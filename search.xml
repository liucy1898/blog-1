<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL(1)--整体架构]]></title>
    <url>%2Fblog%2F2019%2F04%2F11%2FMySQL-1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1. MySQL 整体架构1.1. MySQL 逻辑架构 最上层是通用的 C/S 架构服务架构, 比如连接处理, 权限校验, 安全等. 第二层架构包含了大多数 MySQL 核心服务, 比如查询解析, 分析, 优化, 缓存以及所有的内置函数, 所有跨存储引擎的功能都在这一层实现: 存储过程, 触发器, 视图等. 第三层包含了存储引擎, 负责MySQL 中数据的存储以及读取, 服务器通过 API 和存储引擎进行通信, API 屏蔽了不同存储引擎的差异. 存储引擎 API 包含十几个底层函数, 可以执行如下操作: 开启一个事务, 根据主键查找一行记录 等操作, 不同存储引擎之间也不会相互通信, 只会简单的响应服务器的请求. 1.1.1. 连接/线程的处理和安全性每个客户端连接都会在服务器进程中拥有一个线程, 完全在这个单独的线程中完成操作. 而服务器通过连接池去对线程对缓存. 一旦客户端连接成功, 服务器会验证该客户端是否具有执行具体某个特定查询的权限. 1.1.2. 优化和执行MySQL 会解析查询, 并创建语法解析树以进行优化, 包括重写查询, 决定表的读取顺序, 选择理想的引擎等. 在执行 SELECT 语句的时候, MySQL 会首先检查缓存, 如果缓存中存在, 就不再执行查询解析, 优化和执行的整个过程, 直接返回查询缓存中的结果集. 1.2. 事务事务就是一组原子性的 SQL 查询, 如果数据库引擎能够成功的应用该组查询的全部语句, 那么就全部执行该组操作, 否则如果其中某些语句无法执行, 那么所有的语句就都不执行. 原子性: 一个事务必须被视为一个不可分割的最小工作单元, 整个事务中的所有操作要么全部提交成功, 要么全部不提交, 永远不能出现一部分成功另一部分失败的情况. 一致性: 数据库总是从一个一致性的状态转换到另外一个一致性的状态. 隔离性: 一个事务所做的修改在最终提交之前, 对其他事务都是不可见的, 当然, 这还受隔离级别的影响. 持久性: 一旦事务提交, 其所做的修改就会永久保存到数据库中, 即使系统崩溃也不会丢失. 1.2.1. 隔离级别SQL 标准中定义了四种隔离级别, 每一种级别都规定了一个事务中所做的修改哪些是可见的, 哪些是不可见的. 在我个人的理解中, 用户对数据库的期望其实是自相矛盾的, 一方面人们期望数据库能尽可能快速的完成任务, 另一方面又希望数据库能够尽可能安全的完成任务, 而在目前的数据库模型中, 这是一个本质上无法兼得的情况, 因此诞生了隔离级别, 用于让用户在不同的业务场景下选择最合适的策略去满足需要. 就像机场安全, 机场的安检也有不同级别, 日常情况下安检级别比较低, 吞吐量大; 特殊时期(如遭受恐怖威胁)安检级别更高, 吞吐量较低, 但可以保证安全. Read Uncommitted(读未提交), 事务中的修改即使没有提交对其他事务而言也是可见的. 事务之间可以读取未提交的数据, 被称为脏读, 这个级别会导致很多问题, 从性能上来说其实不会比其他级别好太多, 但缺乏其他级别的优势, 因此一般情况下不会选择. (读写均不加锁) Read Committed(读已提交), 除了 MySQL 外, 大多数数据库的默认隔离级别. 一个事务开始的时候, 只能看到已提交的事务所做的修改, 一个事务从开始到提交之前, 所做的任何修改对其他事务都是不可见的, 这个级别也可以叫不可重复读, 因为两次执行同样的查询, 可能会得到不一样的结果. (读不加锁) Repeatable Read(可重复读), 该级别保证了同一个事务中多次读取同样记录的结果是一致的. 但理论上, 可重复读依然无法解决另一个问题: 幻读. 当某个事务在读取一定范围内的记录时, 另一个事务再该范围内插入了新的记录, 当之前的事务再次读取该范围的记录时, 就会产生幻行. InnoDB 通过 MVCC(多版本并发控制) 解决了幻读问题. Serializable(可串行化), 通过强制事务串行执行, 避免前面提到的所有问题, 包括幻读. 隔离级别 脏读 不可重复读 幻读 加锁读 Read Uncommitted √ √ √ × Read Committed × √ √ × Repeatable Read × × √ × Serializable × × × √ 1.2.2. 死锁当 多个事务 以 不同的顺序 去访问 相同资源 的时候, 就可能产生死锁, 我高亮的部分就是死锁产生的条件. 假设有以下两个语句: 1234567891011-- 事务1START TRANSACTION;UPDATE tb_account set sum = 1000 where user_id = 3;UPDATE tb_account set sum = 2000 where user_id = 4;COMMIT;-- 事务2START TRANSACTION;UPDATE tb_account set sum = 3000 where user_id = 4;UPDATE tb_account set sum = 4000 where user_id = 3;COMMIT; 如果在某个时间点上, 两个事务都执行了第一条 UPDATE 语句, 同时也锁定了各自的第一条语句, 然后开始尝试锁定第二条语句的时候, 却发现已经被其他事务锁定, 此时就会等待释放. 两个事务都等待对方释放锁, 同时又持有对象所需要的锁, 就会陷入一个死循环. 此时就需要由外部检测并介入, 才能够消除死锁. 死锁的消除非常简单, 任意选择一个事务回滚即可, 此时另一个事务获取资源, 就会继续执行下面的操作, InnoDB 目前处理死锁的方法是将持有最少行级排他锁的事务进行回滚. 但相比消除, 如何检测死锁是一个相对更棘手的问题. 1.2.2.1. 被动检测最简单的方式是设定一个阈值: 比如如果有事务的锁定时间超过1分钟, 那么就检测并将其回滚. 但会出现下面两个问题: 假设当前事务确实由于死锁超过阈值, 那从死锁开始到结束必须等到超时才会被处理, 会严重影响数据库的吞吐量. 如果问题更严重一些, 当前事务确实由一系列的复杂操作组成, 没有发生死锁, 但依然超过了我们定义的阈值, 这样的话可能该事务永远得不到执行. 因此设定阈值的方式可能比较简单, 但无法成为一个高效且通用的解决方式. 1.2.2.2. 主动检测InnoDB 使用了一种更为巧妙的方式 wait-for-graph, 通过 等待获取的锁 和 等待获取该锁的事务, 构造出一张有向图, 如果图中存在回路, 就代表存在死锁. InnoDB 将各个事务看成一个个节点, 资源就是各个事务占用的锁, 当事务1需要等待事务2的锁时, 就生成一条有向边从1指向2, 最终形成一个有向图. InnoDB 会定时遍历该图, 一旦发现回路, 就将其中一个回滚, 另一个事务就得以继续执行. 被回滚的事务会返回 “dead lock” 1.2.3. 事务日志事务日志可以帮助提高事务的效率, 使用事务日志, 存储引擎在修改表的时候只需要先在内存中完成, 然后再将修改行为记录到硬盘上的事务日志中, 而不需要每次豆浆修改的数据本身持久化到磁盘. 事务日志采用追加的方式, 在磁盘上的体现就是顺序 IO, 而将数据持久化到磁盘是一个随机 IO 的操作. 因此追加事务日志会更加迅速. 事务日志持久化之后, 内存中被修改的数据可以在后台慢慢刷新回磁盘. 对于事务来说, 为了提高性能, 当修改本身被持久化到事务日志后, 就会返回成功. 如果在持久化修改数据之前系统崩溃, 一般来说数据库在重启的时候会重新检测事务日志有没有被完全消费, 如果没有就会先将未消费的事务日志处理, 以保障事务的持久性. 1.3. 多版本并发控制一般来说, 可以认为 MVCC 是行锁的一个变种, 但在很多情况下避免了加锁操作, 因此开销更低, 大多数都实现了非阻塞的读操作, 写操作也只锁定必要的行. MVCC 的实现时通过保存数据在某个时间点的快照来实现的, 不管需要执行多长时间, 每个事务看到的数据都是一致的, 根据事务开始的时间不同, 每个事务对同一张表同一时刻看到的数据可能是不一样的. InnoDB 的 MVCC, 是通过在每行记录后面保存两个隐藏的字段来实现的, 一个保存了行的创建时间, 另一个保存过期时间. 这个时间指的不是实际时间, 而是系统版本号. 每开始一个新的事务, 系统版本号都会自动递增, 事务开始时刻的系统版本号会作为事务的版本号, 用来和目标行记录的版本号进行比较. 在 Repeatable Read 隔离级别下, MVCC 具体的行为: SELECT: InnoDB 会根据以下两个条件检查每行记录 InnoDB 只查找版本小于等于当前事务版本的数据行, 这样可以确保事务读取的行要么是在事务开始前已经存在的, 要么是事务自身插入或者修改过的. 行的删除版本要么未定义, 要么大于当前事务版本号, 这样可以确保事务读取到的行在事务开始前没有被删除. INSERT: InnoDB 为新插入的每一行保存当前系统版本号作为行版本号. DELETE: InnoDB 为删除的每一行记录保存当前的系统版本号作为行删除标识. UPDATE: InnoDB 为插入一行新记录, 保存当前系统版本号作为行版本号, 同时保存当前系统版本号作为行删除标识. 假设我们定义如下结构: row(n,m)n 为创建时间, m 为过期时间 系统版本号 t1 t2 t3 t4 INSERT row(1,nil) UPDATE row(2,nil)row(1,2) SELECT 搜索条件: n&lt;=3 &amp;&amp; (m==nil \ \ m&gt;3) DELETE row(2,4)row(1,2) 通过保存这两个额外的系统版本号, 使得大多数读操作都不需要加锁, 但系统的复杂度有所上升, 并且需要额外的存储空间. 2. MySQL 数据库设计2.1. 选择合适的数据类型在如何选择合适的数据类型上, 有以下几个普遍适用的原则 更小通常更好, 一般情况下尽量使用可以正确存储数据的最小数据类型, 更小的数据类型通常占用空间更少, 操作起来更加迅速. 越简单越好, 简单数据类型的操作通常需要更少的 CPU 周期, 比如整型比字符串操作代价更低, 因此字符集的排序规则更加复杂 尽量避免 NULL, 对于可能为 NULL 的列, 对 MySQL 来说更加难以优化, 因为这样的列使得索引的建立, 统计都更为复杂, 索引需要为每个记录单独设计一个额外的字节. 2.1.1. 整型常见的整型类型: 类型 占用空间(bit) TINYINT 8 SMALLINT 16 MEDIUMINT 24 INT 32 BIGINT 64 此外, 整数类型还可以选择 UNSIGNED, 用于表示该列不允许负数, 可以使对应的正数范围提升一倍, 原理与 c/c++ 基本相同. MySQL 可以为整型指定宽度, 如 INT(11), 对大多数应用来说都没有意义, 不会限制真正的合法范围, 只是规定了某些客户端用来显示字符的个数. 对于存储和计算来说, INT(1) 和 INT(20) 是完全相同的. 2.1.2. 实数类型实数是带有浮点的数字, 但对于 MySQL, 也可以使用 DECIMAL 存储比 BIGINT 更大的数字. DECIMAL 用于存储精确的小数, 由于 CPU 不支持直接对 DECIMAL 的直接计算, 因此 MySQL 自身实现了 DECIMAL 的高精度计算. CPU 原生支持浮点计算, 因此浮点数 DOUBLE 和 FLOAT 的运算速度更快. 2.1.3. 字符串类型2.1.3.1. VARCHAR 和 CHAR 类型这是两种最主要的字符串类型 VARCHAR: 用于存储变长字符串, 是最常见的字符串类型, 比定长字符串更节省空间, 需要使用 1 或 2 个额外字节来记录字符串的长度, 如果列的长度小于或等于 255 个字节, 就只需要 1 个字节, 否则需要 2 个字节. VARCHAR 节省了空间, 但由于 UPDATE 的时候可能使得对应行记录变得更长, 就需要额外的工作, 如果在页内没有更多空间的情况下发生, 在 InnoDB 中需要分裂页来使记录可以放进页内. CHAR: 定长类型, 适合存储很短的字符串, 或者所有的值都近乎一个长度, 定长的 CHAR 不容易产生碎片. 对于 ‘hello’ 的存储, VARCHAR(5) 相比 VARCHAR(200) 更有优势, 因为 MySQL 通常会分配固定大小的内存块来保存内部值, 尤其是使用内存临时表进行排序或操作时会特别糟糕. 2.1.3.2 BLOB 和 TEXT 类型二者都是为存储很大类型数据而设计的字符串数据类型, 分别采用二进制和字符方式存储. 字符串系列 二进制系列 TINYTEXT TINYBLOB SMALLTEXT SMALLBLOB TEXT BLOB MEDIUMTEXT MEDIUMBLOB LONGTEXT LONGBLOB MySQL 把每个 BLOB 和 TEXT 当做一个独立的对象处理, 存储引擎在存储时通常会做特殊处理, 如果值过大, InnoDB 会使用专门的 “外部” 存储区域来进行存储, 此时每个值在行内需要 1~4个字节存储一个指针, 然后再外部存储区域存储实际的值. 此外, 在排序上, MySQL 对于这两种类型只能对最前 max_sort_length 字节而不是整个字符串进行排序. 2.1.4. 日期是时间类型3. 高性能索引]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(9)-XML解析]]></title>
    <url>%2Fblog%2F2019%2F04%2F08%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-9-XML%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. XML 解析1.1. DOM 模型 优点: 文档解析的时候允许客户端编辑和更新 XML 文档的内容, 并可以随机访问文档中定义的元素数据. 缺点: 文档解析的时候需要将 XML 一次性加载到内存, 进而映射成 Document 对象中的树形结构, 在解析大文件的时候内存占用大, 元素遍历查找慢, 性能容易成为瓶颈. 1.2. SAX 模型 优点: 该方式解析文档的时候, 每一次操作只会将解析的节点放置到内存中, 从头部开始, 读取一段处理一段, 内存占用小. 缺点: 解析文档的时候文档是只读的, 不能编辑, 并且文件流只能前进不能后退 在 Activiti 中, 由于 XML 完全由用户的输入决定, 无法控制器大小, 因此选用 SAX 模型 2. 文档转换器文档转换器可以将文档转换为 BpmnModel, 也可以将 BpmnModel 转换为文档 文档解析器: BpmnXMLConverter 解析器内部持有所有 元素解析器 元素解析器与元素之间一一对应 任务节点的元素名称是 UserTask, 因此对应的解析器为 UserTaskXMLConverter 连线的元素名称是 SequenceFlow, 对应的解析器为 SequenceFlowXMLConverter]]></content>
      <categories>
        <category>Activiti</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(7)-ID生成器]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-ID%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. DbIdGenerator Activiti 默认采用数据库来实现强一致的发号器 DbIdGenerator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class DbIdGenerator implements IdGenerator &#123; protected int idBlockSize; protected long nextId; protected long lastId = -1; protected CommandExecutor commandExecutor; protected CommandConfig commandConfig; public synchronized String getNextId() &#123; if (lastId &lt; nextId) &#123; getNewBlock(); &#125; long _nextId = nextId++; return Long.toString(_nextId); &#125; protected synchronized void getNewBlock() &#123; IdBlock idBlock = commandExecutor.execute(commandConfig, new GetNextIdBlockCmd(idBlockSize)); this.nextId = idBlock.getNextId(); this.lastId = idBlock.getLastId(); &#125; public int getIdBlockSize() &#123; return idBlockSize; &#125; public void setIdBlockSize(int idBlockSize) &#123; this.idBlockSize = idBlockSize; &#125; public CommandExecutor getCommandExecutor() &#123; return commandExecutor; &#125; public void setCommandExecutor(CommandExecutor commandExecutor) &#123; this.commandExecutor = commandExecutor; &#125; public CommandConfig getCommandConfig() &#123; return commandConfig; &#125; public void setCommandConfig(CommandConfig commandConfig) &#123; this.commandConfig = commandConfig; &#125;&#125; DbIdGenerator 实现了 getNextId 方法, 用于对应用范围内所有的实体对象分配 id, 我们就以这个方法为起点, 分析默认的发号器逻辑. 1.1. DbIdGenerator#getNextId()1234567public synchronized String getNextId() &#123; if (lastId &lt; nextId) &#123; getNewBlock(); &#125; long _nextId = nextId++; return Long.toString(_nextId);&#125; 比较内部持有的两个布局变量 lastId 和 nextId 如果 lastId 已经小于 nextId 获取一个新的 Block 获得当前的 _nextId, 并转换成字符串, 同时持有的局部变量 nextId 自增 1.2. DbIdGenerator#getNewBlock()12345protected synchronized void getNewBlock() &#123; IdBlock idBlock = commandExecutor.execute(commandConfig, new GetNextIdBlockCmd(idBlockSize)); this.nextId = idBlock.getNextId(); this.lastId = idBlock.getLastId();&#125; 获取一个新的 IdBlock 对象 分别将该对象的 nextId 和 lastId 赋值给自身持有的同名字段 1.3. GetNextIdBlockCmd#execute(CommandContext commandContext)1234567public IdBlock execute(CommandContext commandContext) &#123; PropertyEntity property = (PropertyEntity) commandContext.getPropertyEntityManager().findById("next.dbid"); long oldValue = Long.parseLong(property.getValue()); long newValue = oldValue + idBlockSize; property.setValue(Long.toString(newValue)); return new IdBlock(oldValue, newValue - 1);&#125; 调用 PropertyEntityManager, 从 ACT_GE_PROPERTY 表中获取 next.dbid 字段的值 将旧值转换成 long 类型并增加 idBlockSize 长度得到新值, 其中 idBlockSize 通过调用链追踪到在 ProcessEngineConfiguration 将其设置为 2500, 并调用命令类的初始化 将新值设置进查询到的 property 对象 返回新的 IdBlock 对象]]></content>
      <categories>
        <category>Activiti</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(8)-发起流程实例]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-%E5%8F%91%E8%B5%B7%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1. 概念1.1. 启动流程 操作数据库的 ACT_RU_EXECUTION 表, 如果是用户任务节点, 同时也会在 ACT_RU_TASK 表添加一条记录; 1.2. 流程实例 代表流程定义的执行实例 一个流程实例包括了所有的运行节点 流程实例表示一个流程从开始到结束的最大流程分支 流程实例也被称为执行实例根节点 在 Activiti 对应的接口为: 123public interface ProcessInstance extends Execution &#123; // ...&#125; 可以看出 ProcessInstance 就是 Execution 1.3. 执行实例 启动流程的时候会首先创建流程实例, 然后创建执行实例 流程运转的过程中永远执行的是自己对应的执行实例 当所有的执行实例按照规则完毕之后, 对应的流程随之结束 Activiti 使用 Execution 对象去描述流程执行的每一个节点 流程按照流程定义的规则执行一次的过程, 就可以表示执行对象 Execution 一个流程中, 执行对象可以存在多个, 但流程实例只能有一个 执行实例的父级 / 父级的父级为流程实例 1.4. 概念演示1.4.1. 简单流程实例 发起流程的时候, 会先创建一个流程实例, 然后创建执行实例; 随着流程的运转, 执行实例会不断更新; 直到流程执行完毕(走到结束节点), 对应执行实例会结束, 此时流程实例也结束. 1.4.2. 有分支的流程实例 当流程进入并行网关之后, 会创建两个执行实例 当两个执行实例都结束之后, 再创建第三个执行实例 2. RuntimeServiceImpl#startProcessInstanceByKey(String processDefinitionKey)123public ProcessInstance startProcessInstanceByKey(String processDefinitionKey) &#123; return commandExecutor.execute(new StartProcessInstanceCmd&lt;ProcessInstance&gt;(processDefinitionKey, null, null, null));&#125; 2.1. StartProcessInstanceCmd#execution(CommandContext commandContext)1234567891011121314151617181920212223242526272829303132333435public ProcessInstance execute(CommandContext commandContext) &#123; DeploymentManager deploymentCache = commandContext.getProcessEngineConfiguration().getDeploymentManager(); // Find the process definition ProcessDefinition processDefinition = null; if (processDefinitionId != null) &#123; processDefinition = deploymentCache.findDeployedProcessDefinitionById(processDefinitionId); if (processDefinition == null) &#123; throw new ActivitiObjectNotFoundException("No process definition found for id = '" + processDefinitionId + "'", ProcessDefinition.class); &#125; &#125; else if (processDefinitionKey != null &amp;&amp; (tenantId == null || ProcessEngineConfiguration.NO_TENANT_ID.equals(tenantId))) &#123; processDefinition = deploymentCache.findDeployedLatestProcessDefinitionByKey(processDefinitionKey); if (processDefinition == null) &#123; throw new ActivitiObjectNotFoundException("No process definition found for key '" + processDefinitionKey + "'", ProcessDefinition.class); &#125; &#125; else if (processDefinitionKey != null &amp;&amp; tenantId != null &amp;&amp; !ProcessEngineConfiguration.NO_TENANT_ID.equals(tenantId)) &#123; processDefinition = deploymentCache.findDeployedLatestProcessDefinitionByKeyAndTenantId(processDefinitionKey, tenantId); if (processDefinition == null) &#123; throw new ActivitiObjectNotFoundException("No process definition found for key '" + processDefinitionKey + "' for tenant identifier " + tenantId, ProcessDefinition.class); &#125; &#125; else &#123; throw new ActivitiIllegalArgumentException("processDefinitionKey and processDefinitionId are null"); &#125; processInstanceHelper = commandContext.getProcessEngineConfiguration().getProcessInstanceHelper(); ProcessInstance processInstance = createAndStartProcessInstance(processDefinition, businessKey, processInstanceName, variables, transientVariables); return processInstance;&#125; 初始化 processDefinition 对象, 由于 startProcessInstanceByXX 系列方法有多种参数, 因此一下三种条件都可以实现: 如果 processDefinitionId 不为空, 通过该 id 查询流程定义; 如果 processDefinitionKey 不为空, 并且 tenantId 为空, 就通过 processDefinitionKey 查询最新的流程定义; 如果 processDefinitionKey 不为空, 并且 tenantId 也不为空, 就通过这两个参数一起查询最新的流程定义; 获取 processInstanceHelper 对象 执行创建流程逻辑并返回 2.2. StartProcessInstanceCmd#createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String,Object&gt; variables, Map&lt;String, Object&gt; transientVariables)参数较多, 先解释下参数: processDefinition: 流程定义对象 businessKey: 业务标识 processInstanceName: 需要设置的流程名称 variables: 表单数据(会持久化到变量表中) transientVariables: 不需要持久化的变量表 1234protected ProcessInstance createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String,Object&gt; variables, Map&lt;String, Object&gt; transientVariables) &#123; return processInstanceHelper.createAndStartProcessInstance(processDefinition, businessKey, processInstanceName, variables, transientVariables);&#125; 2.3. ProcessInstanceHelper#createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance)123456789101112131415161718192021222324252627282930protected ProcessInstance createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance) &#123; CommandContext commandContext = Context.getCommandContext(); // Todo: ideally, context should be passed here if (Activiti5Util.isActiviti5ProcessDefinition(commandContext, processDefinition)) &#123; Activiti5CompatibilityHandler activiti5CompatibilityHandler = Activiti5Util.getActiviti5CompatibilityHandler(); return activiti5CompatibilityHandler.startProcessInstance(processDefinition.getKey(), processDefinition.getId(), variables, businessKey, processDefinition.getTenantId(), processInstanceName); &#125; // Do not start process a process instance if the process definition is suspended if (ProcessDefinitionUtil.isProcessDefinitionSuspended(processDefinition.getId())) &#123; throw new ActivitiException("Cannot start process instance. Process definition " + processDefinition.getName() + " (id = " + processDefinition.getId() + ") is suspended"); &#125; // Get model from cache Process process = ProcessDefinitionUtil.getProcess(processDefinition.getId()); if (process == null) &#123; throw new ActivitiException("Cannot start process instance. Process model " + processDefinition.getName() + " (id = " + processDefinition.getId() + ") could not be found"); &#125; FlowElement initialFlowElement = process.getInitialFlowElement(); if (initialFlowElement == null) &#123; throw new ActivitiException("No start element found for process definition " + processDefinition.getId()); &#125; return createAndStartProcessInstanceWithInitialFlowElement(processDefinition, businessKey, processInstanceName, initialFlowElement, process, variables, transientVariables, startProcessInstance); &#125; 如果流程定义是 Activiti5 风格的, 执行 Activiti5 相关的兼容代码 如果流程定义已经被挂起, 那么抛出异常 根据 processDefinitionId 获取 Process 对象, 如果失败抛出异常 获取 Process 对象的 initialFlowElement 创建并开启流程实例, 并返回结果 2.3.1. ProcessDefinitionUtil#getProcess(String processDefinitionId)123456789101112public static Process getProcess(String processDefinitionId) &#123; if (Context.getProcessEngineConfiguration() == null) &#123; return Activiti5Util.getActiviti5CompatibilityHandler().getProcessDefinitionProcessObject(processDefinitionId); &#125; else &#123; DeploymentManager deploymentManager = Context.getProcessEngineConfiguration().getDeploymentManager(); // This will check the cache in the findDeployedProcessDefinitionById and resolveProcessDefinition method ProcessDefinition processDefinitionEntity = deploymentManager.findDeployedProcessDefinitionById(processDefinitionId); return deploymentManager.resolveProcessDefinition(processDefinitionEntity).getProcess(); &#125;&#125; 2.3.2. DeploymentManager#findDeployedProcessDefinitionById(String processDefinitionId)123456789101112131415161718public ProcessDefinition findDeployedProcessDefinitionById(String processDefinitionId) &#123; if (processDefinitionId == null) &#123; throw new ActivitiIllegalArgumentException("Invalid process definition id : null"); &#125; // first try the cache ProcessDefinitionCacheEntry cacheEntry = processDefinitionCache.get(processDefinitionId); ProcessDefinition processDefinition = cacheEntry != null ? cacheEntry.getProcessDefinition() : null; if (processDefinition == null) &#123; processDefinition = processDefinitionEntityManager.findById(processDefinitionId); if (processDefinition == null) &#123; throw new ActivitiObjectNotFoundException("no deployed process definition found with id '" + processDefinitionId + "'", ProcessDefinition.class); &#125; processDefinition = resolveProcessDefinition(processDefinition).getProcessDefinition(); &#125; return processDefinition;&#125; 首先从缓存中查找 如果缓存没有, 继续从 DB 中查找 将 ProcessDefinition 转换为 Process 并返回 2.3.3. DeploymentManager#resolveProcessDefinition(ProcessDefinition processDefinition)12345678910111213141516171819202122232425public ProcessDefinitionCacheEntry resolveProcessDefinition(ProcessDefinition processDefinition) &#123; String processDefinitionId = processDefinition.getId(); String deploymentId = processDefinition.getDeploymentId(); ProcessDefinitionCacheEntry cachedProcessDefinition = processDefinitionCache.get(processDefinitionId); if (cachedProcessDefinition == null) &#123; CommandContext commandContext = Context.getCommandContext(); if (commandContext.getProcessEngineConfiguration().isActiviti5CompatibilityEnabled() &amp;&amp; Activiti5Util.isActiviti5ProcessDefinition(Context.getCommandContext(), processDefinition)) &#123; return Activiti5Util.getActiviti5CompatibilityHandler().resolveProcessDefinition(processDefinition); &#125; DeploymentEntity deployment = deploymentEntityManager.findById(deploymentId); deployment.setNew(false); deploy(deployment, null); cachedProcessDefinition = processDefinitionCache.get(processDefinitionId); if (cachedProcessDefinition == null) &#123; throw new ActivitiException("deployment '" + deploymentId + "' didn't put process definition '" + processDefinitionId + "' in the cache"); &#125; &#125; return cachedProcessDefinition;&#125; 首先尝试从缓存中获取流程定义 如果为空 如果是 Activiti5 风格的配置 通过 Activiti5 的方式获取并返回 尝试从 DB 中获取, 补充到缓存中 再从缓存中获取 返回 2.4. ProcessInstanceHelper#createAndStartProcessInstanceWithInitialFlowElement(ProcessDefinition processDefinition, String businessKey, String processInstanceName, FlowElement initialFlowElement, Process process, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public ProcessInstance createAndStartProcessInstanceWithInitialFlowElement(ProcessDefinition processDefinition, String businessKey, String processInstanceName, FlowElement initialFlowElement, Process process, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance) &#123; CommandContext commandContext = Context.getCommandContext(); // Create the process instance String initiatorVariableName = null; if (initialFlowElement instanceof StartEvent) &#123; initiatorVariableName = ((StartEvent) initialFlowElement).getInitiator(); &#125; ExecutionEntity processInstance = commandContext.getExecutionEntityManager() .createProcessInstanceExecution(processDefinition, businessKey, processDefinition.getTenantId(), initiatorVariableName); commandContext.getHistoryManager().recordProcessInstanceStart(processInstance, initialFlowElement); processInstance.setVariables(processDataObjects(process.getDataObjects())); // Set the variables passed into the start command if (variables != null) &#123; for (String varName : variables.keySet()) &#123; processInstance.setVariable(varName, variables.get(varName)); &#125; &#125; if (transientVariables != null) &#123; for (String varName : transientVariables.keySet()) &#123; processInstance.setTransientVariable(varName, transientVariables.get(varName)); &#125; &#125; // Set processInstance name if (processInstanceName != null) &#123; processInstance.setName(processInstanceName); commandContext.getHistoryManager().recordProcessInstanceNameChange(processInstance.getId(), processInstanceName); &#125; // Fire events if (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123; Context.getProcessEngineConfiguration().getEventDispatcher() .dispatchEvent(ActivitiEventBuilder.createEntityWithVariablesEvent(ActivitiEventType.ENTITY_INITIALIZED, processInstance, variables, false)); &#125; // Create the first execution that will visit all the process definition elements ExecutionEntity execution = commandContext.getExecutionEntityManager().createChildExecution(processInstance); execution.setCurrentFlowElement(initialFlowElement); if (startProcessInstance) &#123; startProcessInstance(processInstance, commandContext, variables); &#125; return processInstance;&#125; 创建流程实例(父级 Execution) 在历史流程表中将流程实例标记为开始 将所有 DataObject 转换为 Map&lt;String, Object&gt;, 并设置为流程实例的变量 将创建流程时填入的表单信息设置为变量 为流程变量设置名称 触发事件 创建第一个将访问所有流程定义元素的 Execution 并将该 Execution 对象的当前元素设置为传入的初始化元素 如果需要立即开启 调用开启流程实例方法 返回该流程实例 2.4.1. ExecutionEntityManagerImpl#createProcessInstanceExecution(ProcessDefinition processDefinition, String businessKey, String tenantId, String initiatorVariableName)123456789101112131415161718192021222324252627282930313233343536373839404142434445public ExecutionEntity createProcessInstanceExecution(ProcessDefinition processDefinition, String businessKey, String tenantId, String initiatorVariableName) &#123; ExecutionEntity processInstanceExecution = executionDataManager.create(); if (isExecutionRelatedEntityCountEnabledGlobally()) &#123; ((CountingExecutionEntity) processInstanceExecution).setCountEnabled(true); &#125; processInstanceExecution.setProcessDefinitionId(processDefinition.getId()); processInstanceExecution.setProcessDefinitionKey(processDefinition.getKey()); processInstanceExecution.setProcessDefinitionName(processDefinition.getName()); processInstanceExecution.setProcessDefinitionVersion(processDefinition.getVersion()); processInstanceExecution.setBusinessKey(businessKey); processInstanceExecution.setScope(true); // process instance is always a scope for all child executions // Inherit tenant id (if any) if (tenantId != null) &#123; processInstanceExecution.setTenantId(tenantId); &#125; String authenticatedUserId = Authentication.getAuthenticatedUserId(); processInstanceExecution.setStartTime(Context.getProcessEngineConfiguration().getClock().getCurrentTime()); processInstanceExecution.setStartUserId(authenticatedUserId); // Store in database insert(processInstanceExecution, false); if (initiatorVariableName != null) &#123; processInstanceExecution.setVariable(initiatorVariableName, authenticatedUserId); &#125; // Need to be after insert, cause we need the id processInstanceExecution.setProcessInstanceId(processInstanceExecution.getId()); processInstanceExecution.setRootProcessInstanceId(processInstanceExecution.getId()); if (authenticatedUserId != null) &#123; getIdentityLinkEntityManager().addIdentityLink(processInstanceExecution, authenticatedUserId, null, IdentityLinkType.STARTER); &#125; // Fire events if (getEventDispatcher().isEnabled()) &#123; getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, processInstanceExecution)); &#125; return processInstanceExecution;&#125; 创建一个新的 ExecutionEntity 对象并初始化 获取创建人 ID 和开始时间 插入该 ExecutionEntity 触发事件 2.4.2. DefaultHistoryManager#recordProcessInstanceStart(ExecutionEntity processInstance, FlowElement startElement)12345678910111213141516public void recordProcessInstanceStart(ExecutionEntity processInstance, FlowElement startElement) &#123; if (isHistoryLevelAtLeast(HistoryLevel.ACTIVITY)) &#123; HistoricProcessInstanceEntity historicProcessInstance = getHistoricProcessInstanceEntityManager().create(processInstance); historicProcessInstance.setStartActivityId(startElement.getId()); // Insert historic process-instance getHistoricProcessInstanceEntityManager().insert(historicProcessInstance, false); // Fire event ActivitiEventDispatcher activitiEventDispatcher = getEventDispatcher(); if (activitiEventDispatcher != null &amp;&amp; activitiEventDispatcher.isEnabled()) &#123; activitiEventDispatcher.dispatchEvent( ActivitiEventBuilder.createEntityEvent(ActivitiEventType.HISTORIC_PROCESS_INSTANCE_CREATED, historicProcessInstance)); &#125; &#125;&#125; 根据传入的 processInstance 构造 HistoricProcessInstanceEntity 对象 向历史表插入该对象 将给定的事件分派给任何已注册的侦听器 2.4.3. ExecutionEntityManagerImpl#createChildExecution(ExecutionEntity parentExecutionEntity)创建第一个将访问所有流程定义元素的执行对象 123456789101112131415161718192021222324252627public ExecutionEntity createChildExecution(ExecutionEntity parentExecutionEntity) &#123; ExecutionEntity childExecution = executionDataManager.create(); inheritCommonProperties(parentExecutionEntity, childExecution); childExecution.setParent(parentExecutionEntity); childExecution.setProcessDefinitionId(parentExecutionEntity.getProcessDefinitionId()); childExecution.setProcessDefinitionKey(parentExecutionEntity.getProcessDefinitionKey()); childExecution.setProcessInstanceId(parentExecutionEntity.getProcessInstanceId() != null ? parentExecutionEntity.getProcessInstanceId() : parentExecutionEntity.getId()); childExecution.setScope(false); // manage the bidirectional parent-child relation parentExecutionEntity.addChildExecution(childExecution); // Insert the child execution insert(childExecution, false); if (logger.isDebugEnabled()) &#123; logger.debug("Child execution &#123;&#125; created with parent &#123;&#125;", childExecution, parentExecutionEntity.getId()); &#125; if (getEventDispatcher().isEnabled()) &#123; getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, childExecution)); getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_INITIALIZED, childExecution)); &#125; return childExecution; &#125; 创建一个新的 ExecutionEntity 对象, 并继承父 ExecutionEntity 的公共配置 设置父子关系 插入子 ExecutionEntity 将指定事件分派给已注册的监听器 2.4.4. ExecutionEntityManagerImpl#startProcessInstance(ExecutionEntity processInstance, CommandContext commandContext, Map&lt;String, Object&gt; variables)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void startProcessInstance(ExecutionEntity processInstance, CommandContext commandContext, Map&lt;String, Object&gt; variables) &#123; Process process = ProcessDefinitionUtil.getProcess(processInstance.getProcessDefinitionId()); // Event sub process handling List&lt;MessageEventSubscriptionEntity&gt; messageEventSubscriptions = new LinkedList&lt;&gt;(); for (FlowElement flowElement : process.getFlowElements()) &#123; if (flowElement instanceof EventSubProcess) &#123; EventSubProcess eventSubProcess = (EventSubProcess) flowElement; for (FlowElement subElement : eventSubProcess.getFlowElements()) &#123; if (subElement instanceof StartEvent) &#123; StartEvent startEvent = (StartEvent) subElement; if (CollectionUtil.isNotEmpty(startEvent.getEventDefinitions())) &#123; EventDefinition eventDefinition = startEvent.getEventDefinitions().get(0); if (eventDefinition instanceof MessageEventDefinition) &#123; MessageEventDefinition messageEventDefinition = (MessageEventDefinition) eventDefinition; BpmnModel bpmnModel = ProcessDefinitionUtil.getBpmnModel(processInstance.getProcessDefinitionId()); if (bpmnModel.containsMessageId(messageEventDefinition.getMessageRef())) &#123; messageEventDefinition.setMessageRef(bpmnModel.getMessage(messageEventDefinition.getMessageRef()).getName()); &#125; ExecutionEntity messageExecution = commandContext.getExecutionEntityManager().createChildExecution(processInstance); messageExecution.setCurrentFlowElement(startEvent); messageExecution.setEventScope(true); messageEventSubscriptions .add(commandContext.getEventSubscriptionEntityManager().insertMessageEvent(messageEventDefinition.getMessageRef(), messageExecution)); &#125; &#125; &#125; &#125; &#125; &#125; ExecutionEntity execution = processInstance.getExecutions().get(0); // There will always be one child execution created commandContext.getAgenda().planContinueProcessOperation(execution); if (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123; ActivitiEventDispatcher eventDispatcher = Context.getProcessEngineConfiguration().getEventDispatcher(); eventDispatcher.dispatchEvent(ActivitiEventBuilder.createProcessStartedEvent(execution, variables, false)); for (MessageEventSubscriptionEntity messageEventSubscription : messageEventSubscriptions) &#123; commandContext.getProcessEngineConfiguration().getEventDispatcher() .dispatchEvent(ActivitiEventBuilder.createMessageEvent(ActivitiEventType.ACTIVITY_MESSAGE_WAITING, messageEventSubscription.getActivityId(), messageEventSubscription.getEventName(), null, messageEventSubscription.getExecution().getId(), messageEventSubscription.getProcessInstanceId(), messageEventSubscription.getProcessDefinitionId())); &#125; &#125;&#125; 获取流程对象 找到所有的子流程的开始事件, 并查找开始事件的事件定义来收集所有的消息事件 获取当前 ExecutionEntity 的第一个子对象, 并由该子对象开始执行 开始流程后, 继续进行将给定的事件分派给任何已注册的侦听器的操作]]></content>
      <categories>
        <category>Activiti</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(6)--RepositoryService(仓库服务类)模型校验]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-RepositoryService-%E4%BB%93%E5%BA%93%E6%9C%8D%E5%8A%A1%E7%B1%BB-%E6%A8%A1%E5%9E%8B%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445 @Test public void testBpmnModel() throws UnsupportedEncodingException &#123; BpmnModel bpmnModel = new BpmnModel(); Process process = new Process(); process.setId("my-process"); StartEvent startEvent = new StartEvent(); startEvent.setId("startEvent"); UserTask someTask = new UserTask(); someTask.setId("someTask"); someTask.setName("Activiti is awesome!"); someTask.setAssignee("$&#123;user&#125;"); MultiInstanceLoopCharacteristics multiInstanceLoopCharacteristics = new MultiInstanceLoopCharacteristics(); multiInstanceLoopCharacteristics.setSequential(false); multiInstanceLoopCharacteristics.setInputDataItem("$&#123;usersBean.getUsers(name)&#125;"); multiInstanceLoopCharacteristics.setElementVariable("user"); multiInstanceLoopCharacteristics.setCompletionCondition("$&#123;nrOfCompletedInstances &gt; 0&#125;"); someTask.setLoopCharacteristics(multiInstanceLoopCharacteristics); EndEvent endEvent = new EndEvent(); endEvent.setId("endEvent"); SequenceFlow flow1 = createSequence("startEvent", "someTask", "flow1", "flow1", null); SequenceFlow flow2 = createSequence("someTask", "endEvent", "flow2", "flow2", null); process.addFlowElement(startEvent); process.addFlowElement(someTask); process.addFlowElement(endEvent); process.addFlowElement(flow1); process.addFlowElement(flow2); bpmnModel.addProcess(process); byte[] bytes = new BpmnXMLConverter().convertToXML(bpmnModel); String s = new String(bytes, "utf-8"); log.info(s); ProcessValidatorFactory processValidatorFactory = new ProcessValidatorFactory(); ProcessValidator defaultProcessValidator = processValidatorFactory.createDefaultProcessValidator(); List&lt;ValidationError&gt; validate = defaultProcessValidator.validate(bpmnModel); log.info("validate: &#123;&#125;", validate); &#125;&#125; 生成的 XMl 文件:1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process" isExecutable="true"&gt; &lt;startEvent id="startEvent"&gt;&lt;/startEvent&gt; &lt;userTask id="someTask" name="Activiti is awesome!" activiti:assignee="$&#123;user&#125;"&gt; &lt;multiInstanceLoopCharacteristics isSequential="false" activiti:collection="$&#123;usersBean.getUsers(name)&#125;" activiti:elementVariable="user"&gt; &lt;completionCondition&gt;$&#123;nrOfCompletedInstances &amp;gt; 0&#125;&lt;/completionCondition&gt; &lt;/multiInstanceLoopCharacteristics&gt; &lt;/userTask&gt; &lt;endEvent id="endEvent"&gt;&lt;/endEvent&gt; &lt;sequenceFlow id="flow1" name="flow1" sourceRef="startEvent" targetRef="someTask"&gt;&lt;/sequenceFlow&gt; &lt;sequenceFlow id="flow2" name="flow2" sourceRef="someTask" targetRef="endEvent"&gt;&lt;/sequenceFlow&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram id="BPMNDiagram_my-process"&gt; &lt;bpmndi:BPMNPlane bpmnElement="my-process" id="BPMNPlane_my-process"&gt;&lt;/bpmndi:BPMNPlane&gt; &lt;/bpmndi:BPMNDiagram&gt;&lt;/definitions&gt; validate 的结果validate: [] 代表当前流程正常, 没有错误 1. ProcessValidatorFactory#createDefaultProcessValidator()12345public ProcessValidator createDefaultProcessValidator() &#123; ProcessValidatorImpl processValidator = new ProcessValidatorImpl(); processValidator.addValidatorSet(new ValidatorSetFactory().createActivitiExecutableProcessValidatorSet()); return processValidator;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(5)--RepositoryService(仓库服务类)classpath资源部署]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-RepositoryService-%E4%BB%93%E5%BA%93%E6%9C%8D%E5%8A%A1%E7%B1%BB-classpath%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[RepositoryService 是 Activiti 的仓库服务类, 仓库指的是流程定义文档的两个文件: BPMN 文件和流程图片 获得方式: 1RepositoryService repositoryService = processEngine.getRepositoryService(); 其实现类为: RepositoryServiceImpl 可以产生 DeploymentBuilder, 用来产生定义流程部署的相关参数 1Deployment deployment = repositoryService.createDeployment(); 1. classpath 部署方式说明 先获取流程引擎对象, 在创建时会自动加载 classpath 下的 activiti.cfg.xml 首先获得默认的流程引擎, 通过流程引擎获取一个 RepositoryService 对象 由仓库的服务对象产生一个部署对象配置对象, 用来封装部署操作的相关配置 链式编程, 在部署的配置对象中设置显示名, 上传流程定义规则文件 向数据库中存放流程定义的规则信息 测试代码 1234567891011@Testpublic void test() &#123; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); Deployment deployment = processEngine.getRepositoryService() .createDeployment() .name("my-process") .addClasspathResource("process/my-process.bpmn20.xml") .deploy(); log.info("deployment: &#123;&#125;", deployment);&#125; 1.1. DeploymentBuilderImpl#addClasspathResource(String resource)1234567public DeploymentBuilder addClasspathResource(String resource) &#123; InputStream inputStream = ReflectUtil.getResourceAsStream(resource); if (inputStream == null) &#123; throw new ActivitiIllegalArgumentException("resource '" + resource + "' not found"); &#125; return addInputStream(resource, inputStream);&#125; 通过资源路径获取输入流 添加输入流并返回 1.1.1. ReflectUtil.getResourceAsStream(String name)12345678910111213141516171819public static InputStream getResourceAsStream(String name) &#123; InputStream resourceStream = null; ClassLoader classLoader = getCustomClassLoader(); if (classLoader != null) &#123; resourceStream = classLoader.getResourceAsStream(name); &#125; if (resourceStream == null) &#123; // Try the current Thread context classloader classLoader = Thread.currentThread().getContextClassLoader(); resourceStream = classLoader.getResourceAsStream(name); if (resourceStream == null) &#123; // Finally, try the classloader for this class classLoader = ReflectUtil.class.getClassLoader(); resourceStream = classLoader.getResourceAsStream(name); &#125; &#125; return resourceStream;&#125; 获取自定义类加载器 如果类加载器不为空, 获取 classpath 路径下的资源 如果资源为空, 重新获取当前线程的类加载器, 再次尝试获取 classpath 下的资源 如果资源依然为空, 再获取当前类的类加载器再次尝试获取 classpath 下的资源 返回 1.2. DeploymentBuilderImpl#addInputStream(String resourceName, InputStream inputStream)1234567891011public DeploymentBuilder addInputStream(String resourceName, InputStream inputStream) &#123; if (inputStream == null) &#123; throw new ActivitiIllegalArgumentException("inputStream for resource '" + resourceName + "' is null"); &#125; byte[] bytes = IoUtil.readInputStream(inputStream, resourceName); ResourceEntity resource = resourceEntityManager.create(); resource.setName(resourceName); resource.setBytes(bytes); deployment.addResource(resource); return this;&#125; 将输入流转化为字节数组 创建一个 ResourceEntity 实例对象, 并设置名称和字节数组 为 deployment 对象添加资源, 其内部包含一个 Map&lt;String, ResourceEntity&gt; 的属性 返回当前对象(DeploymentBuilder) 1.2.1. IoUtil#readInputStream(InputStream inputStream, String inputStreamName)1234567891011121314public static byte[] readInputStream(InputStream inputStream, String inputStreamName) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[16 * 1024]; try &#123; int bytesRead = inputStream.read(buffer); while (bytesRead != -1) &#123; outputStream.write(buffer, 0, bytesRead); bytesRead = inputStream.read(buffer); &#125; &#125; catch (Exception e) &#123; throw new ActivitiException("couldn't read input stream " + inputStreamName, e); &#125; return outputStream.toByteArray();&#125; 1.3. DeploymentEntityImpl#addResource(ResourceEntity resource)123456public void addResource(ResourceEntity resource) &#123; if (resources == null) &#123; resources = new HashMap&lt;String, ResourceEntity&gt;(); &#125; resources.put(resource.getName(), resource);&#125; 1.4. RepositoryServiceImpl#deploy()123public Deployment deploy(DeploymentBuilderImpl deploymentBuilder) &#123; return commandExecutor.execute(new DeployCmd&lt;Deployment&gt;(deploymentBuilder));&#125; 1.5. DeployCmd#execute(CommandContext commandContext)12345678910111213public Deployment execute(CommandContext commandContext) &#123; // Backwards compatibility with Activiti v5 if (commandContext.getProcessEngineConfiguration().isActiviti5CompatibilityEnabled() &amp;&amp; deploymentBuilder.getDeploymentProperties() != null &amp;&amp; deploymentBuilder.getDeploymentProperties().containsKey(DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION) &amp;&amp; deploymentBuilder.getDeploymentProperties().get(DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION).equals(Boolean.TRUE)) &#123; return deployAsActiviti5ProcessDefinition(commandContext); &#125; return executeDeploy(commandContext);&#125; 1.6. DeployCmd#executeDeploy(CommandContext commandContext)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859protected Deployment executeDeploy(CommandContext commandContext) &#123; DeploymentEntity deployment = deploymentBuilder.getDeployment(); deployment.setDeploymentTime(commandContext.getProcessEngineConfiguration().getClock().getCurrentTime()); if (deploymentBuilder.isDuplicateFilterEnabled()) &#123; List&lt;Deployment&gt; existingDeployments = new ArrayList&lt;Deployment&gt;(); if (deployment.getTenantId() == null || ProcessEngineConfiguration.NO_TENANT_ID.equals(deployment.getTenantId())) &#123; DeploymentEntity existingDeployment = commandContext.getDeploymentEntityManager().findLatestDeploymentByName(deployment.getName()); if (existingDeployment != null) &#123; existingDeployments.add(existingDeployment); &#125; &#125; else &#123; List&lt;Deployment&gt; deploymentList = commandContext.getProcessEngineConfiguration().getRepositoryService().createDeploymentQuery().deploymentName(deployment.getName()) .deploymentTenantId(deployment.getTenantId()).orderByDeploymentId().desc().list(); if (!deploymentList.isEmpty()) &#123; existingDeployments.addAll(deploymentList); &#125; &#125; DeploymentEntity existingDeployment = null; if (!existingDeployments.isEmpty()) &#123; existingDeployment = (DeploymentEntity) existingDeployments.get(0); &#125; if ((existingDeployment != null) &amp;&amp; !deploymentsDiffer(deployment, existingDeployment)) &#123; return existingDeployment; &#125; &#125; deployment.setNew(true); // Save the data commandContext.getDeploymentEntityManager().insert(deployment); if (commandContext.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123; commandContext.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, deployment)); &#125; // Deployment settings Map&lt;String, Object&gt; deploymentSettings = new HashMap&lt;String, Object&gt;(); deploymentSettings.put(DeploymentSettings.IS_BPMN20_XSD_VALIDATION_ENABLED, deploymentBuilder.isBpmn20XsdValidationEnabled()); deploymentSettings.put(DeploymentSettings.IS_PROCESS_VALIDATION_ENABLED, deploymentBuilder.isProcessValidationEnabled()); // Actually deploy commandContext.getProcessEngineConfiguration().getDeploymentManager().deploy(deployment, deploymentSettings); if (deploymentBuilder.getProcessDefinitionsActivationDate() != null) &#123; scheduleProcessDefinitionActivation(commandContext, deployment); &#125; if (commandContext.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123; commandContext.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_INITIALIZED, deployment)); &#125; return deployment;&#125; 设置部署时间 2. 资源部署涉及到的表 ACT_RE_DEPLOYMENT: 存放流程定义的显示名称和部署时间, 每部署一次增加一条记录; ACT_RE_PROCDEF: 流程定义表, 存放流程定义的属性信息, 部署每个新的流程定义都会在这张表中增加一条记录, 当流程定义的 key 相同的时候, 使用的是版本升级 ACT_GE_BYTEARRAY: 资源文件表, 存储流程定义相关的二进制文件, 包括 XML 和图片.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(4)--CommandExecutor(命令执行器)]]></title>
    <url>%2Fblog%2F2019%2F02%2F21%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-CommandExecutor-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. commandExecutor 对象的构造1.1. ProcessEngineConfigurationImpl#ProcessEngineConfigurationImpl()1234567public void initCommandExecutors() &#123; initDefaultCommandConfig(); initSchemaCommandConfig(); initCommandInvoker(); initCommandInterceptors(); initCommandExecutor();&#125; 该方法由 ProcessEngineConfigurationImpl#init() 调用, init 在创建 ProcessEngineConfigurationImpl 对象的时候已经分析过 第 5 行, 初始化命令拦截器 第 6 行, 初始化命令执行器 1.1.1. initCommandInterceptors() 方法Activiti 提供了命令拦截器的功能, 通过 API 对 Activiti 流程各个实例的操作本质上都是对 DB 的操作. 因此 Activiti 将每一个 CRUD 操作都封装为一个 Command, 然后交由命令执行器 CommandExecutor 去执行. 为了能让使用者可以对命令进行拦截, Activiti 还是用了 责任链模式, 使用者可以在其中添加相应的拦截器. 职责链让多个对象都有机会处理请求, 从而避免了请求发送者和接受者之间的耦合, 这些请求接受者将组成一条链, 并沿着这条链传递下去, 直到有一个对象处理了这个请求为止. 12345678910111213public void initCommandInterceptors() &#123; if (commandInterceptors == null) &#123; commandInterceptors = new ArrayList&lt;CommandInterceptor&gt;(); if (customPreCommandInterceptors != null) &#123; commandInterceptors.addAll(customPreCommandInterceptors); &#125; commandInterceptors.addAll(getDefaultCommandInterceptors()); if (customPostCommandInterceptors != null) &#123; commandInterceptors.addAll(customPostCommandInterceptors); &#125; commandInterceptors.add(commandInvoker); &#125;&#125; 该方法完成对所有拦截器的初始化 自定义前置拦截器: 需要开发者实现 CommandInterceptor 接口, 并配置到 Activiti 配置文件(activiti.cfg.xml)中 默认的拦截器: LogInterceptor: 日志拦截器, 用于打印执行的日志 TransactionInterceptor: 事务拦截器 CommandContextInterceptor: 命令上下文拦截器 自定义后置拦截器: 需要开发者实现 CommandInterceptor 接口, 并配置到 Activiti 配置文件中. 1.1.2. getDefaultCommandInterceptors()12345678910111213141516171819public Collection&lt;? extends CommandInterceptor&gt; getDefaultCommandInterceptors() &#123; List&lt;CommandInterceptor&gt; interceptors = new ArrayList&lt;CommandInterceptor&gt;(); interceptors.add(new LogInterceptor()); CommandInterceptor transactionInterceptor = createTransactionInterceptor(); if (transactionInterceptor != null) &#123; interceptors.add(transactionInterceptor); &#125; if (commandContextFactory != null) &#123; interceptors.add(new CommandContextInterceptor(commandContextFactory, this)); &#125; if (transactionContextFactory != null) &#123; interceptors.add(new TransactionContextInterceptor(transactionContextFactory)); &#125; return interceptors;&#125; 1.2. ProcessEngineConfigurationImpl#initCommandExecutor()123456public void initCommandExecutor() &#123; if (commandExecutor == null) &#123; CommandInterceptor first = initInterceptorChain(commandInterceptors); commandExecutor = new CommandExecutorImpl(getDefaultCommandConfig(), first); &#125;&#125; 将命令拦截器列表初始化为职责链 色织第一个拦截器 1.2.1 ProcessEngineConfigurationImpl#initInterceptorChain(List chain)123456789public CommandInterceptor initInterceptorChain(List&lt;CommandInterceptor&gt; chain) &#123; if (chain == null || chain.isEmpty()) &#123; throw new ActivitiException("invalid command interceptor chain configuration: " + chain); &#125; for (int i = 0; i &lt; chain.size() - 1; i++) &#123; chain.get(i).setNext(chain.get(i + 1)); &#125; return chain.get(0);&#125; 初始化命令拦截器链, 并返回其中的第一个拦截器 2. ProcessEngineConfigurationImpl#initService(Object service)在各个服务对象(如 RuntimeService, RepositoryService等)中, 都可以直接使用 CommandExecutor 来执行命令commandExecutor 对象由 RepositoryServiceImpl 的基类 ServiceImpl 声明 在 ProcessEngineConfigurationImpl 类的 initService(Object service) 方法中完成各个服务类的属性注入 12345public void initService(Object service) &#123; if (service instanceof ServiceImpl) &#123; ((ServiceImpl) service).setCommandExecutor(commandExecutor); &#125;&#125;]]></content>
      <categories>
        <category>activiti</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(3)--Spring配置风格源码分析1]]></title>
    <url>%2Fblog%2F2019%2F02%2F20%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-Spring%E9%85%8D%E7%BD%AE%E9%A3%8E%E6%A0%BC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%2F</url>
    <content type="text"><![CDATA[在分析源码之前, 先贴出一个典型的 Activiti 与 Spring 整合的配置文件: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 ProcessEngineConfiguration --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; &lt;!-- Spring 需要单独配置 DataSource --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="transactionManager" ref="transactionManager"/&gt; &lt;property name="databaseSchemaUpdate" value="true"/&gt; &lt;/bean&gt; &lt;!-- 数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="org.h2.Driver"/&gt; &lt;property name="url" value="jdbc:h2:mem:activiti"/&gt; &lt;property name="username" value="sa"/&gt; &lt;property name="password" value=""/&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 流程引擎对象 --&gt; &lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration"/&gt; &lt;/bean&gt; &lt;!-- 将服务暴露给 Spring --&gt; &lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService"/&gt; &lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService"/&gt; &lt;bean id="formService" factory-bean="processEngine" factory-method="getFormService"/&gt; &lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService"/&gt; &lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService"/&gt; &lt;!-- 配置 activitiRule 用于测试 --&gt; &lt;bean id="activitiRule" class="org.activiti.engine.test.ActivitiRule"&gt; &lt;property name="processEngine" ref="processEngine"/&gt; &lt;/bean&gt;&lt;/beans&gt; 1. ProcessEngines 类1.1. init() 方法12345678910try &#123; resources = classLoader.getResources("activiti-context.xml");&#125; catch (IOException e) &#123; throw new ActivitiIllegalArgumentException("problem retrieving activiti-context.xml resources on the classpath: " + System.getProperty("java.class.path"), e);&#125;while (resources.hasMoreElements()) &#123; URL resource = resources.nextElement(); log.info("Initializing process engine using Spring configuration '&#123;&#125;'", resource.toString()); initProcessEngineFromSpringResource(resource);&#125; 在前两篇文章中, 我们主要对常规模式(即不与 Spring 整合的初始化模式)做了简单介绍, 这篇文章我们对于 Spring 整合方式下的 ProcessEngine 初始化做一个简单分析. 读取 classpath 下的 activiti-context.xml 文件 将资源列表依次交由 initProcessEngineFromSpringResource(resource) 方法完成初始化 1.2. initProcessEngineFromSpringResource(URL resource) 方法123456789101112131415protected static void initProcessEngineFromSpringResource(URL resource) &#123; try &#123; Class&lt;?&gt; springConfigurationHelperClass = ReflectUtil.loadClass("org.activiti.spring.SpringConfigurationHelper"); Method method = springConfigurationHelperClass.getDeclaredMethod("buildProcessEngine", new Class&lt;?&gt;[] &#123; URL.class &#125;); ProcessEngine processEngine = (ProcessEngine) method.invoke(null, new Object[] &#123; resource &#125;); String processEngineName = processEngine.getName(); ProcessEngineInfo processEngineInfo = new ProcessEngineInfoImpl(processEngineName, resource.toString(), null); processEngineInfosByName.put(processEngineName, processEngineInfo); processEngineInfosByResourceUrl.put(resource.toString(), processEngineInfo); &#125; catch (Exception e) &#123; throw new ActivitiException("couldn't initialize process engine from spring configuration resource " + resource.toString() + ": " + e.getMessage(), e); &#125;&#125; 通过反射的方式加载目标类 org.activiti.spring.SpringConfigurationHelper 的 class 对象 通过反射的方式获取该类名为 buildProcessEngine , 参数列表为 URL 的方法对象 反射调用 org.activiti.spring.SpringConfigurationHelper#buildProcessEngine(URL resource) 方法 2. SpringConfigurationHelper 类2.1. buildProcessEngine(URL resource) 方法1234567891011121314public static ProcessEngine buildProcessEngine(URL resource) &#123; log.debug("==== BUILDING SPRING APPLICATION CONTEXT AND PROCESS ENGINE ========================================="); ApplicationContext applicationContext = new GenericXmlApplicationContext(new UrlResource(resource)); Map&lt;String, ProcessEngine&gt; beansOfType = applicationContext.getBeansOfType(ProcessEngine.class); if ((beansOfType == null) || (beansOfType.isEmpty())) &#123; throw new ActivitiException("no " + ProcessEngine.class.getName() + " defined in the application context " + resource.toString()); &#125; ProcessEngine processEngine = beansOfType.values().iterator().next(); log.debug("==== SPRING PROCESS ENGINE CREATED =================================================================="); return processEngine; &#125; 使用传入的 activiti-context.xml 文件创建 ApplicationContext 对象 通过 ApplicationContext 获取类型为 ProcessEngine 的所有对象, 返回值为 Map&lt;beanId, ProcessEngine 对象&gt; 通过遍历获取其中第一个 value 并返回 在执行第 1 步的时候, 就会触发 Spring Application Context 管理的对应对象的初始化. 对应开始时贴出来的配置文件范例, 在初始化 &lt;processEngine, ProcessEngineFactoryBean&gt; 前, 需要先初始化 &lt;processEngineConfiguration, SpringProcessEngineConfiguration&gt; 对象 2.2 SpringProcessEngineConfiguration 对象的默认构造方法123456public SpringProcessEngineConfiguration() &#123; this.transactionsExternallyManaged = true; deploymentStrategies.add(new DefaultAutoDeploymentStrategy()); deploymentStrategies.add(new SingleResourceAutoDeploymentStrategy()); deploymentStrategies.add(new ResourceParentFolderAutoDeploymentStrategy());&#125; 2.3. ProcessEngine 对象的 getObject() 方法1234567891011public ProcessEngine getObject() throws Exception &#123; configureExpressionManager(); configureExternallyManagedTransactions(); if (processEngineConfiguration.getBeans() == null) &#123; processEngineConfiguration.setBeans(new SpringBeanFactoryProxyMap(applicationContext)); &#125; this.processEngine = processEngineConfiguration.buildProcessEngine(); return this.processEngine;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(2)--流程引擎类]]></title>
    <url>%2Fblog%2F2019%2F02%2F18%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在上一篇文章中, 我们跟踪了流程引擎配置类对象的创建过程, 今天紧接着来看 Activiti 在获取到流程引擎配置类之后, 如何完成流程引擎的初始化. 1. ProcessEngineConfiguration 类1.1. buildProcessEngine(URL resource) 方法123456789101112private static ProcessEngine buildProcessEngine(URL resource) &#123; InputStream inputStream = null; try &#123; inputStream = resource.openStream(); ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream); return processEngineConfiguration.buildProcessEngine(); &#125; catch (IOException e) &#123; throw new ActivitiIllegalArgumentException("couldn't open resource stream: " + e.getMessage(), e); &#125; finally &#123; IoUtil.closeSilently(inputStream); &#125;&#125; 在该方法中, 上一篇文章我们讲了第 5 行代码的源码调用关系, 最终创建了 ProcessEngineConfiguration 对象, 这篇文章中我们来讲第 6 行是如何创建 ProcessEngine 对象的. 1.2. buildProcessEngine() 方法该方法是一个抽象方法, 实现类分别有: MultiSchemaMultiTenantProcessEngineConfiguration ProcessEngineConfigurationImpl SpringProcessEngineConfiguration 在本例中, 最终会调用 ProcessEngineConfigurationImpl 的 buildProcessEngine() 方法, 因为我们在 activiti.cfg.xml 中的配置如下: 12345&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;!-- 配置数据库连接 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- ... --&gt;&lt;/bean&gt; 使用的是 StandaloneProcessEngineConfiguration, 而打开该类发现该类没有 buildProcessEngine() 方法的实现, 因此实现方法在其父类 ProcessEngineConfigurationImpl 中. 2. ProcessEngineConfigurationImpl 类2.1. buildProcessEngine() 方法1234567891011public ProcessEngine buildProcessEngine() &#123; init(); ProcessEngineImpl processEngine = new ProcessEngineImpl(this); // trigger build of Activiti 5 Engine if (isActiviti5CompatibilityEnabled &amp;&amp; activiti5CompatibilityHandler != null) &#123; Context.setProcessEngineConfiguration(processEngine.getProcessEngineConfiguration()); activiti5CompatibilityHandler.getRawProcessEngine(); &#125; postProcessEngineInitialisation(); return processEngine;&#125; 2.2. init()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void init() &#123; initConfigurators(); configuratorsBeforeInit(); initProcessDiagramGenerator(); initHistoryLevel(); initExpressionManager(); if (usingRelationalDatabase) &#123; initDataSource(); &#125; initAgendaFactory(); initHelpers(); initVariableTypes(); initBeans(); initFormEngines(); initFormTypes(); initScriptingEngines(); initClock(); initBusinessCalendarManager(); initCommandContextFactory(); initTransactionContextFactory(); initCommandExecutors(); initServices(); initIdGenerator(); initBehaviorFactory(); initListenerFactory(); initBpmnParser(); initProcessDefinitionCache(); initProcessDefinitionInfoCache(); initKnowledgeBaseCache(); initJobHandlers(); initJobManager(); initAsyncExecutor(); initTransactionFactory(); if (usingRelationalDatabase) &#123; initSqlSessionFactory(); &#125; initSessionFactories(); initDataManagers(); initEntityManagers(); initHistoryManager(); initJpa(); initDeployers(); initDelegateInterceptor(); initEventHandlers(); initFailedJobCommandFactory(); initEventDispatcher(); initProcessValidator(); initDatabaseEventLogging(); initActiviti5CompatibilityHandler(); configuratorsAfterInit(); &#125; 可以看到 init() 是一个非常大的方法, 其内容主要是各种初始化操作的执行, 其中有些比较重要的需要单独讲解. 如果使用关系型数据库, 其实 usingRelationalDatabase 变量默认为 true, 代表目前只支持关系型数据库, 就会使用 initRelationalDatabase() 方法完成数据库相关的初始化操作. 2.3. initRelationalDatabase()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void initDataSource() &#123; if (dataSource == null) &#123; if (dataSourceJndiName != null) &#123; try &#123; dataSource = (DataSource) new InitialContext().lookup(dataSourceJndiName); &#125; catch (Exception e) &#123; throw new ActivitiException("couldn't lookup datasource from " + dataSourceJndiName + ": " + e.getMessage(), e); &#125; &#125; else if (jdbcUrl != null) &#123; if ((jdbcDriver == null) || (jdbcUsername == null)) &#123; throw new ActivitiException("DataSource or JDBC properties have to be specified in a process engine configuration"); &#125; log.debug("initializing datasource to db: &#123;&#125;", jdbcUrl); PooledDataSource pooledDataSource = new PooledDataSource(ReflectUtil.getClassLoader(), jdbcDriver, jdbcUrl, jdbcUsername, jdbcPassword); if (jdbcMaxActiveConnections &gt; 0) &#123; pooledDataSource.setPoolMaximumActiveConnections(jdbcMaxActiveConnections); &#125; if (jdbcMaxIdleConnections &gt; 0) &#123; pooledDataSource.setPoolMaximumIdleConnections(jdbcMaxIdleConnections); &#125; if (jdbcMaxCheckoutTime &gt; 0) &#123; pooledDataSource.setPoolMaximumCheckoutTime(jdbcMaxCheckoutTime); &#125; if (jdbcMaxWaitTime &gt; 0) &#123; pooledDataSource.setPoolTimeToWait(jdbcMaxWaitTime); &#125; if (jdbcPingEnabled == true) &#123; pooledDataSource.setPoolPingEnabled(true); if (jdbcPingQuery != null) &#123; pooledDataSource.setPoolPingQuery(jdbcPingQuery); &#125; pooledDataSource.setPoolPingConnectionsNotUsedFor(jdbcPingConnectionNotUsedFor); &#125; if (jdbcDefaultTransactionIsolationLevel &gt; 0) &#123; pooledDataSource.setDefaultTransactionIsolationLevel(jdbcDefaultTransactionIsolationLevel); &#125; dataSource = pooledDataSource; &#125; if (dataSource instanceof PooledDataSource) &#123; // ACT-233: connection pool of Ibatis is not properly // initialized if this is not called! ((PooledDataSource) dataSource).forceCloseAll(); &#125; &#125; if (databaseType == null) &#123; initDatabaseType(); &#125;&#125; 如果 dataSource 对象为空, 就初始化一个 PooledDataSource 对象, 根据默认的 jdbcUrl, jdbcDriver, jdbcUsername 等变量创建一个数据库连接, 而上述的默认值则对应 Activiti 内置的内存数据库 H2, 说明如果不设置 dataSource, Activiti 就会使用内置的 H2 数据库完成 dataSource 的初始化. databaseType 用于标识数据库类型, 如果该变量为空, 需要调用 initDatabaseType() 来完成数据库类型的赋值. 2.4. initDatabaseType() 方法12345678910111213141516171819202122232425262728293031public void initDatabaseType() &#123; Connection connection = null; try &#123; connection = dataSource.getConnection(); DatabaseMetaData databaseMetaData = connection.getMetaData(); String databaseProductName = databaseMetaData.getDatabaseProductName(); log.debug("database product name: '&#123;&#125;'", databaseProductName); databaseType = databaseTypeMappings.getProperty(databaseProductName); if (databaseType == null) &#123; throw new ActivitiException("couldn't deduct database type from database product name '" + databaseProductName + "'"); &#125; log.debug("using database type: &#123;&#125;", databaseType); // Special care for MSSQL, as it has a hard limit of 2000 params per statement (incl bulk statement). // Especially with executions, with 100 as default, this limit is passed. if (DATABASE_TYPE_MSSQL.equals(databaseType)) &#123; maxNrOfStatementsInBulkInsert = DEFAULT_MAX_NR_OF_STATEMENTS_BULK_INSERT_SQL_SERVER; &#125; &#125; catch (SQLException e) &#123; log.error("Exception while initializing Database connection", e); &#125; finally &#123; try &#123; if (connection != null) &#123; connection.close(); &#125; &#125; catch (SQLException e) &#123; log.error("Exception while closing the Database connection", e); &#125; &#125;&#125; 获取一个数据库连接 通过该连接获取元数据信息, 得到数据库产品的名称 通过该名称去获取内部实现保存的数据库名称 Properties 集合, 如果为空说明不支持该数据库 通过存在就将 databaseType 完成赋值 2.5. 回到 buildProcessEngine() 方法123456789101112131415@Overridepublic ProcessEngine buildProcessEngine() &#123; init(); ProcessEngineImpl processEngine = new ProcessEngineImpl(this); // trigger build of Activiti 5 Engine if (isActiviti5CompatibilityEnabled &amp;&amp; activiti5CompatibilityHandler != null) &#123; Context.setProcessEngineConfiguration(processEngine.getProcessEngineConfiguration()); activiti5CompatibilityHandler.getRawProcessEngine(); &#125; postProcessEngineInitialisation(); return processEngine; &#125; init() 方法结束后, 已经完成了相关资源的初始化 使用 ProcessEngineConfiguration 对象去创建 ProcessEngineImpl, xxxService 核心服务对象都是通过 ProcessEngineConfiguration 对象中的同类对象完成的初始化. 如果开启 Activiti5 兼容功能, 并且 activiti5CompatibilityHandler(Activiti5兼容处理器对象) 不为空, 执行兼容初始化逻辑, 正常情况下不走该逻辑. 执行 postProcessEngineInitialisation() 2.6. postProcessEngineInitialisation()12345protected void postProcessEngineInitialisation() &#123; if (performanceSettings.isValidateExecutionRelationshipCountConfigOnBoot()) &#123; commandExecutor.execute(new ValidateExecutionRelatedEntityCountCfgCmd()); &#125;&#125; 使用该方法来检查是否使用了流程实例相关数量记录(validateExecutionRelationshipCountConfigOnBoot 配置的默认值为 true, 默认开启) 使用命令执行器执行 ValidateExecutionRelatedEntityCountCfgCmd 3. ValidateExecutionRelatedEntityCountCfgCmd 类实现了 Command 接口, 命令执行器执行的时候会自动调用其 execute(CommandContext commandContext) 方法. 3.1. execute(CommandContext commandContext) 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overridepublic Void execute(CommandContext commandContext) &#123; /* * If execution related entity counting is on in config | Current property in database : Result * * A) true | not there : write new property with value 'true' * B) true | true : all good * C) true | false : the feature was disabled before, but it is enabled now. Old executions will have a local flag with false. * It is now enabled. This is fine, will be handled in logic. Update the property. * * D) false | not there: write new property with value 'false' * E) false | true : the feature was disabled before and enabled now. To guarantee data consistency, we need to remove the flag from all executions. * Update the property. * F) false | false : all good * * In case A and D (not there), the property needs to be written to the db * Only in case E something needs to be done explicitely, the others are okay. */ PropertyEntityManager propertyEntityManager = commandContext.getPropertyEntityManager(); boolean configProperty = commandContext.getProcessEngineConfiguration().getPerformanceSettings().isEnableExecutionRelationshipCounts(); PropertyEntity propertyEntity = propertyEntityManager.findById(PROPERTY_EXECUTION_RELATED_ENTITY_COUNT); if (propertyEntity == null) &#123; // 'not there' case in the table above: easy, simply insert the value PropertyEntity newPropertyEntity = propertyEntityManager.create(); newPropertyEntity.setName(PROPERTY_EXECUTION_RELATED_ENTITY_COUNT); newPropertyEntity.setValue(Boolean.toString(configProperty)); propertyEntityManager.insert(newPropertyEntity); &#125; else &#123; boolean propertyValue = Boolean.valueOf(propertyEntity.getValue().toString().toLowerCase()); if (!configProperty &amp;&amp; propertyValue) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Configuration change: execution related entity counting feature was enabled before, but now disabled. " + "Updating all execution entities."); &#125; commandContext.getProcessEngineConfiguration().getExecutionDataManager().updateAllExecutionRelatedEntityCountFlags(configProperty); &#125; // Update property if (configProperty != propertyValue) &#123; propertyEntity.setValue(Boolean.toString(configProperty)); propertyEntityManager.update(propertyEntity); &#125; &#125; return null;&#125; 去数据库中的 ACT_GE_PROPERTY 表查询 id 为 cfg.execution-related-entities-count 的记录. 如果没有查到, 则插入一条 cfg.execution-related-entities-count, false 的记录 如果查到, 将该记录中的值转换为小写字符串, 转换为 boolean 值 如果配置的值不等于 DB 中存储的值, 那么将 DB 的值更新为配置的值 最终初始化代码执行完成后, 会在 DB 中存在这样一条记录 执行完毕后, 此时 ProcessEngine 对象已经初始化完成. 调用关系如下:]]></content>
  </entry>
  <entry>
    <title><![CDATA[关系型数据库的瓶颈与优化]]></title>
    <url>%2Fblog%2F2019%2F01%2F19%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%93%B6%E9%A2%88%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 数据库的分类数据库大致可以分为两部分: 传统的关系型数据库, 如: MySQL, Oracle, SQLServer 以及 PostgreSQL; MySQL 是国内使用最广泛的数据库, Oracle 在传统行业应用最为广泛, PostgreSQL 性能和功能都比较完善, 但目前文档和社区还有待成长. 非关系型数据库, 如 HBase(列式数据库), MongoDB(文档型数据库), Redis(高性能 KV 存储), Lucene(搜索引擎) 等等. 2. 关系型数据库的瓶颈与优化2.1 为什么数据库的架构需要调整 互联网的数据增长往往是指数型的; 读写分离, 分布式: 单机性能上存在瓶颈; NoSQL, 搜索引擎: 特殊场景的需求无法满足; 分析系统: 无法满足大数据的分析需求; 部署要求: 同城容灾/异地容灾. 2.2 数据库会遇到什么问题2.2.1 性能 查询性能 写入更新 并发, 数据量等 2.2.2 功能 新功能: LBS/JSON/特殊业务场景 数据安全性: 强一致性/非强一致性 大数据分析 搜索等 3. 不同业务场景的存储选型3.1 一个简单的问题MySQL 已经有 cache 了, 为何还需要加一层 Redis3.2 数据库查询开销 其中比较耗时的步骤有: 建立 TCP 连接 生成执行计划 开表 从磁盘扫描数据 关闭连接 3.2.1 SQL 解析假设有如下三条语句, 均是根据主键的查询. 12345678910# 1 SELECT id, name, price FROM products WHERE id IN (1, 2, 3, 4, ... 30000); # (1-2s)# 2. 将第一条查询转换成 30000 条语句SELECT id, name, price FROM products WHERE id = 1;...SELECT id, name, price FROM products WHERE id = 30000; # (2-3s)# 3. 将第一条转换成 OR 语句SELECT id, name, price FROM products WHERE id = 1 OR id = 2 OR ... OR id = 30000; # (8-10s) 造成第三条语句执行时间如此长的主要原因就是大量的 OR 语句会导致 SQL 解析非常耗时. 3.2.2 以 MySQL 的 InnoDB 存储引擎主键查询为例1SELECT * FROM t WHERE id = ?; 常规配置的服务器基本可以达到 400000 QPS. 3.2.3 如果查询条件不是主键1SELECT * FROM t WHERE name = ?; 对于非主键的查询, MySQL 会根据二级索引查询到主索引对应节点的位置. 按照图中的情况, 会首先通过三次 IO 找到对应主键, 在二级索引的叶子节点会同时保存索引字段的值以及主键的值, 再回到主索引通过主键查询到整条记录. 在 MySQL 中, 主键查询时最为高效的一类查询. DBA 往往希望所有的 SQL 语句都是 KV 查询, 但是往往是不现实的. 主键查询有限, 有些主键没有业务含义; 设计表结构时, 并没有考虑过主键问题. SQL 语句允许开发人员用各种方式从表中获取数据, 但 DBA 却不会希望我们这么做. 3.2.3 数据库的大字段1content varchar(2046) NOT NULL COMMENT '原始消息'; 以 InnoDB 存储引擎为例: TinyText/Text/Mediumtext varchar(256)/varchar(500)/varchar(20000) tinyBlob/blob/mediumBlob text 类型本质上和 varchar 类型没有区别. MySQL 中, 数据是以页的方式来组织的, 每个数据页默认大小 16 KB, 其中包括页头, 页尾, 中间是一行一行的记录. 图中的每条记录包括 ID, NAME, AGE 和 DETAIL. 假设 DETAIL 是一个大字段, 达到超过了单页的大小, 此时 DB 会新开一个数据页, 当前页通过指针指向该页. 如果一页依然不够, MySQL 就会不断新加数据页直到能够存下为止. 一旦存在这样的大字段, 会带来如下问题: 查询开销大; 查询影响大, 严重时会触发热页换出, 引起系统抖动. MySQL 将记录从磁盘读取出来的时候, 可能会有很多数据页, MySQL 自带缓存时非常宝贵的, 会导致真正使用频率高的数据页被替换成大字段的数据页. 此外, 对 MySQL 来说, 即便只查记录中的某几个字段, 数据库依然会把整条记录取出, 读进内存, 再进行指定字段的筛选 对于大字段场景可以尝试的优化方案: 是否适合存储关系型数据库; 是否所有数据都需要存数据库; 是否可以新建一张表存储大字段. 3.2.4 数据库缓存利用率以 InnoDB 存储引擎为例: MySQL 默认数据页为 16KB, 哪怕只读一行记录, 也需要从磁盘中取出 16KB 数据取出; MySQL 是以页为最小的缓存单位; 如果每行数据 1kb, 256kb 内存空间能缓存多少行有效数据, 最好的情况是每条数据整齐排列在一个数据页中, 那么可以缓存256条记录, 最坏的情况下每一页只存在一条数据, 那么就只能缓存16条; 在 256KB 的 Buffer Pool 中, 并不是所有空间都用来做数据页缓存, 有很大的一块在 Write Buffer(MySQL 为了优化写操作, 会将一段时间内的写操作先放在 Write Buffer, 再由后台线程定时异步刷新到磁盘上). 然而剩下的 128KB 中还存在一部分脏页. 缓存为什么如此重要: 互联网产品往往读多写少; 扩展缓存远比扩展 DB 简单; 数据库缓存利用率很低; 互联网应用对 DB 响应时间比较敏感, 缓存系统一般性能比较好 只要符合条件的数据都应该走缓存: 修改不频繁的数据; 非实时的数据, 一致性要求不严的数据; 查询频率较高, 带有明显热点请求的数据; 3.2.5 缓存带来的问题 用了缓存并不一定代表没有问题 缓存命中 缓存穿透 缓存失效 缓存一致 3.2.6 选择正确的索引 降低扫描数据量还是降低排序代价 大多数查询只能使用一个索引, 因此在需要对多个列进行操作的 SQL 语句中, 我们需要准确评估每个索引的开销. key idx_create_time(createTime) key idx_price(price)1SELECT * FROM tb_order WHERE createTime &gt; xxx AND createTime &lt; xxx ORDER BY price DESC; 3.2.7 索引的使用3.2.7.1 索引字段过长, 超过索引支持1234# name varchar(512)# ket idx_name(name(100))SELECT * FROM comment WHERE name &gt;= 'destiny' ORDER BY name ASC LIMIT 100; 上面的例子在实际场景中执行非常慢, 使用 EXPLAIN 打印查询计划: select_type: SIMPLE table: comment type: range possible_keys: id_name key: uk_sess key_len: 403 ref: NULL rows: 462642 Extra:Using where; Using filesort 1 row in set(0.00sec) 其中需要重点关注的是: Extra:Using where; Using filesort Using where: 表用到了索引 Using filesort: MySQL 自带的磁盘排序, 并没有用到索引的排序 问题是为什么使用了索引, 查询效率依然非常慢? 真正的原因是字段太长, 而索引的长度只能覆盖 256 字节, 导致 ORDER BY 无法在内存中完成排序 3.2.7.2查询某个用户 id 的分值总和 123456-- uid varchar(190) NOT NULL DEFAULT '' COMMENT '用户 id',-- score bigint(20) NOT NULL DEFAULT '0' COMMENT '变动分值, 正增, 负减',-- primary key ID-- KEY idx_uid(uid)SELECT SUM(score) FROM name WHERE uid = '5993156' 这条 SQL 的执行顺序: 根据二级索引 uid 找到所有主键 id 再根据主键逐行找到 score 对 score 进行聚合 这个 SQL 的问题在于需要进行大量的回表操作(从二级索引回到一级索引), 然后将全部符合过滤条件的记录放在内存中完成聚合操作. 改进的方法其实很简单, 可以尝试使用 (uid, score) 建立联合索引, 这样只需要查询二级索引就可以获得全部数据. 随机插入 100W 条数据, 现在对比下两条索引的开销. 3.3 数据库写开销 对持久化要求严格, 写操作代价大 日志文件需要 fsync, 硬件存在瓶颈 数据库写操作很难扩展 主从要求一致场景下还要算上网络开销 将 3 所在的数据页读到缓存中; 在内存中将 3 改成 5, 提交事务, 触发 Redo Log 的刷新; 向用户返回操作成功; 3.4 业务场景触发的高并发写入3.4.1 秒杀 高并发写入的极端情况 业务优化(缓存/令牌通/排队/Java 信号量/乐观锁) 热点资源隔离 引入数据库线程池 InnoDB 内核层优化: AliSQL 3.4.2 私信/站内信消息推送 高并发写入 伴随大量的读请求 系统消息/个人消息区分对待 消息内容单独对待 延迟写入, 通过队列/缓存达到限流目的 3.4.3 听歌量 业务原因导致写入量非常大 插入更新比不确定, 更新能力强 数据库需要具备自动扩展的能力 数据非强一致 3.5 死锁和超时 InnoDB 锁超时默认需要 5s 等待 死锁马上就能被发现, 然后被 DB 自动回滚 锁超时一般是索引不对, 或者 SQL 语句执行性能较差 死锁一般是业务实现有问题 锁超时一般影响较为可控 死锁情况比较严重, 会导致全站崩溃 3.6 数据库并发事务, 锁 业务流程中的锁: 减库存, 发优惠券 悲观锁实现:12345BEGIN;SELECT count FROM tb WHERE id = ? FOR UPDATE;-- do sthUPDATE tb SET count = count - ? WHERE id = ?;COMMIT; 乐观锁实现:12345BEGIN;SELECT count FROM tb WHERE id = ?;UPDATE tb SET count = count - ? WHERE id = ? AND count = :count;COMMIT;-- do sth 4. 数据库的模块化拆分4.1 单机服务器的局限 虽然硬件配置越来越高, 但是总有瓶颈(e.g. CPU/内存/网络/IO/容量) 为了后续业务的可扩展性 单机系统崩溃风险较高 优化性能 读写分离 冷热分离, 创建归档库 关键链路和非关键链路隔离 系统层面做好降级 4.2 常见拆分方案4.2.1 读写分离读写分离的原理就是将数据库读写操作分散到不同的节点上 读写分离的基本原理就是: 数据库服务器搭建主从集群; 数据库主机负责写操作, 从机只负责读操作; 数据库主机通过复制将数据同步到从机, 每台数据库服务器都存储了所有业务数据. 业务服务器将写操作发给数据库主机, 将读操作发给数据库从机. 使用读写分离之后, 可能会引入两个问题: 主从复制延迟 分配机制 4.2.1.1 复制延迟主从复制的延迟可能达到秒级, 如果有大量数据短时间需要完成同步, 延迟甚至可能达到分钟. 主从复制所带来的问题: 如果业务服务器将数据写入到主库后进行读取, 此时读操作访问从库, 而主库的数据没有完全复制过来, 从库是无法读取到最新数据的. 解决方案: 写操作后的读操作指定发给主库, 逻辑会和业务强绑定, 对业务侵入较大. 读从库失败后再读一次主库, 如果有大量没有命中从库的读请求, 会给主库带来较大压力. 关键业务读写操作全部走主库, 非关键业务采用读写分离. 4.2.1.2 分配机制将读写操作区分开来, 然后访问不同的数据库服务器, 一般有两种方式: 程序代码封装和中间件封装 1. 程序代码封装在代码中抽象一个数据访问层, 实现读写操作分离和数据库服务器连接的管理. 特点: 实现简单, 可以根据业务定制化; 无法做到多语言通用, 容易重复开发; 故障情况下, 如果主从发生切换, 需要将系统配置手动修改. 2. 中间件封装独立一套系统出来, 实现读写分离和数据库服务器连接的管理, 中间件对业务服务器提供 SQL 兼容的协议, 业务服务器无需自己进行读写分离, 对于业务服务器来说, 访问中间件和访问数据库没有区别 特点: 能够支持多种编程语言, 因为数据库中间件对业务提供的是标准的 SQL 接口. 实现较为复杂, 需要完整支持 SQL 语法和数据库服务器的协议. 性能要求很高, 容易成为瓶颈. 数据库主从切换对业务服务器无感知, 数据库中间件可以探测数据库服务器的主从状态(e.g. 向某个测试库写入一条数据, 成功的是主机, 失败的是从机) 4.2.2 分布式读写分离分散了读写操作的压力, 但没有分散存储的压力, 当数据量达到千万级以上的时候, 单台数据库服务器的存储能力就会成为瓶颈: 数据量太大, 读写的性能会大幅下降. 数据文件备份和恢复都会很困难. 垂直分表: 适合将某些表中不常用且占用大量空间的列拆分出去. 代价是操作表的数量增加. 水平拆分: 适合行数较大的表, 会引入更多的复杂度: 路由, join 操作, count 操作 等]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis详解(1)--数据结构]]></title>
    <url>%2Fblog%2F2019%2F01%2F16%2FRedis%E8%AF%A6%E8%A7%A3-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Activiti源码分析(1)--流程引擎配置类]]></title>
    <url>%2Fblog%2F2018%2F12%2F31%2FActiviti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%BC%95%E6%93%8E%E9%85%8D%E7%BD%AE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Activiti 配置风格获取引擎源码分析: 流程引擎管理类 ProcessEngines 1234567891011121314151617181920212223242526272829@Testpublic void testProcessEngine() &#123; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); log.info("processEngine: &#123;&#125;", processEngine); // org.activiti.engine.impl.ProcessEngineImpl@66ea1466 Class&lt;? extends ProcessEngine&gt; processEngineClass = processEngine.getClass(); log.info("class: &#123;&#125;", processEngineClass); // org.activiti.engine.impl.ProcessEngineImpl DynamicBpmnService dynamicBpmnService = processEngine.getDynamicBpmnService(); FormService formEngineFormService = processEngine.getFormEngineFormService(); FormRepositoryService formEngineRepositoryService = processEngine.getFormEngineRepositoryService(); org.activiti.engine.FormService formService = processEngine.getFormService(); HistoryService historyService = processEngine.getHistoryService(); IdentityService identityService = processEngine.getIdentityService(); ManagementService managementService = processEngine.getManagementService(); ProcessEngineConfiguration processEngineConfiguration = processEngine.getProcessEngineConfiguration(); // 流程引擎配置类 RepositoryService repositoryService = processEngine.getRepositoryService(); RuntimeService runtimeService = processEngine.getRuntimeService(); // 运行时 TaskService taskService = processEngine.getTaskService(); // 任务相关 log.info("dynamicBpmnService: &#123;&#125;", dynamicBpmnService); // org.activiti.engine.impl.DynamicBpmnServiceImpl@1601e47 log.info("formEngineFormService: &#123;&#125;", formEngineFormService); // null log.info("formEngineRepositoryService: &#123;&#125;", formEngineRepositoryService); // null log.info("formService: &#123;&#125;", formService); // org.activiti.engine.impl.FormServiceImpl@3bffddff log.info("historyService: &#123;&#125;", historyService); // org.activiti.engine.impl.HistoryServiceImpl@66971f6b log.info("identityService: &#123;&#125;", identityService); // org.activiti.engine.impl.IdentityServiceImpl@50687efb log.info("managementService: &#123;&#125;", managementService); // org.activiti.engine.impl.ManagementServiceImpl@517bd097 log.info("processEngineConfiguration: &#123;&#125;", processEngineConfiguration); // org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration@142eef62 log.info("repositoryService: &#123;&#125;", repositoryService); // org.activiti.engine.impl.RepositoryServiceImpl@4a9cc6cb log.info("runtimeService: &#123;&#125;", runtimeService); // org.activiti.engine.impl.RuntimeServiceImpl@5990e6c5 log.info("taskService: &#123;&#125;", taskService); // org.activiti.engine.impl.TaskServiceImpl@56e07a08&#125; 总的来说流程引擎配置类(ProcessEngineConfiguration) 的获取比较简单, 通过默认配置找到 classpath 下的 activiti.cfg.xml 配置文件, 再将该配置文件使用 Spring 的组件完成读取, 将 id 为 processEngineConfiguration 的 bean 完成初始化并返回. 1. ProcessEngines包含四个重要的集合 1234567891011// &lt;流程引擎名称, 流程引擎实例&gt;protected static Map&lt;String, ProcessEngine&gt; processEngines = new HashMap&lt;String, ProcessEngine&gt;();// &lt;流程引擎名称, 流程引擎信息类实例&gt;protected static Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByName = new HashMap&lt;String, ProcessEngineInfo&gt;();// &lt;构造流程引擎的资源名称(如文件路径名), 流程引擎信息类实例&gt;protected static Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl = new HashMap&lt;String, ProcessEngineInfo&gt;();// 存储流程引擎信息类实例对象protected static List&lt;ProcessEngineInfo&gt; processEngineInfos = new ArrayList&lt;ProcessEngineInfo&gt;(); 1.1. getDefaultProcessEngine方法体中只有一行代码 123public static ProcessEngine getDefaultProcessEngine() &#123; return getProcessEngine(NAME_DEFAULT);&#125; 类中 NAME_DEFAULT 的值是 default 1.2. getProcessEngine(String processEngineName)123456public static ProcessEngine getProcessEngine(String processEngineName) &#123; if (!isInitialized()) &#123; init(); &#125; return processEngines.get(processEngineName);&#125; 判断该类是否已经被初始化 如果没有初始化, 执行 init() 方法 返回 Map&lt;String, ProcessEngine&gt; processEngines 对应 key 的实例对象 1.2.1. isInitialized()返回类中一个静态常量, 用于标识 1protected static boolean isInitialized; 1.3. init()1234567891011121314151617181920212223242526272829303132333435363738394041public synchronized static void init() &#123; if (!isInitialized()) &#123; if (processEngines == null) &#123; // Create new map to store process-engines if current map is // null processEngines = new HashMap&lt;String, ProcessEngine&gt;(); &#125; ClassLoader classLoader = ReflectUtil.getClassLoader(); Enumeration&lt;URL&gt; resources = null; try &#123; resources = classLoader.getResources("activiti.cfg.xml"); &#125; catch (IOException e) &#123; throw new ActivitiIllegalArgumentException("problem retrieving activiti.cfg.xml resources on the classpath: " + System.getProperty("java.class.path"), e); &#125; // Remove duplicated configuration URL's using set. Some // classloaders may return identical URL's twice, causing duplicate // startups Set&lt;URL&gt; configUrls = new HashSet&lt;URL&gt;(); while (resources.hasMoreElements()) &#123; configUrls.add(resources.nextElement()); &#125; for (Iterator&lt;URL&gt; iterator = configUrls.iterator(); iterator.hasNext();) &#123; URL resource = iterator.next(); log.info("Initializing process engine using configuration '&#123;&#125;'", resource.toString()); initProcessEngineFromResource(resource); &#125; try &#123; resources = classLoader.getResources("activiti-context.xml"); &#125; catch (IOException e) &#123; throw new ActivitiIllegalArgumentException("problem retrieving activiti-context.xml resources on the classpath: " + System.getProperty("java.class.path"), e); &#125; while (resources.hasMoreElements()) &#123; URL resource = resources.nextElement(); log.info("Initializing process engine using Spring configuration '&#123;&#125;'", resource.toString()); initProcessEngineFromSpringResource(resource); &#125; setInitialized(true); &#125; else &#123; log.info("Process engines already initialized"); &#125;&#125; 再判断是否已经初始化 如果未初始化, 先初始化 Map&lt;String, ProcessEngine&gt; processEngines 获取当前类加载器 使用该类加载器指定加载 activiti.cfg.xml 路径下的资源, 并保存在 Set 中 遍历 Set 集合执行 initProcessEngineFromResource(URL resource) 获取 spring 风格配置文件 将类中 initialized 设置为 true 如果已被初始化, 直接返回 1.4. initProcessEngineFromResource(URL resourceUrl)123456789101112131415161718192021222324252627282930private static ProcessEngineInfo initProcessEngineFromResource(URL resourceUrl) &#123; ProcessEngineInfo processEngineInfo = processEngineInfosByResourceUrl.get(resourceUrl.toString()); // if there is an existing process engine info if (processEngineInfo != null) &#123; // remove that process engine from the member fields processEngineInfos.remove(processEngineInfo); if (processEngineInfo.getException() == null) &#123; String processEngineName = processEngineInfo.getName(); processEngines.remove(processEngineName); processEngineInfosByName.remove(processEngineName); &#125; processEngineInfosByResourceUrl.remove(processEngineInfo.getResourceUrl()); &#125; String resourceUrlString = resourceUrl.toString(); try &#123; log.info("initializing process engine for resource &#123;&#125;", resourceUrl); ProcessEngine processEngine = buildProcessEngine(resourceUrl); String processEngineName = processEngine.getName(); log.info("initialised process engine &#123;&#125;", processEngineName); processEngineInfo = new ProcessEngineInfoImpl(processEngineName, resourceUrlString, null); processEngines.put(processEngineName, processEngine); processEngineInfosByName.put(processEngineName, processEngineInfo); &#125; catch (Throwable e) &#123; log.error("Exception while initializing process engine: &#123;&#125;", e.getMessage(), e); processEngineInfo = new ProcessEngineInfoImpl(null, resourceUrlString, getExceptionString(e)); &#125; processEngineInfosByResourceUrl.put(resourceUrlString, processEngineInfo); processEngineInfos.add(processEngineInfo); return processEngineInfo;&#125; 根据路径尝试从 Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl 获取流程引擎类实例 如果不为空 将 List&lt;ProcessEngineInfo&gt; processEngineInfos 中对应的元素删除 流程引擎信息类实例没有 Exception, 将 Map&lt;String, ProcessEngine&gt; processEngines 和 Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByName 中 key 对应的元素都删除 Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl 中 key 对应的元素也删除. 通过 buildProcessEngine 方法获取 ProcessEngine 对象 将 Map&lt;String, ProcessEngine&gt; processEngines 和 Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByName 设置对应的 key 和 value 将 Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl 和 List&lt;ProcessEngineInfo&gt; processEngineInfos 也添加对应元素 1.5. buildProcessEngine(URL resource)123456789101112private static ProcessEngine buildProcessEngine(URL resource) &#123; InputStream inputStream = null; try &#123; inputStream = resource.openStream(); ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream); return processEngineConfiguration.buildProcessEngine(); &#125; catch (IOException e) &#123; throw new ActivitiIllegalArgumentException("couldn't open resource stream: " + e.getMessage(), e); &#125; finally &#123; IoUtil.closeSilently(inputStream); &#125;&#125; 通过传入的 URL 获取输入流; 通过 createProcessEngineConfigurationFromInputStream() 方法获取流程引擎配置对象 根据流程引擎配置类实例返回流程引擎实例 关闭流 2. ProcessEngineConfiguration 类2.1. createProcessEngineConfigurationFromInputStream(InputStream inputStream)123public static ProcessEngineConfiguration createProcessEngineConfigurationFromInputStream(InputStream inputStream) &#123; return createProcessEngineConfigurationFromInputStream(inputStream, "processEngineConfiguration");&#125; 方法只有一行, 用来添加默认的 beanName: processEngineConfiguration 这个 beanName 非常重要, Activiti 要求在配置文件中必须完成 id 为 processEngineConfiguration 的 bean 2.2. createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName)123public static ProcessEngineConfiguration createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName) &#123; return BeansConfigurationHelper.parseProcessEngineConfigurationFromInputStream(inputStream, beanName);&#125; 3. BeansConfigurationHelper 类3.1. parseProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName)1234public static ProcessEngineConfiguration parseProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName) &#123; Resource springResource = new InputStreamResource(inputStream); return parseProcessEngineConfiguration(springResource, beanName);&#125; 将输入流转化为 org.springframework.core.io.Resource, Spring 的资源抽象接口, 用于后续的 spring 风格配置文件解析; 将配置文件解析为 bean, 最终构造 ProcessEngineConfiguration 并返回 3.2. parseProcessEngineConfiguration(Resource springResource, String beanName)123456789public static ProcessEngineConfiguration parseProcessEngineConfiguration(Resource springResource, String beanName) &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); xmlBeanDefinitionReader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_XSD); xmlBeanDefinitionReader.loadBeanDefinitions(springResource); ProcessEngineConfigurationImpl processEngineConfiguration = (ProcessEngineConfigurationImpl) beanFactory.getBean(beanName); processEngineConfiguration.setBeans(new SpringBeanFactoryProxyMap(beanFactory)); return processEngineConfiguration;&#125; 创建 BeanFactory; 创建 XmlBeanDefinitionReader, 用于读取 XML 中的 bean 定义; 指定 XML 验证方式为 XSD; 读取配置文件资源; 根据 beanName 从 beanFactory 中获取指定对象, 并强转为 ProcessEngineConfigurationImpl; 4. 回到 ProcessEngines 类中此时已经完成了 ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream); 的执行, 得到了 ProcessEngineConfiguration 对象, 接下来调用 processEngineConfiguration.buildProcessEngine() 来获取 ProcessEngine 并返回.]]></content>
      <categories>
        <category>activiti</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti(7)--加签功能的实现]]></title>
    <url>%2Fblog%2F2018%2F12%2F23%2FActiviti-7-%E5%8A%A0%E7%AD%BE%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[加签的概念 思路: 直接需改模板, 在模板中添加节点以及连线, 并修改实例的走向; 直接修改路程定义对应的缓存数据, 不修改模板, 新增节点与当前需要加签的实例挂钩. 1. 方案一1.1. 实现方式 找到当前实例对象的模板数据 在模板数据的基础上添加新节点以及修改连线, 并更新数据库中的模板. 更新模板对应的流程定义缓存, 必须更新缓存否则加签的节点不会生效. 因为 Activiti 在查找流程定义的时候会先尝试从缓存中进行获取. 完成新增节点额任务后, 再把新增节点以及连线删除, 即还原模板. 1.2. 优缺点 模板是共享的, 因此修改模板就会将所有运行实例对象的模板修改. 实例间应该相互独立, 不能让针对某个实例的加签影响到其他实例. 修改模板容易导致当前实例影响其他实例, 因此该方案不可取; 2. 方案二 模板是共享的, 因此不能修改模板, 否则会影响其他实例. 也不需要修改原有流程的入线即出线, 不修改原有的走向. 由于流程运转的过程中, 需要实时的获取该实例对应的模板数据才能知道应该如何运转. 从流程定义缓存中获取模板数据 如果流程定义缓存丢失, 则需要重新执行模板的解析工作并补充到流程定义缓存中. 因此可以直接修改流程定义缓存数据. 2.1. 思路 在流程缓存中添加一个任务节点, 并未任务节点添加出线信息, 出线连接的是需要到达的目标节点. 添加的目标节点并没有入线, 并不会影响其他实例, 因此其他流程没有机会走到该节点. 加签完成后触发执行实例走到新增的任务节点, 这样当前实例就按照最新的路线进行运转; 如果当前节点在加签后不想直接运转到最新节点, 则可以复制一个当前节点, 继续让流程运转. 加签的最终目的是让实例按照最新的路线走, 与模板中规划的路线脱离关系. 2.2. 引入的问题 新增的任务节点及连线如何存储 流程定义缓存如何修改 加签的节点以及连线信息如何持久化 如果我们重新修改的流程定义缓存丢失, 引擎依然会解析数据库中保存的原有定义, 新增的节点并没有持久化到 DB 流程实例结束后, 当前加签的节点以及连线如何删除. 123456789101112131415161718192021222324252627282930313233343536public void testAddOneTask(String taskId, String targetActivityId) &#123; // 获取当前的任务 TaskEntity taskEntity = (TaskEntity) activitiRule.getTaskService().createTaskQuery().taskId(taskId).singleResult(); log.info("taskEntity: &#123;&#125;", taskEntity); String processDefinitionId = taskEntity.getProcessDefinitionId(); ManagementService managementService = activitiRule.getManagementService(); Process process = managementService.executeCommand(new GetProcessCmd(processDefinitionId)); log.info("process: &#123;&#125;", process); // 创建新节点 UserTask userTask = new UserTask(); userTask.setId("destinyD"); userTask.setName("加签节点 destinyD"); userTask.setAssignee("destiny-d"); userTask.setBehavior(createUserTaskBehavior(userTask)); // 新节点的目标连线 SequenceFlow sequenceFlow = new SequenceFlow(); sequenceFlow.setId("extra"); userTask.setOutgoingFlows(Arrays.asList(sequenceFlow)); sequenceFlow.setTargetFlowElement(process.getFlowElement(targetActivityId)); sequenceFlow.setTargetRef(targetActivityId); process.addFlowElement(userTask); process.addFlowElement(sequenceFlow); // 更新缓存 ProcessDefinitionCacheEntry processDefinitionCacheEntry = managementService.executeCommand(new GetProcessDefinitionCacheEntryCmd(processDefinitionId)); processDefinitionCacheEntry.setProcess(process); Process processCache = managementService.executeCommand(new GetProcessDefinitionCacheEntryCmd(processDefinitionId)).getProcess(); log.info("processCache: &#123;&#125;", processCache); // 跳转 managementService.executeCommand(new JumpCmd(taskId, userTask.getId()));&#125; 但该方法产生跳转后的新 task 仍然无法提交, 会报一下错误: 17:59:18.971 [main] [ERROR] Error while closing command context o.a.e.i.i.CommandContext.logException:122 org.activiti.engine.ActivitiException: Programmatic error: no current flow element found or invalid type: null. Halting. at org.activiti.engine.impl.agenda.TriggerExecutionOperation.run(TriggerExecutionOperation.java:49) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperation(CommandInvoker.java:73) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperations(CommandInvoker.java:57) at org.activiti.engine.impl.interceptor.CommandInvoker.execute(CommandInvoker.java:42) at org.activiti.engine.impl.interceptor.TransactionContextInterceptor.execute(TransactionContextInterceptor.java:48) at org.activiti.engine.impl.interceptor.CommandContextInterceptor.execute(CommandContextInterceptor.java:63) at org.activiti.engine.impl.interceptor.LogInterceptor.execute(LogInterceptor.java:29) at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:44) at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:39) at org.activiti.engine.impl.TaskServiceImpl.complete(TaskServiceImpl.java:182) at org.destiny.activiti.addsign1.ClientTest.complete(ClientTest.java:56) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.activiti.engine.test.ActivitiRule$1.evaluate(ActivitiRule.java:116) 出线错误的原因是加签方法执行完成后, 缓存中的数据已经被释放, complete 的时候无法继续, 需要在 complete 之前重新向缓存中添加之前的节点和连线 在修改流程定义缓存而不修改模板的实现中, 我们需要一个额外的持久化方式去实现加签部分的持久化 2.3. 持久化加签现场数据1234567891011CREATE TABLE `ACT_ADD_SIGN` ( `ID_` bigint(20) NOT NULL AUTO_INCREMENT, `PROCESS_DEFINITION_ID_` varchar(255) NOT NULL COMMENT '流程定义 ID', `ASSIGNEE_` varchar(32) NOT NULL COMMENT '操作人 ID', `ACT_ID_` varchar(64) NOT NULL COMMENT '活动 ID', `PROCESS_INSTANCE_` varchar(255) NOT NULL COMMENT '流程实例 ID', `PROPERTIES_TEXT_` varchar(2000) DEFAULT NULL COMMENT '参数', `STATE_` int(11) DEFAULT NULL COMMENT '状态位, 0-有效, 1-无效', `CREATE_TIME` bigint(20) DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`ID_`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 以及对应的 Mapper 文件: 1234567891011121314151617public interface AddSignMapper &#123; @Select("select * from ACT_ADD_SIGN where STATE_ = 0 AND PROCESS_INSTANCE_ID_ = #&#123;processInstanceId&#125;") @Results(&#123; @Result(property = "id", column = "ID_"), @Result(property = "processDefinitionId", column = "PROCESS_DEFINITION_ID_"), @Result(property = "assignee", column = "ASSIGNEE_"), @Result(property = "processInstanceId", column = "PROCESS_INSTANCE_ID_"), @Result(property = "propertiesText", column = "PROPERTIES_TEXT_"), @Result(property = "state", column = "STATE_"), @Result(property = "createTime", column = "CREATE_TIME_"), &#125;) List&lt;AddSign&gt; find(String processInstanceId); @Insert("insert into act_creation(PROCESS_DEFINITION_ID_, PROCESS_INSTANCE_ID_, PROPERTIES_TEXT_, CREATE_TIME_) values(#&#123;processDefinitionId&#125;, #&#123;processInstanceId&#125;, #&#123;propertiesText&#125;, #&#123;createTime&#125;)") int insert(AddSign addSign);&#125; 2.4. 模型定义2.4.1. AddSign12345678910111213@Datapublic class AddSign &#123; private long id; private String processDefinitionId; // 流程定义 id private String assignee; // 加签用户 private String activityId; // 节点 id private String processInstanceId; // 流程实例 id private String propertiesText; // 参数(复合字段) private int state; // 状态 0-可用, 1-不可用 private long createTime; // 创建时间&#125; 2.4.2. TaskModel12345678@Datapublic class TaskModel implements Serializable &#123; private String id; private String name; private String assignee; // 处理人 private int type = 1; // 任务类型, 1-任务节点&#125; 2.4.3. TmpActivityModel1234567@Datapublic class TmpActivityModel implements Serializable &#123; private String activityIds; // 加签的节点id, 多个的话逗号分隔 private String firstId; private String lastId; private List&lt;TaskModel&gt; activityList;&#125; 2.5. 加签功能实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@Slf4jpublic class AddSignService &#123; /** * @param procDefId 流程定义 ID * @param procInstId 流程实例 ID * @param processEngine 流程引擎 * @param taskModelList 加签节点列表 * @param firstNodeId 加签开始节点 ID * @param lastNodeId 加签结束节点 ID * @param persistence 是否持久化 * @param onset 是否需要立即跳转 * @param taskId taskID * @param targetNodeId 跳转的目标节点 */ public void addUserTask(String procDefId, String procInstId, ProcessEngine processEngine, List&lt;TaskModel&gt; taskModelList, String firstNodeId, String lastNodeId, boolean persistence, boolean onset, String taskId, String targetNodeId) &#123; ManagementService managementService = processEngine.getManagementService(); ProcessDefinitionCacheEntry processDefinitionCacheEntry = managementService.executeCommand(new GetProcessDefinitionCacheEntryCmd(procDefId)); // 通过缓存获取 Process process = processDefinitionCacheEntry.getProcess(); // 批量生成任务, 循环遍历 TaskModel List&lt;UserTask&gt; userTaskList = Lists.newArrayList(); taskModelList.forEach(taskModel -&gt; &#123; UserTask userTask = ActivityUtils.convertToUserTask(taskModel, processEngine); userTaskList.add(userTask); process.addFlowElement(userTask); &#125;); // 构造并添加连线 for (int i = 0; i &lt; userTaskList.size(); ++i) &#123; UserTask userTask = userTaskList.get(i); SequenceFlow sequenceFlow = null; if (i == userTaskList.size() - 1) &#123; // 如果是最后一个节点 sequenceFlow = ActivityUtils.buildSequenceFlow(userTask.getId() + "--&gt;" + lastNodeId, userTask.getId() + "--&gt;" + lastNodeId, userTask.getId(), lastNodeId); sequenceFlow.setTargetRef(lastNodeId); &#125; else &#123; // 如果不是最后一个 ActivityUtils.buildSequenceFlow(userTask.getId() + "--&gt;" + userTaskList.get(i + 1).getId(), userTask.getId() + "--&gt;" + userTaskList.get(i + 1).getId(), userTask.getId(), userTaskList.get(i + 1).getId()); sequenceFlow.setTargetFlowElement(userTaskList.get(i + 1)); &#125; userTask.setOutgoingFlows(Arrays.asList()); process.addFlowElement(sequenceFlow); &#125; log.info("process: &#123;&#125;", process); // 更新缓存 processDefinitionCacheEntry.setProcess(process); // 如果需要立即生效(直接跳转) if (onset) &#123; managementService.executeCommand(new JumpCmd(taskId, targetNodeId)); &#125; // 如果需要持久化 if (persistence) &#123; persistenceToDB(procDefId, procInstId, firstNodeId, lastNodeId, taskModelList, processEngine); &#125; &#125; /** * 将加签的任务节点添加到数据库 * @param procDefId * @param procInstId * @param firstNodeId * @param lastNodeId * @param taskModelList * @param processEngine */ private void persistenceToDB(String procDefId, String procInstId, String firstNodeId, String lastNodeId, List&lt;TaskModel&gt; taskModelList, ProcessEngine processEngine) &#123; ProcessEngineConfigurationImpl processEngineConfiguration = (ProcessEngineConfigurationImpl) processEngine.getProcessEngineConfiguration(); SqlSession sqlSession = processEngineConfiguration.getSqlSessionFactory().openSession(); AddSignMapper mapper = sqlSession.getMapper(AddSignMapper.class); TmpActivityModel tmpActivityModel = new TmpActivityModel(); tmpActivityModel.setFirstId(firstNodeId); tmpActivityModel.setLastId(lastNodeId); tmpActivityModel.setActivityList(taskModelList); StringBuilder stringBuilder = new StringBuilder(); for (TaskModel taskModel : taskModelList) &#123; stringBuilder.append(taskModel.getId() + ","); &#125; tmpActivityModel.setActivityIds(stringBuilder.toString()); AddSign addSign = new AddSign(); addSign.setProcessDefinitionId(procDefId); addSign.setProcessInstanceId(procInstId); addSign.setPropertiesText(JSON.toJSONString(tmpActivityModel)); addSign.setCreateTime(System.currentTimeMillis()); int insert = mapper.insert(addSign); log.info("insert 结果: &#123;&#125;", insert); sqlSession.commit(); sqlSession.close(); &#125;&#125; 2.6. 测试代码部署流程后, 通过测试代码 12345678910111213141516171819202122@Testpublic void addSignTest() &#123; String taskId = "17508"; TaskEntity taskEntity = (TaskEntity) activitiRule.getTaskService().createTaskQuery() .taskId(taskId) .singleResult(); log.info("taskEntity: &#123;&#125;", taskEntity); String firstNodeId = "destinyA"; String lastNodeId = "destinyB"; List&lt;TaskModel&gt; taskModelList = Lists.newArrayList(); TaskModel taskModel1 = ActivityUtils.buildTaskModel("destinyD", "destinyD", "destiny-d"); TaskModel taskModel2 = ActivityUtils.buildTaskModel("destinyD", "destinyD", "destiny-d"); taskModelList.add(taskModel1); taskModelList.add(taskModel2); AddSignService addSignService = new AddSignService(); addSignService.addUserTask(taskEntity.getProcessDefinitionId(), taskEntity.getProcessInstanceId(), activitiRule.getProcessEngine(), taskModelList, firstNodeId, lastNodeId, true, true, taskEntity.getId(), taskModelList.get(0).getId()); &#125; 执行结束后我们就已经将 destinyD -&gt; destinyE 两个节点加签到 destinyA 之后, destinyB 之前. select NAME_ from ACT_RU_TASK where PROC_INST_ID_ = &#39;17504&#39;; 的执行结果已经变成: destinyD 现在已经完成了加签的一部分代码, 但此时的任务是不能被正确提交的, 会报如下异常: org.activiti.engine.ActivitiException: Programmatic error: no current flow element found or invalid type: null. Halting. at org.activiti.engine.impl.agenda.TriggerExecutionOperation.run(TriggerExecutionOperation.java:49) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperation(CommandInvoker.java:73) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperations(CommandInvoker.java:57) at org.activiti.engine.impl.interceptor.CommandInvoker.execute(CommandInvoker.java:42) at org.activiti.engine.impl.interceptor.TransactionContextInterceptor.execute(TransactionContextInterceptor.java:48) at org.activiti.engine.impl.interceptor.CommandContextInterceptor.execute(CommandContextInterceptor.java:63) at org.activiti.engine.impl.interceptor.LogInterceptor.execute(LogInterceptor.java:29) at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:44) at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:39) at org.activiti.engine.impl.TaskServiceImpl.complete(TaskServiceImpl.java:182) at org.destiny.activiti.addsign1.ClientTest.complete(ClientTest.java:61) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.activiti.engine.test.ActivitiRule$1.evaluate(ActivitiRule.java:116) 2.7. 流程引擎启动时从 DB 加载流程定义信息当流程引擎启动的时候, 如果 ACT_ADD_SIGN 表有数据, 就需要将对应的加签现场数据保存并添加到缓存中.]]></content>
      <categories>
        <category>Activiti</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti(5)--任意节点跳转]]></title>
    <url>%2Fblog%2F2018%2F12%2F22%2FActiviti-5-%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[1. 任意节点跳转以及原理 常规节点跳转 跳转到目标节点 跳转到目标节点的入线 跳转到目标节点的上一个节点并触发连线的条件计算 多实例节点的跳转 普通节点跳转到多实例节点 多实例节点跳转到普通节点 比如总经理审批节点跳转到请假申请节点: 思路: 可以获取总经理审批节点对应的任务 ID, 实例 ID, 执行实例 ID 可以通过 planContiuneProcessInCompensation 方法让当前执行的实例按照我们预期的效果流转 我们可以将当前执行实例中的 currentFlowElement 字段设置为 请假申请 节点 XML 中的 id 值; 因为执行实例运转之后, 当前的任务节点并没有被删除, 所以需要手工删除; 历史表跳转之前的任务节点也不会被完成, 需要手工进行完成. 1.1. 实现方案 获取 ActivitiEngineAgenda commandContext.getExecutionEntityManager() 获取 ExecutionEntityManager commandContext.getTaskEntityManager() 获取 TaskEntityManager 设置执行实例的运行节点 触发执行实例运转 设置删除当前的任务节点 更新历史实例表以及历史任务表, 当前的任务节点为完成状态 123456789101112131415161718192021222324252627282930313233343536@AllArgsConstructorpublic class JumpCmd implements Command&lt;Void&gt; &#123; private String taskId; private String targetNodeId; @Override public Void execute(CommandContext commandContext) &#123; ActivitiEngineAgenda agenda = commandContext.getAgenda(); TaskEntityManager taskEntityManager = commandContext.getTaskEntityManager(); TaskEntity taskEntity = taskEntityManager.findById(taskId); // 执行实例 id String executionId = taskEntity.getExecutionId(); String processDefinitionId = taskEntity.getProcessDefinitionId(); ExecutionEntityManager executionEntityManager = commandContext.getExecutionEntityManager(); HistoryManager historyManager = commandContext.getHistoryManager(); // 执行实例对象 ExecutionEntity executionEntity = executionEntityManager.findById(executionId); Process process = ProcessDefinitionUtil.getProcess(processDefinitionId); FlowElement flowElement = process.getFlowElement(targetNodeId); if (flowElement == null) &#123; throw new RuntimeException("目标节点不存在"); &#125; // 将历史活动表更新 historyManager.recordActivityEnd(executionEntity, "jump"); // 设置当前流程 executionEntity.setCurrentFlowElement(flowElement); // 跳转, 触发执行实例运转 agenda.planContinueProcessInCompensation(executionEntity); // 从runtime 表中删除当前任务 taskEntityManager.delete(taskId); // 将历史任务表更新, 历史任务标记为完成 historyManager.recordTaskEnd(taskId, "jump"); return null; &#125;&#125; 1.2. 测试场景假设有如下流程定义: 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="userTask1"/&gt; &lt;userTask id="userTask1" name="userTask1" activiti:assignee="destiny1"/&gt; &lt;sequenceFlow id="flow2" sourceRef="userTask1" targetRef="userTask2"/&gt; &lt;userTask id="userTask2" name="userTask2" activiti:assignee="destiny2"/&gt; &lt;sequenceFlow id="flow3" sourceRef="userTask2" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 结构如下: start -&gt; userTask1 -&gt; userTask2 -&gt; end 使用如下的执行顺序: startProcessInstance complete 任务 userTask1 执行 ManagementService().executeCommand(new JumpCmd(&quot;7502&quot;, &quot;userTask1&quot;)) complete 任务 userTask1 执行 ManagementService().executeCommand(new JumpCmd(&quot;7502&quot;, &quot;userTask1&quot;)) 然后查询 ACT_HI_ACTINST 表, 能够看到如下执行轨迹: ID_ PROC_DEF_ID_ PROC_INST_ID_ EXECUTION_ID_ ACT_ID_ TASK_ID_ CALL_PROC_INST_ID_ ACT_NAME_ ACT_NAME_ ASSIGNEE_ START_TIME_ END_TIME_ DURATION_ DELETE_REASON_ TENANT_ID_ 6 my-process:1:3 4 5 start startEvent 2019-03-04 00:37:54.328 2019-03-04 00:37:54.330 2 “” 7 my-process:1:3 4 5 userTask1 8 userTask1 userTask destiny1 2019-03-04 00:37:54.331 2019-03-04 00:38:19.920 25589 “” 2501 my-process:1:3 4 5 userTask2 2502 userTask2 userTask destiny2 2019-03-04 00:38:19.933 2019-03-04 00:38:44.834 24901 jump “” 5001 my-process:1:3 4 5 userTask1 5002 userTask1 userTask destiny1 2019-03-04 00:38:44.848 2019-03-04 00:39:02.232 17384 “” 7501 my-process:1:3 4 5 userTask2 7502 userTask2 userTask destiny2 2019-03-04 00:39:02.245 2019-03-04 00:39:19.718 17473 jump “” 10001 my-process:1:3 4 5 userTask1 10002 userTask1 userTask destiny1 2019-03-04 00:39:19.743 “” 可以看到我们已经完成了简单条件下的跳转 1.3. 关于自由跳转时历史活动不更新问题的解决之前遇到一个错误的写法: 123456789101112131415161718192021222324252627282930313233343536@AllArgsConstructorpublic class JumpCmd implements Command&lt;Void&gt; &#123; private String taskId; private String targetNodeId; @Override public Void execute(CommandContext commandContext) &#123; ActivitiEngineAgenda agenda = commandContext.getAgenda(); TaskEntityManager taskEntityManager = commandContext.getTaskEntityManager(); TaskEntity taskEntity = taskEntityManager.findById(taskId); // 执行实例 id String executionId = taskEntity.getExecutionId(); String processDefinitionId = taskEntity.getProcessDefinitionId(); ExecutionEntityManager executionEntityManager = commandContext.getExecutionEntityManager(); HistoryManager historyManager = commandContext.getHistoryManager(); // 执行实例对象 ExecutionEntity executionEntity = executionEntityManager.findById(executionId); Process process = ProcessDefinitionUtil.getProcess(processDefinitionId); FlowElement flowElement = process.getFlowElement(targetNodeId); if (flowElement == null) &#123; throw new RuntimeException("目标节点不存在"); &#125; // 设置当前流程 executionEntity.setCurrentFlowElement(flowElement); // 跳转, 触发执行实例运转 agenda.planContinueProcessInCompensation(executionEntity); // 从runtime 表中删除当前任务 taskEntityManager.delete(taskId); // 将历史活动表更新 historyManager.recordActivityEnd(executionEntity, "jump"); // 将历史任务表更新, 历史任务标记为完成 historyManager.recordTaskEnd(taskId, "jump"); return null; &#125;&#125; 与上文中正确写法的不同之处在于数据库更新操作的顺序. 但仅仅更换顺序也会到导致历史表中数据无法正确结束. 问题的原因在于第 25 行的时候已经为执行实例执行了 setCurrentFlowElement() 操作, 设置了最新的流程元素, 所以如果在后面再执行对 ACT_HI_ACTINST 的更新, 就无法找到正确的 FlowElement. 所以需要将 historyManager.recordActivityEnd(executionEntity, &quot;jump&quot;); 放在第 25 行之前 2. 跳转到目标节点的入线假设有如下流程定义: 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;userTask id="userTask1" name="userTask1" activiti:assignee="destiny1"/&gt; &lt;userTask id="userTask2" name="userTask2" activiti:assignee="destiny2"/&gt; &lt;userTask id="userTask3" name="userTask3" activiti:assignee="destiny3"/&gt; &lt;endEvent id="end1"/&gt; &lt;endEvent id="end2"/&gt; &lt;sequenceFlow sourceRef="start" targetRef="userTask1"/&gt; &lt;sequenceFlow sourceRef="userTask1" targetRef="userTask2"&gt; &lt;conditionExpression&gt;$&#123;condition==1&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow sourceRef="userTask1" targetRef="userTask3"&gt; &lt;conditionExpression&gt;$&#123;condition==2&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow sourceRef="userTask2" targetRef="end1"/&gt; &lt;sequenceFlow sourceRef="userTask3" targetRef="end2"/&gt; &lt;/process&gt;&lt;/definitions&gt; 将原先的跳转命令类稍作修改: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@AllArgsConstructorpublic class SequenceFlowJumpCmd implements Command&lt;Void&gt; &#123; private String taskId; private String targetNodeId; @Override public Void execute(CommandContext commandContext) &#123; ActivitiEngineAgenda agenda = commandContext.getAgenda(); TaskEntityManager taskEntityManager = commandContext.getTaskEntityManager(); TaskEntity taskEntity = taskEntityManager.findById(taskId); // 执行实例 id String executionId = taskEntity.getExecutionId(); String processDefinitionId = taskEntity.getProcessDefinitionId(); ExecutionEntityManager executionEntityManager = commandContext.getExecutionEntityManager(); HistoryManager historyManager = commandContext.getHistoryManager(); // 执行实例对象 ExecutionEntity executionEntity = executionEntityManager.findById(executionId); Process process = ProcessDefinitionUtil.getProcess(processDefinitionId); FlowElement flowElement = process.getFlowElement(targetNodeId); if (flowElement == null) &#123; throw new RuntimeException("目标节点不存在"); &#125; SequenceFlow sequenceFlow = null; if (flowElement instanceof FlowNode) &#123; FlowNode flowNode = (FlowNode) flowElement; // 找到所有的入线, 并取其中唯一的一条 List&lt;SequenceFlow&gt; incomingFlows = flowNode.getIncomingFlows(); sequenceFlow = incomingFlows.get(0); &#125; if (sequenceFlow == null) &#123; throw new RuntimeException("目标连线不存在"); &#125; // 将历史活动表更新 historyManager.recordActivityEnd(executionEntity, "jump"); // 设置当前流程 executionEntity.setCurrentFlowElement(sequenceFlow); // 触发执行实例运转, 第二个参数为是否参与计算 agenda.planTakeOutgoingSequenceFlowsOperation(executionEntity, true); // 从runtime 表中删除当前任务 taskEntityManager.delete(taskId); // 将历史任务表更新, 历史任务标记为完成 historyManager.recordTaskEnd(taskId, "jump"); return null; &#125;&#125; 通过连线触发实例的时候, 连线上的条件不会参与计算 只有实例经过节点, 网关的时候, 连线上的条件才会经过计算 3. 跳转到目标节点入线连接的节点因为实例是从节点离开, 因此后面的连线是可以参与运算的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@AllArgsConstructorpublic class SequenceFlowSourceJumpCmd implements Command&lt;Void&gt; &#123; private String taskId; private String targetNodeId; private Map&lt;String, Object&gt; condition; @Override public Void execute(CommandContext commandContext) &#123; ActivitiEngineAgenda agenda = commandContext.getAgenda(); TaskEntityManager taskEntityManager = commandContext.getTaskEntityManager(); TaskEntity taskEntity = taskEntityManager.findById(taskId); // 执行实例 id String executionId = taskEntity.getExecutionId(); String processDefinitionId = taskEntity.getProcessDefinitionId(); ExecutionEntityManager executionEntityManager = commandContext.getExecutionEntityManager(); HistoryManager historyManager = commandContext.getHistoryManager(); // 执行实例对象 ExecutionEntity executionEntity = executionEntityManager.findById(executionId); Process process = ProcessDefinitionUtil.getProcess(processDefinitionId); FlowElement flowElement = process.getFlowElement(targetNodeId); if (flowElement == null) &#123; throw new RuntimeException("目标节点不存在"); &#125; SequenceFlow sequenceFlow = null; if (flowElement instanceof FlowNode) &#123; FlowNode flowNode = (FlowNode) flowElement; // 找到所有的入线, 并取其中唯一的一条 List&lt;SequenceFlow&gt; incomingFlows = flowNode.getIncomingFlows(); sequenceFlow = incomingFlows.get(0); &#125; if (sequenceFlow == null) &#123; throw new RuntimeException("目标连线不存在"); &#125; FlowElement sourceFlowElement = sequenceFlow.getSourceFlowElement(); executionEntity.setVariables(condition); // 将历史活动表更新 historyManager.recordActivityEnd(executionEntity, "jump"); // 设置当前流程 executionEntity.setCurrentFlowElement(sourceFlowElement); // 触发执行实例运转, 第二个参数为是否参与计算 agenda.planTakeOutgoingSequenceFlowsOperation(executionEntity, true); // 从runtime 表中删除当前任务 taskEntityManager.delete(taskId); // 将历史任务表更新, 历史任务标记为完成 historyManager.recordTaskEnd(taskId, "jump"); return null; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Activiti(6)--加签功能的实现]]></title>
    <url>%2Fblog%2F2018%2F12%2F22%2FActiviti-6-%E5%8A%A0%E7%AD%BE%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 概述假设有如下流程: 我们在流程进行的时候, 需要在申请和经理审批之间临时新增一个节点, 达到如下的效果: 该行为我们称之为加签. 加签的两种思路 直接修改模板, 在模板中添加节点以及连线, 并修改实例的走向; 直接修改流程定义对应的缓存数据, 不修改模板, 新增的节点与当前需要加签的实例挂钩. 2. 实现方式2.1. 修改模板步骤: 找到当前实例对象对应的模板数据; 在模板数据的基础上添加新节点, 修改连线, 并更新数据库中的模板; 更新模板对应的流程定义缓存, 否则加签节点不会生效; 完成新增的节点任务后, 再把新增的节点以及连线删除, 即还原流程模板. 模板是共享的, 所以把模板修改了, 所有运行实例对应的模板也会被修改; 修改模板容易导致当前实例影响到其他实例, 这种方法并不可取; 2.2 修改流程定义缓存因为模板是共享的, 不修改模板就不会影响其他实例; 也不需要修改原有流程的流向, 要让流程按照新的流向运行. 因为流程在运转过程中, 需要实时获取该实例对应的模板数据才能知道应该如何流转 首先从流程定义缓存中获取模板数据; 如果流程缓存定义丢失, 则需要重新执行模板的解析工作并将其防止到流程缓存中; 因此修改流程定义缓存就可以实现功能. 但仍有一个问题需要解决: 如果流程定义缓存丢失, 引擎默认解析的是数据库中存在的模板数据, 而新增的临时节点不会存在与 XML 中. 2.2.1 步骤 在流程缓存中添加一个任务节点并为任务节点添加出线信息, 出线信息是需要到达的目标节点; 添加的目标节点并没有入线, 也就是说不会影响到其他的实例, 正常的流程实例启动的时候不会走到这个节点; 加签完成后可以触发执行实例走到新增的任务节点, 这样当前实例就按照最新的路线进行运转; 如果当前的节点加签后不想让实例运转到最新的节点, 可以复制一个当前节点, 继续让实例运转; 加签的最终目的是让实例按照最新的路线走, 与模板中规划的路线脱离关系. 需要解决的问题: 新增的节点以及连线如何存储; 流程定义缓存如何修改; 加签的节点以及连线信息如何持久化; 缓存丢失, 新的路线图丢失; 流程实例结束, 当前加签的节点以及连线已经不需要应该如何删除; 修改流程定义缓存后, 由于缓存失效, 依然会报错 此时就需要先添加缓存, 然后完成任务 3. 加签原理代码讲解4. 加签节点存储表设计 Activiti 继承了 MyBatis 框架, 因此可以让我们注入配置文件或者注解类使用 MyBatis. 4.1. 表结构4.2. 实体类4.3. Mapper 类4.4. 注入流程引擎]]></content>
      <categories>
        <category>Activiti</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti(4)--多实例实现会签功能]]></title>
    <url>%2Fblog%2F2018%2F12%2F16%2FActiviti-4-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%AE%9E%E7%8E%B0%E4%BC%9A%E7%AD%BE%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1. Activiti 多实例 多实例节点是在业务流程中定义重复环节的一种方式 从开发角度讲, 多实例类似于循环, 可以根据给定的集合, 为每个元素执行一个环境甚至一个子流程, 既可以顺序依次执行也可以并发同步执行. 多实例是在一个普通节点上添加额外的属性定义, 这样被多实例修饰的节点就会执行多次, 在 BPMN 规范中, 下面的节点都可以成为一个多实例节点: UserTask Script Task Java Service Task Web Service Task Business Rule Task Email Task Manual Task Receive Task Sub-Process Call Activity 每个上级流程为每个实例创建分支的时候都要提供如下变量: nrOfInstances: 实例总数 nrOfActiveInstances: 当前活动的实例数量, 对于顺序执行的多实例, 该值始终为1 nrOfCompletedInstances: 已经完成的实例数量 loopCounter: 当前实例所在循环的索引值, 其他实例不可见, 不会保存到流程实例级别. 可以通过 execution.getVariable(String key) 方法获得这些变量 1.1. isSequential表示节点时顺序执行还是并行执行, 默认为 false, 表示并行执行 1.2. 指定实例数量实例的数量会在进入节点时进行计算, 但也可以直接指定 123456&lt;multiInstanceLoopCharacteristics isSequential="false"&gt; &lt;!-- 可以使用loopCardinality子元素直接指定一个数字 --&gt; &lt;loopCardinality&gt;5&lt;/loopCardinality&gt; &lt;!-- 也可以使用结果为整数的表达式 --&gt; &lt;loopCardinality&gt;$&#123;nrOfOrders-nrOfCancellations&#125;&lt;/loopCardinality&gt;&lt;/multiInstanceLoopCharacteristics&gt; 1.3. 接收并遍历集合除此之外还可以通过 loopDataInputRef 元素设置一个类型为集合的流程变量名, 对于集合中的每个元素都会创建一个实例, 也可以通过 inputDataItem 子元素指定集合 123456&lt;userTask id="someTask" name="Activiti is awesome!" activiti:assignee="$&#123;user&#125;"&gt; &lt;multiInstanceLoopCharacteristics isSequential="false"&gt; &lt;loopDataInputRef&gt;userList&lt;/loopDataInputRef&gt; &lt;inputDataItem name="user"/&gt; &lt;/multiInstanceLoopCharacteristics&gt;&lt;/userTask&gt; loopDataInputRef 中的 userList 表示需要遍历的元素列表 inputDataItem 中的 user 表示每个分支都会拥有一个名为 user 的流程变量, 这个变量会包含集合中的对应元素, 在例子中用来设置用户任务的办理者, 也就是说 userTask 中的 activiti:assignee 属性的值需要和 inputDataItem 一致. 此外, 上述的变量名存在如下缺点: 名称复杂 BPMN2.0 规定不能该节点不能包含表达式 Activiti 通过 multiInstanceCharacteristics 中设置 collection 和 elementVariable 属性来解决这个问题: 123&lt;userTask id="someTask" name="Activiti is awesome!" activiti:assignee="$&#123;user&#125;"&gt; &lt;multiInstanceLoopCharacteristics isSequential="false" activiti:collection="$&#123;userList&#125;" activiti:elementVariable="user"/&gt;&lt;/userTask&gt; 二者实现的功能是相同的, 不过后者可以支持表达式, 这是我们动态配置用户任务属性的重要功能 1.4. 结束条件多实例节点默认会在所有节点完成后结束, 也可以指定一个表达式在每个实例结束时执行, 如果表达式返回 true, 所有其他的实例都会销毁, 多实例节点也会结束, 流程会继续执行. 123456&lt;userTask id="someTask" name="Activiti is awesome!" activiti:assignee="$&#123;user&#125;"&gt; &lt;multiInstanceLoopCharacteristics isSequential="false" activiti:collection="$&#123;userList&#125;" activiti:elementVariable="user"&gt; &lt;!-- 如果有 60% 的任务完成时, 其他任务会被删除, 流程继续进行 --&gt; &lt;completionCondition&gt;$&#123;nrOfCompletedInstances/nrOfInstances &gt;= 0.6&#125;&lt;/completionCondition&gt; &lt;/multiInstanceLoopCharacteristics&gt;&lt;/userTask&gt; 2. 会签逻辑经过以上对 Activiti 多实例的介绍可知, 实现会签功能几个重要的点在于: 利用多实例完成动态实例的创建 根据业务设置合适的结束条件 2.1. 流程定义2.1.1. XML 格式123456789&lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask" /&gt; &lt;userTask id="someTask" name="Activiti is awesome!" activiti:assignee="$&#123;user&#125;"&gt; &lt;multiInstanceLoopCharacteristics isSequential="false" activiti:collection="$&#123;userList&#125;" activiti:elementVariable="user"/&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end" /&gt;&lt;/process&gt; 2.1.2. BpmnModel 模型用到的测试类: 123456789@Slf4j@Componentpublic class UsersBean implements Serializable &#123; public List&lt;String&gt; getUsers(String userId) &#123; log.info("userId: &#123;&#125;", userId); return Arrays.asList(userId + "1", userId + "2", userId + "3"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Testpublic void testExclusionGatewayModel() &#123; BpmnModel bpmnModel = new BpmnModel(); Process process = new Process(); process.setId("my-process"); StartEvent startEvent = new StartEvent(); startEvent.setId("startEvent"); UserTask someTask = new UserTask(); someTask.setId("someTask"); someTask.setName("Activiti is awesome!"); someTask.setAssignee("$&#123;user&#125;"); MultiInstanceLoopCharacteristics multiInstanceLoopCharacteristics = new MultiInstanceLoopCharacteristics(); multiInstanceLoopCharacteristics.setSequential(false); multiInstanceLoopCharacteristics.setInputDataItem("$&#123;usersBean.getUsers(name)&#125;"); multiInstanceLoopCharacteristics.setElementVariable("user"); multiInstanceLoopCharacteristics.setCompletionCondition("$&#123;nrOfCompletedInstances &gt; 0&#125;"); someTask.setLoopCharacteristics(multiInstanceLoopCharacteristics); EndEvent endEvent = new EndEvent(); endEvent.setId("endEvent"); SequenceFlow flow1 = createSequence("startEvent", "someTask", "flow1", "flow1", null); SequenceFlow flow2 = createSequence("someTask", "endEvent", "flow2", "flow2", null); process.addFlowElement(startEvent); process.addFlowElement(someTask); process.addFlowElement(endEvent); process.addFlowElement(flow1); process.addFlowElement(flow2); bpmnModel.addProcess(process); // client Deployment deployment = activitiRule.getRepositoryService().createDeployment() .addBpmnModel("bpmn", bpmnModel) .deploy(); log.info("deployment: &#123;&#125;", ToStringBuilder.reflectionToString(deployment, ToStringStyle.JSON_STYLE)); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("usersBean", usersBean); map.put("name", "wk"); ProcessInstance processInstance = activitiRule.getRuntimeService().startProcessInstanceByKey("my-process", map); log.info("processInstance: &#123;&#125;", ToStringBuilder.reflectionToString(processInstance, ToStringStyle.JSON_STYLE)); List&lt;Task&gt; taskList = activitiRule.getTaskService().createTaskQuery().list(); log.info("当前 taskList 数量: &#123;&#125;", taskList.size()); for (Task task : taskList) &#123; log.info("task: &#123;&#125;", ToStringBuilder.reflectionToString(task, ToStringStyle.JSON_STYLE)); &#125; activitiRule.getTaskService().complete(taskList.get(0).getId()); log.info("其中一个节点完成审批"); taskList = activitiRule.getTaskService().createTaskQuery().list(); log.info("第一个节点审批完成后 taskList 数量: &#123;&#125;", taskList.size()); for (Task task : taskList) &#123; log.info("第一个节点审批完成后 task: &#123;&#125;", ToStringBuilder.reflectionToString(task, ToStringStyle.JSON_STYLE)); &#125;&#125; 2.1.3. 日志输出09:55:17,517 [main] INFO org.destiny.activiti.GatewayExpressSpringTest - processInstance: {&quot;currentFlowElement&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;processInstance&quot;:&quot;ProcessInstance[4]&quot;,&quot;parent&quot;:null,&quot;executions&quot;:[Multi instance root execution[ id &apos;8&apos; ] - activity &apos;someTask - parent &apos;4&apos;],&quot;superExecution&quot;:null,&quot;subProcessInstance&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;name&quot;:null,&quot;description&quot;:null,&quot;localizedName&quot;:null,&quot;localizedDescription&quot;:null,&quot;lockTime&quot;:null,&quot;isActive&quot;:true,&quot;isScope&quot;:true,&quot;isConcurrent&quot;:false,&quot;isEnded&quot;:false,&quot;isEventScope&quot;:false,&quot;isMultiInstanceRoot&quot;:false,&quot;isCountEnabled&quot;:false,&quot;eventName&quot;:null,&quot;eventSubscriptions&quot;:[],&quot;jobs&quot;:[],&quot;timerJobs&quot;:[],&quot;tasks&quot;:[],&quot;identityLinks&quot;:[IdentityLinkEntity[id=24, type=participant, userId=wk1, processInstanceId=4], IdentityLinkEntity[id=27, type=participant, userId=wk2, processInstanceId=4], IdentityLinkEntity[id=30, type=participant, userId=wk3, processInstanceId=4]],&quot;deleteReason&quot;:null,&quot;suspensionState&quot;:1,&quot;startUserId&quot;:null,&quot;startTime&quot;:&quot;Sun Dec 16 21:55:17 CST 2018&quot;,&quot;eventSubscriptionCount&quot;:0,&quot;taskCount&quot;:0,&quot;jobCount&quot;:0,&quot;timerJobCount&quot;:0,&quot;suspendedJobCount&quot;:0,&quot;deadLetterJobCount&quot;:0,&quot;variableCount&quot;:0,&quot;identityLinkCount&quot;:0,&quot;processDefinitionId&quot;:&quot;my-process:1:3&quot;,&quot;processDefinitionKey&quot;:&quot;my-process&quot;,&quot;processDefinitionName&quot;:null,&quot;processDefinitionVersion&quot;:1,&quot;deploymentId&quot;:null,&quot;activityId&quot;:null,&quot;activityName&quot;:null,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;businessKey&quot;:null,&quot;parentId&quot;:null,&quot;superExecutionId&quot;:null,&quot;rootProcessInstanceId&quot;:&quot;4&quot;,&quot;rootProcessInstance&quot;:null,&quot;forcedUpdate&quot;:false,&quot;queryVariables&quot;:null,&quot;isDeleted&quot;:false,&quot;variableInstances&quot;:{usersBean=VariableInstanceEntity[id=6, name=usersBean, type=serializable, byteArrayValueId=5]},&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;4&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:true,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 09:59:03,449 [main] INFO org.destiny.activiti.GatewayExpressSpringTest - 当前 taskList 数量: 3 09:59:03,450 [main] INFO org.destiny.activiti.GatewayExpressSpringTest - task: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:1,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:&quot;wk1&quot;,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Activiti is awesome!&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:null,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sun Dec 16 21:59:03 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;14&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;my-process:1:3&quot;,&quot;taskDefinitionKey&quot;:&quot;someTask&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;24&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 09:59:03,450 [main] INFO org.destiny.activiti.GatewayExpressSpringTest - task: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:1,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:&quot;wk2&quot;,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Activiti is awesome!&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:null,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sun Dec 16 21:59:03 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;15&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;my-process:1:3&quot;,&quot;taskDefinitionKey&quot;:&quot;someTask&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;27&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 09:59:03,451 [main] INFO org.destiny.activiti.GatewayExpressSpringTest - task: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:1,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:&quot;wk3&quot;,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Activiti is awesome!&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:null,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sun Dec 16 21:59:03 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;16&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;my-process:1:3&quot;,&quot;taskDefinitionKey&quot;:&quot;someTask&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;30&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} ... 09:55:17,585 [main] INFO org.destiny.activiti.GatewayExpressSpringTest - 其中一个节点完成审批 09:55:17,587 [main] INFO org.destiny.activiti.GatewayExpressSpringTest - 第一个节点审批完成后 taskList 数量: 0 3. 多实例任务节点完成自定义条件]]></content>
      <categories>
        <category>Activiti</category>
        <category>Java</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti(3)--数据模型设计]]></title>
    <url>%2Fblog%2F2018%2F12%2F11%2FActiviti-3-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[数据表分类 描述 ACT_GE_* 通用数据表 ACT_RE_* 流程定义存储表 ACT_ID_* 身份信息表 ACT_RU_* 运行时数据库表 ACT_HI_* 历史数据库表, 为了保证运行时数据尽可能少, 流程执行完就会将相关数据迁移到历史表中 核心引擎: activiti.mysql.create.engine.sql 历史数据: activiti.mysql.create.history.sql 身份数据: activiti.mysql.create.identity.sql Activiti 除了核心引擎以外, 其他都是可选的. 首先创建 ACT_GE_PROPERTY 表, 并写入: schema.version(schema 版本) schema.history(schema 历史) next.dbid(自增 id)三条记录 1. 通用数据库 数据表分类 描述 ACT_GE_PROPERTY 属性表(保存流程引擎的 kv 键值属性) ACT_GE_BYTEARRAY 资源表(存储流程定义相关的资源, 如 xml, 流程定义图) 1.1. ACT_GE_PROPERTY对应实体类 org.activiti.engine.impl.persistence.entity.PropertyEntityImpl 1.2 ACT_GE_BYTEARRAY对应实体类 org.activiti.engine.impl.persistence.entity.ByteArrayEntityImpl 其中 GENERATED_ 字段标识该资源文件是自动生成还是人工上传 如果不想添加身份信息相关数据库和历史数据相关数据库, 可以在配置中显式指定 1234567891011&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration"&gt; &lt;property name="jdbcUrl" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000;MVCC=TRUE"/&gt; &lt;property name="jdbcDriver" value="org.h2.Driver"/&gt; &lt;property name="jdbcUsername" value="sa"/&gt; &lt;property name="jdbcPassword" value=""/&gt; &lt;!-- 不创建 ACT_ID_* 相关的表 --&gt; &lt;property name="dbIdentityUsed" value="false"/&gt; &lt;!-- 不创建 ACT_HI_* 相关的表 --&gt; &lt;property name="dbHistoryUsed" value="false"/&gt;&lt;/bean&gt; 2. 流程定义存储表 数据表分类 描述 ACT_RE_DEPLOYMENT 流程部署记录表 ACT_RE_PROCDEF 流程定义信息表 ACT_RE_MODEL 模型信息表(用于 web 设计器) ACT_PROCDEF_INFO 流程定义动态改变信息表 2.1. ACT_RE_DEPLOYMENT对应实体 org.activiti.engine.impl.persistence.entity.DeploymentEntityImpl 关键字段 描述 ID_ 主键 NAME_ 名称 CATEGORY_ 分类 TENANT_ID_ 多租户标志 DEPLOY_TIME_ 部署时间 KEY_ 标志 key ENGINE_VERSION_ 兼容版本, 如果使用 Activiti5, 在升级到6后会有特殊标志 2.2 ACT_RE_PROCDEF对应实体 org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntityImpl 关键字段 描述 DEPLOYMENT_ID_ 关联部署 id RESOURCE_NAME_ 流程定义资源名称 DGRM_RESOURCE_NAME_ 流程图片资源名称 HAS_START_FORM_KEY_ 是否存在开始表单标志 HAS_GRAPHICAL_NOTATION_ 是否有图形信息 SUSPENSION_STATE_ 挂起状态 1 正常, 2 挂起 2.3. 测试代码12345678@Testpublic void testDeploy() &#123; activitiRule.getRepositoryService() .createDeployment() .name("二次审批流程") .addClasspathResource("org/destiny/activiti/SecondApprove.bpmn20.xml") .deploy();&#125; ACT_RE_DEPLOYMENT 表内容: mysql&gt; select * from ACT_RE_DEPLOYMENT \G; *************************** 1. row *************************** ID_: 1 NAME_: 二次审批流程 CATEGORY_: NULL KEY_: NULL TENANT_ID_: DEPLOY_TIME_: 2018-12-11 09:11:27.538 ENGINE_VERSION_: NULL ACT_RE_PROCDEF 表内容: mysql&gt; select * from ACT_RE_PROCDEF \G; *************************** 1. row *************************** ID_: SecondApprove:1:4 REV_: 1 CATEGORY_: http://www.activiti.org/test NAME_: 二级审批 KEY_: SecondApprove VERSION_: 1 DEPLOYMENT_ID_: 1 RESOURCE_NAME_: org/destiny/activiti/SecondApprove.bpmn20.xml DGRM_RESOURCE_NAME_: org/destiny/activiti/SecondApprove.SecondApprove.png DESCRIPTION_: NULL HAS_START_FORM_KEY_: 0 HAS_GRAPHICAL_NOTATION_: 1 SUSPENSION_STATE_: 1 TENANT_ID_: ENGINE_VERSION_: NULL 可以看到, 其中 HAS_START_FORM_KEY_ 为 0, DESCRIPTION_ 为 NULL, 二者都需要去流程定义文件中设置 HAS_START_FORM_KEY_ 需要在 startEvent 中设置 actviti:formKey; DESCRIPTION 需要设置 documentation 修改流程定义文件: 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="SecondApprove" name="二级审批" isExecutable="true"&gt; &lt;documentation&gt;审批流程描述&lt;/documentation&gt; &lt;startEvent id="startEvent" name="开始" activiti:formKey="/process/form/key"&gt;&lt;/startEvent&gt; &lt;userTask id="submitApprove" name="填写申请信息"&gt; 然后重新部署即可看到: mysql&gt; select * from ACT_RE_PROCDEF \G; *************************** 1. row *************************** ID_: SecondApprove:1:4 REV_: 1 CATEGORY_: http://www.activiti.org/test NAME_: 二级审批 KEY_: SecondApprove VERSION_: 1 DEPLOYMENT_ID_: 1 RESOURCE_NAME_: org/destiny/activiti/SecondApprove.bpmn20.xml DGRM_RESOURCE_NAME_: org/destiny/activiti/SecondApprove.SecondApprove.png DESCRIPTION_: NULL HAS_START_FORM_KEY_: 0 HAS_GRAPHICAL_NOTATION_: 1 SUSPENSION_STATE_: 1 TENANT_ID_: ENGINE_VERSION_: NULL *************************** 2. row *************************** ID_: SecondApprove:2:2504 REV_: 1 CATEGORY_: http://www.activiti.org/test NAME_: 二级审批 KEY_: SecondApprove VERSION_: 2 DEPLOYMENT_ID_: 2501 RESOURCE_NAME_: org/destiny/activiti/SecondApprove.bpmn20.xml DGRM_RESOURCE_NAME_: org/destiny/activiti/SecondApprove.SecondApprove.png DESCRIPTION_: 审批流程描述 HAS_START_FORM_KEY_: 0 HAS_GRAPHICAL_NOTATION_: 1 SUSPENSION_STATE_: 1 TENANT_ID_: ENGINE_VERSION_: NULL ACT_RE_PROCDEF 是基于 KEY_ 去升级版本号, 当原有的 key 已经存在, 就会升级版本号, 其中 KEY_, VERSION_, TENANT_ID_ 共同组成一个唯一键 3. 身份数据表设计 数据表设计 描述 ACT_ID_USER 用户的基本信息 ACT_ID_INFO 用户的扩展信息 ACT_ID_GROUP 群组 ACT_ID_MEMBERSHIP 用户与群组关系 3.1. 用户信息表对应实体 org.activiti.engine.impl.persistence.entity.UserEntityImpl +-------------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------------+--------------+------+-----+---------+-------+ | ID_ | varchar(64) | NO | PRI | NULL | | | REV_ | int(11) | YES | | NULL | | | FIRST_ | varchar(255) | YES | | NULL | | | LAST_ | varchar(255) | YES | | NULL | | | EMAIL_ | varchar(255) | YES | | NULL | | | PWD_ | varchar(255) | YES | | NULL | | | PICTURE_ID_ | varchar(64) | YES | | NULL | | +-------------+--------------+------+-----+---------+-------+ 3.2. 用户扩展信息对应实体 org.activiti.engine.impl.persistence.entity.IdentityInfoEntityImpl +------------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +------------+--------------+------+-----+---------+-------+ | ID_ | varchar(64) | NO | PRI | NULL | | | REV_ | int(11) | YES | | NULL | | | USER_ID_ | varchar(64) | YES | | NULL | | | TYPE_ | varchar(64) | YES | | NULL | | | KEY_ | varchar(255) | YES | | NULL | | | VALUE_ | varchar(255) | YES | | NULL | | | PASSWORD_ | longblob | YES | | NULL | | | PARENT_ID_ | varchar(255) | YES | | NULL | | +------------+--------------+------+-----+---------+-------+ USER_ID_: 关联用户 id TYPE_: 类型(固定值) KEY_: 属性名 VALUE_: 属性值 PASSWORD_: 密码(未使用) PARENT_ID_: 上级关联(不建议使用) 3.3. ACT_ID_GROUP对应实体 org.activiti.engine.impl.persistence.entity.GroupEntityImpl +-------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+--------------+------+-----+---------+-------+ | ID_ | varchar(64) | NO | PRI | NULL | | | REV_ | int(11) | YES | | NULL | | | NAME_ | varchar(255) | YES | | NULL | | | TYPE_ | varchar(255) | YES | | NULL | | +-------+--------------+------+-----+---------+-------+ 3.4. 用户组关系表对应实体 org.activiti.engine.impl.persistence.entity.MembershipEntityImpl +-----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------+-------------+------+-----+---------+-------+ | USER_ID_ | varchar(64) | NO | PRI | NULL | | | GROUP_ID_ | varchar(64) | NO | PRI | NULL | | +-----------+-------------+------+-----+---------+-------+ 测试代码: 1234567891011121314151617181920@Testpublic void testIdentity() &#123; IdentityService identityService = activitiRule.getIdentityService(); User user1 = identityService.newUser("user1"); user1.setFirstName("firstName"); user1.setLastName("lastName"); user1.setEmail("user1@126.com"); user1.setPassword("pwd"); identityService.saveUser(user1); User user2 = identityService.newUser("user2"); identityService.saveUser(user2); Group group1 = identityService.newGroup("group1"); group1.setName("for test"); identityService.saveGroup(group1); identityService.createMembership(user1.getId(), group1.getId()); identityService.createMembership(user2.getId(), group1.getId()); // 扩展信息 identityService.setUserInfo(user1.getId(), "age", "18"); identityService.setUserInfo(user1.getId(), "identity", "destiny");&#125; 4. 运行时流程数据表 数据表分类 描述 ACT_RU_EXECUTION 流程实例与分支执行信息 ACT_RU_TASK 用户任务信息 ACT_RU_VARIABLE 变量信息 ACT_RU_IDENTITYLINK 参与者相关信息 ACT_RU_EVENT_SUBSCR 事件监听表 ACT_RU_JOB 作业表 ACT_RU_TIMER_JOB 定时器表 ACT_RU_SUSPENDED_JOB 暂停作业表 ACT_RU_DEADLETTER_JOB 死信表 4.1. ACT_RU_EXECUTION对应实体类 org.activiti.engine.impl.persistence.entity.ExecutionEntityImpl 关键字段 描述 PROC_INST_ID_ 流程实例 ID BUSINESS_KEY_ 业务标志 PARENT_ID_ 父执行信息 PROC_DEF_ID_ 流程定义 ID SUPER_EXEC_ 父流程实例对应的执行 ACT_ID_ 流程定义节点 ID IS_ACTIVE 是否活动的执行 0-非活动, 1-活动 IS_CONCURRENT_ 是否并行分支 0-非, 1-是 IS_SCOPE_ 是否全局流程执行 0-非, 1-是 IS_EVENT_SCOPE_ 是否激活状态 SUSPENSION_STATE 挂起状态 1-正常, 2-挂起 LOCK_TIME_ 锁定时间 4.2. ACT_RU_TASK对应实体类 org.activiti.engine.impl.persistence.entity.TaskEntityImpl 关键字段 描述 EXECUTION_ID_ 执行流 id PROC_INST_ID_ 流程实例 ID PROC_DEF_ID_ 流程定义 ID PARENT_TASK_ID_ 父任务 TASK_DEF_KEY_ 任务定义 ID NAME_ 任务定义名称 OWNER_ 拥有人 ASSIGNEE_ 代理人 DELEGATION_ 委托状态 PENDING-委托中, RESOLVED 已处理 PRIORITY_ 优先级 DUE_DATE_ 过期时间 FORM_KEY_ 表单标志 4.3. ACT_RU_VARIABLE对应实体类 org.activiti.engine.impl.persistence.entity.VariableInstanceEntityImpl 关键字段 描述 TYPE_ 变量名称(integer, string, double, json) NAME_ 变量名 BYTEARRAY_ID_ 资源表 id DOUBLE_ 浮点值 LONG_ 长整型数值 TEXT_ 文本值 4.4. ACT_RU_IDENTITYLINK对应实体类 org.activiti.engine.impl.persistence.entity.IdentityInfoEntityImpl 当用户和流程建立关系的时候, 就会在此表中插入记录 关键字段 描述 ID_ 主键 GROUP_ID_ 用户组 ID TYPE_ 类型 assignee, candidate, owner, starter… USER_ID_ 用户 ID TASK_ID_ 任务 ID PROC_INST_ID_ 流程实例 4.5. ACT_RU_EVENT_SUBSCR对应实体类 org.activiti.engine.impl.persistence.entity.EventSubscriptionEntityImpl 关键字段 描述 EVENT_TYPE_ 事件类型 message, signal EVENT_NAME_ 事件名称 EXECUTION_ID_ 流程执行 ID PROC_INST_ID_ 流程实例 ID ACTIVITY_ID_ 流程定义节点 ID CONFIGURATION_ 配置 4.6. ACT_RU_JOB对应实体类 org.activiti.engine.impl.persistence.entity.JobEntityImpl 关键字段 描述 TYPE_ 类型 LOCK_EXP_TIME_ 锁定过期时间 LOCK_OWNER_ 锁定接点 EXCLUSIVE_ 是否唯一 RETRIES_ 重试次数3 REPEAT_ 重复表达式 R5/PT10S EXCEPTION_STACK_ID_ 异常堆栈(资源表 ID) EXCEPTION_MSG_ 异常信息 DUEDATE_ 过期时间 HANDLER_TYPE_ 处理器类型 HANDLER_CFG 处理器配置 EXECUTION_ID_ 流程执行表 ID 4.7 测试代码12345678910111213@Testpublic void testRuntime() &#123; Deployment deployment = activitiRule.getRepositoryService() .createDeployment() .name("二次审批") .addClasspathResource("org/destiny/activiti/SecondApprove.bpmn20.xml") .deploy(); log.info("deployment: &#123;&#125;", deployment); Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("k1", "v1"); ProcessInstance processInstance = activitiRule.getRuntimeService() .startProcessInstanceByKey("SecondApprove", variables);&#125; 4.7.1 ACT_RU_EXECUTION 表执行完成后, ACT_RU_EXECUTION 表会生成如下两条记录, 流程启动和用户任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162*************************** 1. row *************************** ID_: 5 REV_: 1 PROC_INST_ID_: 5 BUSINESS_KEY_: NULL PARENT_ID_: NULL PROC_DEF_ID_: SecondApprove:1:4 SUPER_EXEC_: NULL ROOT_PROC_INST_ID_: 5 ACT_ID_: NULL IS_ACTIVE_: 1 IS_CONCURRENT_: 0 IS_SCOPE_: 1 IS_EVENT_SCOPE_: 0 IS_MI_ROOT_: 0 SUSPENSION_STATE_: 1 CACHED_ENT_STATE_: NULL TENANT_ID_: NAME_: NULL START_TIME_: 2018-12-12 03:40:16.634 START_USER_ID_: NULL LOCK_TIME_: NULL IS_COUNT_ENABLED_: 0 EVT_SUBSCR_COUNT_: 0 TASK_COUNT_: 0 JOB_COUNT_: 0 TIMER_JOB_COUNT_: 0 SUSP_JOB_COUNT_: 0DEADLETTER_JOB_COUNT_: 0 VAR_COUNT_: 0 ID_LINK_COUNT_: 0*************************** 2. row *************************** ID_: 7 REV_: 1 PROC_INST_ID_: 5 BUSINESS_KEY_: NULL PARENT_ID_: 5 PROC_DEF_ID_: SecondApprove:1:4 SUPER_EXEC_: NULL ROOT_PROC_INST_ID_: 5 ACT_ID_: submitApprove IS_ACTIVE_: 1 IS_CONCURRENT_: 0 IS_SCOPE_: 0 IS_EVENT_SCOPE_: 0 IS_MI_ROOT_: 0 SUSPENSION_STATE_: 1 CACHED_ENT_STATE_: NULL TENANT_ID_: NAME_: NULL START_TIME_: 2018-12-12 03:40:16.636 START_USER_ID_: NULL LOCK_TIME_: NULL IS_COUNT_ENABLED_: 0 EVT_SUBSCR_COUNT_: 0 TASK_COUNT_: 0 JOB_COUNT_: 0 TIMER_JOB_COUNT_: 0 SUSP_JOB_COUNT_: 0DEADLETTER_JOB_COUNT_: 0 VAR_COUNT_: 0 ID_LINK_COUNT_: 0 两条记录的 PROC_DEF_ID_ 相同, 说明是同一个流程的实例. 第一条记录的 ID_ 是5, 第二条记录的 PARENT_ID_ 是 5, 说明第二条是第一条生成的. 第二条记录的 ACT_ID_ 值为 submitApprove, 代表 userTask 的一个节点 第二条记录的 IS_SCOPE 值为 0, 代表不是一个全局的执行流, 而第一条是一个全局执行流. 4.7.2 ACT_RU_TASK 表123456789101112131415161718192021*************************** 1. row *************************** ID_: 10 REV_: 1 EXECUTION_ID_: 7 PROC_INST_ID_: 5 PROC_DEF_ID_: SecondApprove:1:4 NAME_: 填写申请信息 PARENT_TASK_ID_: NULL DESCRIPTION_: NULL TASK_DEF_KEY_: submitApprove OWNER_: NULL ASSIGNEE_: NULL DELEGATION_: NULL PRIORITY_: 50 CREATE_TIME_: 2018-12-12 03:40:16.641 DUE_DATE_: NULL CATEGORY_: NULLSUSPENSION_STATE_: 1 TENANT_ID_: FORM_KEY_: NULL CLAIM_TIME_: NULL PROC_DEF_ID_ 为 SecondApprove:1:4 4.7.3. ACT_RU_VARIABLE 表 保存启动时候设置的变量 12345678910111213*************************** 1. row *************************** ID_: 6 REV_: 1 TYPE_: string NAME_: k1EXECUTION_ID_: 5PROC_INST_ID_: 5 TASK_ID_: NULLBYTEARRAY_ID_: NULL DOUBLE_: NULL LONG_: NULL TEXT_: v1 TEXT2_: NULL 执行设置所属人的代码: 12345678910@Testpublic void testSetOwner() &#123; TaskService taskService = activitiRule.getTaskService(); Task task = taskService .createTaskQuery() .processDefinitionKey("SecondApprove") .singleResult(); // 设置所属人 taskService.setOwner(task.getId(), "destiny");&#125; 4.7.4 ACT_RU_IDENTITYLINK*************************** 1. row *************************** ID_: 2501 REV_: 1 GROUP_ID_: NULL TYPE_: participant USER_ID_: destiny TASK_ID_: NULL PROC_INST_ID_: 5 PROC_DEF_ID_: NULL 而此时在 ACT_RU_TASK 表, 对应的 task 的 OWNER_ 字段已经赋值为 destiny 4.7.5 ACT_RU_TASK*************************** 1. row *************************** ID_: 10 REV_: 2 EXECUTION_ID_: 7 PROC_INST_ID_: 5 PROC_DEF_ID_: SecondApprove:1:4 NAME_: 填写申请信息 PARENT_TASK_ID_: NULL DESCRIPTION_: NULL TASK_DEF_KEY_: submitApprove OWNER_: destiny ASSIGNEE_: NULL DELEGATION_: NULL PRIORITY_: 50 CREATE_TIME_: 2018-12-12 07:19:33.134 DUE_DATE_: NULL CATEGORY_: NULL SUSPENSION_STATE_: 1 TENANT_ID_: FORM_KEY_: NULL CLAIM_TIME_: NULL 5. 历史流程数据表 数据表分类 描述 ACT_HI_PROCINST 历史流程实例表 ACT_HI_ACTINST 历史节点信息表, 执行过程中每经过一个节点就会插入一条记录 ACT_HI_TASKINST 历史任务表 ACT_HI_VARINST 历史变量 ACT_HI_IDENTITYLINK 历史参与者 ACT_HI_DETAIL 历史变更, 当使用 FormService 提交表单时, 表单的属性就会存储在该表, 以及变量的更改 ACT_HI_ATTACHMENT 附件 ACT_HI_COMMENT 评论 ACT_EVT_LOG 事件日志 5.1 ACT_HI_PROCINST| 关键字段 |]]></content>
      <categories>
        <category>Activiti</category>
        <category>Java</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti(2)--BPMN2.0规范]]></title>
    <url>%2Fblog%2F2018%2F12%2F08%2FActiviti-2-BPMN2-0%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[BPMN2.0: 是一套业务流程模型与符号建模标准 精准的执行语义来描述元素的操作 以 XML 为载体, 以符号可视化业务 BPMN2.0元素: 流对象 连接对象 数据 泳道 描述对象 其中最重要的流对象, 流对象包括活动, 事件和网关, 通过连接对象连接起来, 用来表示数据的流转, 泳道用来对业务的范围做区分, 描述对象并不影响业务的进行, 为流程图的可读性做补充性的描述. 1. 事件1.1 分类按照位置分类: 开始事件 中间事件/边界事件(中间事件是指出现在流程中, 可以单独作为流程节点的事件, 而边界事件指的是附属于某个流程节点的事件) 结束事件 按照特征分类: 捕获时间, 捕获事件是一直在等待被触发的事件, 所有的开始事件都是等待被触发的事件 抛出事件, 执行到节点会自动执行并抛出结果, 结束事件都属于抛出事件. 按照定义分类: 定时事件 错误事件 信号事件 消息事件 1.1.1 定时事件 在使用定时事件时, 首先需要流程引擎的异步开关打开 指定时间(timeDate) 指定持续时间(timeDuration) 周期执行(timeCycle) 定时事件的定义方式: 1234&lt;timerEventDefinition&gt; &lt;!-- 指定定时时间的类型: timeDate --&gt; &lt;timeDate&gt;2018-01-01T10:10:10&lt;/timeDate&gt;&lt;/timerEventDefinition&gt; 1.1.1.1 定时开始事件 123456&lt;startEvent id="timerStartEvent" name="Timer Start"&gt; &lt;timerEventDefinition&gt; &lt;!--在流程部署完成 5 分钟后, 执行5次 --&gt; &lt;timeCycle&gt;R5/PT5M&lt;/timeCycle&gt; &lt;/timerEventDefinition&gt;&lt;/startEvent&gt; 1.1.1.2 定时边界事件 流程流转到一个普通任务时, 如果在指定时间内没有完成, 就会触发定时边界事件 流程定义1234567891011121314151617&lt;startEvent id="startEvent"/&gt;&lt;userTask id="commonTask" name="Common Task"/&gt;&lt;!-- 声明边界事件, attachedToRef 指定边界事件的宿主 --&gt;&lt;boundaryEvent id="boundaryEvent" name="Timer" attachedToRef="commonTask" cancelActivity="true"&gt; &lt;timerEventDefinition&gt; &lt;!-- 部署完 5 秒之后 --&gt; &lt;timeDuration&gt;PT5S&lt;/timeDuration&gt; &lt;/timerEventDefinition&gt;&lt;/boundaryEvent&gt;&lt;userTask id="timeoutTask" name="Timeout Task"/&gt;&lt;endEvent id="end1"/&gt;&lt;endEvent id="end2"/&gt;&lt;!-- 构建顺序流 --&gt;&lt;sequenceFlow sourceRef="startEvent" targetRef="commonTask"/&gt;&lt;sequenceFlow sourceRef="commonTask" targetRef="end1"/&gt;&lt;sequenceFlow sourceRef="boundaryEvent" targetRef="timeoutTask"/&gt;&lt;sequenceFlow sourceRef="timeoutTask" targetRef="end2"/&gt; 测试代码123456789101112131415161718192021222324/** * 超时边界事件 * 流程启动之后, 流转到 commonTask, 此时让当前线程休眠 10 秒(5秒就会超时) * 定时任务超时后执行 timeoutTask */@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-time-boundary.bpmn20.xml"&#125;)public void testTimerBoundary() throws InterruptedException &#123; activitiRule.getRuntimeService().startProcessInstanceByKey("my-process"); // task 列表 List&lt;Task&gt; taskList = activitiRule.getTaskService().createTaskQuery().list(); log.info("task 总数: &#123;&#125;", taskList.size()); for (Task task : taskList) &#123; log.info("task.name = &#123;&#125;", task.getName()); &#125; // 强制睡眠等待边界事件触发 Thread.sleep(10 * 1000); // task 列表 taskList = activitiRule.getTaskService().createTaskQuery().list(); log.info("休眠后 task 总数: &#123;&#125;", taskList.size()); for (Task task : taskList) &#123; log.info("休眠后 task.name = &#123;&#125;", task.getName()); &#125;&#125; 日志输出11:06:06,568 [main] INFO org.destiny.activiti.bpmn20.TimerEventTest - task 总数: 1 11:06:06,568 [main] INFO org.destiny.activiti.bpmn20.TimerEventTest - task.name = Common Task ... 11:06:16,573 [main] INFO org.destiny.activiti.bpmn20.TimerEventTest - 休眠后 task 总数: 1 11:06:16,573 [main] INFO org.destiny.activiti.bpmn20.TimerEventTest - 休眠后 task.name = Timeout Task 1.1.2 错误事件 网关中由提交的表单信息判断正常结束还是异常结束, 错误事件会被错误信息所触发, 主要用于处理业务异常 流程图简单分析 提交一个新的 sales leader, 创建一个子流程, 在子流程中同时对 customer rating 以及 profitability 进行考察, 如果同时通过, 则结束子流程, 完成主流程的 Store lead in CRM system 任务以及结束节点 如果 profitability 任务没有提供足够的信息, 则会抛出错误事件, 错误事件被边界事件所捕获, 进入 Provide additional details 流程, 并进入开始子流程 流程定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;error id="notEnoughInfoError" errorCode="not_enough_info" /&gt;&lt;process id="reviewSaledLead" name="Review sales lead"&gt; &lt;startEvent id="theStart" activiti:initiator="initiator" /&gt; &lt;sequenceFlow id="flow1" sourceRef="theStart" targetRef="provideNewSalesLead"/&gt; &lt;userTask id="provideNewSalesLead" name="Provide new sales lead" activiti:assignee="$&#123;initiator&#125;"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="customerName" name="Customer name" type="string" required="true"/&gt; &lt;activiti:formProperty id="potentialProfit" name="Potential profit" type="long" /&gt; &lt;activiti:formProperty id="details" name="Details" type="string"/&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow2" sourceRef="provideNewSalesLead" targetRef="reviewSalesLeadSubProcess"/&gt; &lt;!-- 子流程 --&gt; &lt;subProcess id="reviewSalesLeadSubProcess" name="Review sales lead"&gt; &lt;startEvent id="subProcessStart" /&gt; &lt;sequenceFlow id="flow3" sourceRef="subProcessStart" targetRef="fork"/&gt; &lt;sequenceFlow id="flow4" sourceRef="fork" targetRef="reviewProfitability"/&gt; &lt;parallelGateway id="fork" /&gt; &lt;sequenceFlow id="flow5" sourceRef="fork" targetRef="reviewCustomerRating"/&gt; &lt;userTask id="reviewCustomerRating" name="Review customer rating" activiti:candidateGroups="accountancy" /&gt; &lt;sequenceFlow id="flow6" sourceRef="reviewCustomerRating" targetRef="subProcessEnd1"/&gt; &lt;endEvent id="subProcessEnd1" /&gt; &lt;userTask id="reviewProfitability" name="Review profitability" activiti:candidateGroups="management"&gt; &lt;documentation&gt; $&#123;initiator&#125; has published a new sales lead: $&#123;customerName&#125;. Details: $&#123;details&#125; &lt;/documentation&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="notEnoughInformation" name="Do you believe this customer is profitable?" type="enum" required="true"&gt; &lt;activiti:value id="false" name="Yes" /&gt; &lt;activiti:value id="true" name="No (= request more info)" /&gt; &lt;/activiti:formProperty&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow7" sourceRef="reviewProfitability" targetRef="enoughInformationCheck"/&gt; &lt;exclusiveGateway id="enoughInformationCheck" name="Enough information?" /&gt; &lt;sequenceFlow id="flow8" sourceRef="enoughInformationCheck" targetRef="notEnoughInformationEnd"&gt; &lt;conditionExpression&gt;$&#123;notEnoughInformation == 'true'&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow id="flow9" sourceRef="enoughInformationCheck" targetRef="subProcessEnd2"&gt; &lt;conditionExpression&gt;$&#123;notEnoughInformation == 'false'&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;endEvent id="subProcessEnd2" /&gt; &lt;endEvent id="notEnoughInformationEnd"&gt; &lt;errorEventDefinition errorRef="notEnoughInfoError" /&gt; &lt;/endEvent&gt; &lt;/subProcess&gt; &lt;sequenceFlow id="flow10" sourceRef="reviewSalesLeadSubProcess" targetRef="storeLeadInCrmSystem"/&gt; &lt;boundaryEvent attachedToRef="reviewSalesLeadSubProcess" cancelActivity="true" id="catchNotEnoughInformationError" &gt; &lt;errorEventDefinition errorRef="notEnoughInfoError" /&gt; &lt;/boundaryEvent&gt; &lt;sequenceFlow id="flow11" sourceRef="catchNotEnoughInformationError" targetRef="provideAdditionalDetails"/&gt; &lt;userTask id="provideAdditionalDetails" name="Provide additional details" activiti:assignee="$&#123;initiator&#125;"&gt; &lt;documentation&gt;Provide additional details for $&#123;customerName&#125;.&lt;/documentation&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="details" name="Additional details" type="string" required="true"/&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow12" sourceRef="provideAdditionalDetails" targetRef="reviewSalesLeadSubProcess"/&gt; &lt;task id="storeLeadInCrmSystem" name="Store lead in CRM system" /&gt; &lt;sequenceFlow id="flow13" sourceRef="storeLeadInCrmSystem" targetRef="processEnd"/&gt; &lt;endEvent id="processEnd" /&gt;&lt;/process&gt; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class BoundaryErrorEventTest extends PluggableActivitiTestCase &#123; @Rule public ActivitiRule activitiRule = new ActivitiRule(); @Override protected void setUp() throws Exception &#123; super.setUp(); // 设置当前用户 Authentication.setAuthenticatedUserId("destiny"); &#125; @Override public void tearDown() throws Exception &#123; Authentication.setAuthenticatedUserId(null); super.tearDown(); &#125; @Deployment(resources = &#123;"org/destiny/activiti/reviewSalesLead.bpmn20.xml"&#125;) public void testReviewSalesLeadProcess() &#123; Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;(); variables.put("details", "interesting"); variables.put("customerName", "Camery"); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("reviewSaledLead", variables); log.info("processInstance: &#123;&#125;", ToStringBuilder.reflectionToString(processInstance, ToStringStyle.JSON_STYLE)); Task task = taskService.createTaskQuery() .taskAssignee("destiny") .singleResult(); log.info("task: &#123;&#125;", ToStringBuilder.reflectionToString(task, ToStringStyle.JSON_STYLE)); // 使用断言确认 assertEquals(task.getName(), "Provide new sales lead"); // 提交节点 taskService.complete(task.getId()); // 进入并行网关, 会同时生成两个 task Task ratingTask = taskService.createTaskQuery().taskCandidateGroup("accountancy").singleResult(); log.info("ratingTask: &#123;&#125;", ToStringBuilder.reflectionToString(ratingTask, ToStringStyle.JSON_STYLE)); assertEquals(ratingTask.getName(), "Review customer rating"); Task profitabilityTask = taskService.createTaskQuery().taskCandidateGroup("management").singleResult(); log.info("profitabilityTask: &#123;&#125;", ToStringBuilder.reflectionToString(profitabilityTask, ToStringStyle.JSON_STYLE)); assertEquals(profitabilityTask.getName(), "Review profitability"); // Review profitability 提交后就会触发 errorEvent variables = new HashMap&lt;&gt;(); variables.put("notEnoughInformation", true); taskService.complete(profitabilityTask.getId(), variables); // 查找流程发起者 destiny 对应的 task // 此时 errorEvent 会被边界条件捕获, 流转到 Review profitability Task provideDetailsTask = taskService.createTaskQuery().taskAssignee("destiny").singleResult(); log.info("provideDetailsTask: &#123;&#125;", ToStringBuilder.reflectionToString(provideDetailsTask, ToStringStyle.JSON_STYLE)); assertEquals(provideDetailsTask.getName(), "Provide additional details"); // 完成 Review profitability 节点后, 会重新进入子流程 taskService.complete(provideDetailsTask.getId()); List&lt;Task&gt; reviewTasks = taskService.createTaskQuery().orderByTaskName().asc().list(); for (Task reviewTask : reviewTasks) &#123; log.info("reviewTask: &#123;&#125;", ToStringBuilder.reflectionToString(reviewTask, ToStringStyle.JSON_STYLE)); &#125; assertEquals(reviewTasks.get(0).getName(), "Review customer rating"); assertEquals(reviewTasks.get(1).getName(), "Review profitability"); taskService.complete(reviewTasks.get(0).getId()); variables.put("notEnoughInformation", false); taskService.complete(reviewTasks.get(1).getId(), variables); assertProcessEnded(processInstance.getId()); &#125;&#125; 日志输出 分析日志可以看到, 没有错误所有的断言全部通过, 证明整个流程无误(日志量比较大, 为了能够清晰描述流程特地将日志格式调整) 03:53:20,823 [main] INFO org.activiti.engine.ProcessEngines - initialised process engine default 03:53:23,006 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,008 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : theStart (StartEvent, parent id 5 (active) 03:53:23,009 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,009 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : theStart (StartEvent, parent id 5 (active) 03:53:23,010 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,010 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : theStart -&gt; provideNewSalesLead, parent id 5 (active) 03:53:23,010 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,011 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : provideNewSalesLead (UserTask, parent id 5 (active) 03:53:23,053 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - processInstance: {&quot;currentFlowElement&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;processInstance&quot;:&quot;ProcessInstance[5]&quot;,&quot;parent&quot;:null,&quot;executions&quot;:[Execution[ id &apos;10&apos; ] - activity &apos;provideNewSalesLead - parent &apos;5&apos;],&quot;superExecution&quot;:null,&quot;subProcessInstance&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;name&quot;:null,&quot;description&quot;:null,&quot;localizedName&quot;:null,&quot;localizedDescription&quot;:null,&quot;lockTime&quot;:null,&quot;isActive&quot;:true,&quot;isScope&quot;:true,&quot;isConcurrent&quot;:false,&quot;isEnded&quot;:false,&quot;isEventScope&quot;:false,&quot;isMultiInstanceRoot&quot;:false,&quot;isCountEnabled&quot;:false,&quot;eventName&quot;:null,&quot;eventSubscriptions&quot;:[],&quot;jobs&quot;:[],&quot;timerJobs&quot;:[],&quot;tasks&quot;:[],&quot;identityLinks&quot;:[IdentityLinkEntity[id=7, type=starter, userId=destiny, processInstanceId=5]],&quot;deleteReason&quot;:null,&quot;suspensionState&quot;:1,&quot;startUserId&quot;:&quot;destiny&quot;,&quot;startTime&quot;:&quot;Sat Dec 08 15:53:23 CST 2018&quot;,&quot;eventSubscriptionCount&quot;:0,&quot;taskCount&quot;:0,&quot;jobCount&quot;:0,&quot;timerJobCount&quot;:0,&quot;suspendedJobCount&quot;:0,&quot;deadLetterJobCount&quot;:0,&quot;variableCount&quot;:0,&quot;identityLinkCount&quot;:0,&quot;processDefinitionId&quot;:&quot;reviewSaledLead:1:4&quot;,&quot;processDefinitionKey&quot;:&quot;reviewSaledLead&quot;,&quot;processDefinitionName&quot;:&quot;Review sales lead&quot;,&quot;processDefinitionVersion&quot;:1,&quot;deploymentId&quot;:null,&quot;activityId&quot;:null,&quot;activityName&quot;:null,&quot;processInstanceId&quot;:&quot;5&quot;,&quot;businessKey&quot;:null,&quot;parentId&quot;:null,&quot;superExecutionId&quot;:null,&quot;rootProcessInstanceId&quot;:&quot;5&quot;,&quot;rootProcessInstance&quot;:null,&quot;forcedUpdate&quot;:false,&quot;queryVariables&quot;:null,&quot;isDeleted&quot;:false,&quot;variableInstances&quot;:{details=VariableInstanceEntity[id=8, name=details, type=string, textValue=interesting], customerName=VariableInstanceEntity[id=9, name=customerName, type=string, textValue=Camery], initiator=VariableInstanceEntity[id=6, name=initiator, type=string, textValue=destiny]},&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;5&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:true,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 03:53:23,075 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - task: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:1,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:&quot;destiny&quot;,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Provide new sales lead&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:null,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sat Dec 08 15:53:23 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;10&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;5&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;reviewSaledLead:1:4&quot;,&quot;taskDefinitionKey&quot;:&quot;provideNewSalesLead&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;13&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 03:53:23,081 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 03:53:23,082 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : provideNewSalesLead (UserTask, parent id 5 (active) 03:53:23,083 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,083 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : provideNewSalesLead (UserTask, parent id 5 (active) 03:53:23,084 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,084 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : provideNewSalesLead -&gt; reviewSalesLeadSubProcess, parent id 5 (active) 03:53:23,084 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,084 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) 03:53:23,086 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,087 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) └── 17 : subProcessStart (StartEvent, parent id 14 (active) 03:53:23,087 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,087 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) └── 17 : subProcessStart (StartEvent, parent id 14 (active) 03:53:23,087 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,088 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) └── 17 : subProcessStart -&gt; fork, parent id 14 (active) 03:53:23,088 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,088 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) └── 17 : fork (ParallelGateway, parent id 14 (active) 03:53:23,088 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,089 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) └── 17 : fork (ParallelGateway, parent id 14 (not active) 03:53:23,089 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,089 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : fork -&gt; reviewProfitability, parent id 14 (active) └── 20 : fork -&gt; reviewCustomerRating, parent id 14 (active) 03:53:23,089 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,090 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : reviewProfitability (UserTask, parent id 14 (active) └── 20 : fork -&gt; reviewCustomerRating, parent id 14 (active) 03:53:23,090 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,090 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : reviewProfitability (UserTask, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,092 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,092 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 10 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : reviewProfitability (UserTask, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,114 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - ratingTask: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:0,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:null,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Review customer rating&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:null,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sat Dec 08 15:53:23 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;20&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;5&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;reviewSaledLead:1:4&quot;,&quot;taskDefinitionKey&quot;:&quot;reviewCustomerRating&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;25&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 03:53:23,116 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - profitabilityTask: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:0,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:null,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Review profitability&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:&quot;destiny has published a new sales lead: Camery. Details: interesting&quot;,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sat Dec 08 15:53:23 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;17&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;5&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;reviewSaledLead:1:4&quot;,&quot;taskDefinitionKey&quot;:&quot;reviewProfitability&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;22&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 03:53:23,122 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 03:53:23,125 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : reviewProfitability (UserTask, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,126 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,126 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : reviewProfitability (UserTask, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,126 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,127 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : reviewProfitability -&gt; enoughInformationCheck, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,127 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,127 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : enoughInformationCheck (ExclusiveGateway, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,131 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,131 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : enoughInformationCheck -&gt; notEnoughInformationEnd, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,132 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,132 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : enoughInformationCheck -&gt; notEnoughInformationEnd, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,132 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,132 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : notEnoughInformationEnd (EndEvent, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,133 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 03:53:23,134 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 14 (active) ├── 17 : notEnoughInformationEnd (EndEvent, parent id 14 (active) └── 20 : reviewCustomerRating (UserTask, parent id 14 (active) 03:53:23,139 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,139 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 17 : notEnoughInformationEnd (EndEvent, parent id 14 (not active) (ended) └── 20 : reviewCustomerRating (UserTask, parent id 14 (not active) (ended) └── 16 : catchNotEnoughInformationError (BoundaryEvent, parent id 5 (active) 03:53:23,139 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,139 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 17 : notEnoughInformationEnd (EndEvent, parent id 14 (not active) (ended) └── 20 : reviewCustomerRating (UserTask, parent id 14 (not active) (ended) └── 16 : catchNotEnoughInformationError -&gt; provideAdditionalDetails, parent id 5 (active) 03:53:23,139 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,140 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 14 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 17 : notEnoughInformationEnd (EndEvent, parent id 14 (not active) (ended) └── 20 : reviewCustomerRating (UserTask, parent id 14 (not active) (ended) └── 16 : provideAdditionalDetails (UserTask, parent id 5 (active) 03:53:23,150 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - provideDetailsTask: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:1,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:&quot;destiny&quot;,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Provide additional details&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:&quot;Provide additional details for Camery.&quot;,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sat Dec 08 15:53:23 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;16&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;5&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;reviewSaledLead:1:4&quot;,&quot;taskDefinitionKey&quot;:&quot;provideAdditionalDetails&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;32&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 03:53:23,152 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 03:53:23,153 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : provideAdditionalDetails (UserTask, parent id 5 (active) 03:53:23,154 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,154 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : provideAdditionalDetails (UserTask, parent id 5 (active) 03:53:23,155 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,155 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : provideAdditionalDetails -&gt; reviewSalesLeadSubProcess, parent id 5 (active) 03:53:23,155 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,155 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) 03:53:23,156 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,157 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : subProcessStart (StartEvent, parent id 33 (active) 03:53:23,157 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,157 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : subProcessStart (StartEvent, parent id 33 (active) 03:53:23,157 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,158 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : subProcessStart -&gt; fork, parent id 33 (active) 03:53:23,158 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,158 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : fork (ParallelGateway, parent id 33 (active) 03:53:23,159 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,159 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : fork (ParallelGateway, parent id 33 (not active) 03:53:23,159 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,159 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) ├── 36 : fork -&gt; reviewProfitability, parent id 33 (active) └── 39 : fork -&gt; reviewCustomerRating, parent id 33 (active) 03:53:23,159 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,159 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) ├── 36 : reviewProfitability (UserTask, parent id 33 (active) └── 39 : fork -&gt; reviewCustomerRating, parent id 33 (active) 03:53:23,159 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,160 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) ├── 36 : reviewProfitability (UserTask, parent id 33 (active) └── 39 : reviewCustomerRating (UserTask, parent id 33 (active) 03:53:23,161 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,162 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 16 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (ended) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) ├── 36 : reviewProfitability (UserTask, parent id 33 (active) └── 39 : reviewCustomerRating (UserTask, parent id 33 (active) 03:53:23,180 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - reviewTask: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:0,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:null,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Review customer rating&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:null,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sat Dec 08 15:53:23 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;39&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;5&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;reviewSaledLead:1:4&quot;,&quot;taskDefinitionKey&quot;:&quot;reviewCustomerRating&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;44&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 03:53:23,180 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - reviewTask: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:0,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:null,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Review profitability&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:&quot;destiny has published a new sales lead: Camery. Details: interesting&quot;,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Sat Dec 08 15:53:23 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;36&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;5&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;reviewSaledLead:1:4&quot;,&quot;taskDefinitionKey&quot;:&quot;reviewProfitability&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;41&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} 03:53:23,183 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 03:53:23,190 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 39 : reviewCustomerRating (UserTask, parent id 33 (active) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,190 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,190 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 39 : reviewCustomerRating (UserTask, parent id 33 (active) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,191 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,191 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 39 : reviewCustomerRating -&gt; subProcessEnd1, parent id 33 (active) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,191 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,191 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 39 : subProcessEnd1 (EndEvent, parent id 33 (active) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,191 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,192 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 39 : subProcessEnd1 (EndEvent, parent id 33 (active) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,192 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.EndExecutionOperation : 03:53:23,193 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 39 : subProcessEnd1 (EndEvent, parent id 33 (active) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,203 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 03:53:23,204 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,205 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,205 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability (UserTask, parent id 33 (active) 03:53:23,206 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,206 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : reviewProfitability -&gt; enoughInformationCheck, parent id 33 (active) 03:53:23,206 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,206 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : enoughInformationCheck (ExclusiveGateway, parent id 33 (active) 03:53:23,206 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,206 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : enoughInformationCheck -&gt; subProcessEnd2, parent id 33 (active) 03:53:23,207 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,207 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : enoughInformationCheck -&gt; subProcessEnd2, parent id 33 (active) 03:53:23,207 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,207 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (active) 03:53:23,207 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,207 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (active) 03:53:23,208 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.EndExecutionOperation : 03:53:23,208 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) (scope) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (active) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (active) 03:53:23,211 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,211 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (active) 03:53:23,211 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,211 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : reviewSalesLeadSubProcess -&gt; storeLeadInCrmSystem, parent id 5 (active) 03:53:23,211 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : storeLeadInCrmSystem (ManualTask, parent id 5 (active) 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : storeLeadInCrmSystem (ManualTask, parent id 5 (active) 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : storeLeadInCrmSystem -&gt; processEnd, parent id 5 (active) 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : processEnd (EndEvent, parent id 5 (active) 03:53:23,212 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : 03:53:23,213 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : processEnd (EndEvent, parent id 5 (active) 03:53:23,213 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.EndExecutionOperation : 03:53:23,213 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - 5 (process instance) └── 33 : reviewSalesLeadSubProcess (SubProcess, parent id 5 (not active) (scope) (ended) ├── 35 : catchNotEnoughInformationError (BoundaryEvent, parent id 33 (not active) (ended) └── 36 : subProcessEnd2 (EndEvent, parent id 33 (not active) (ended) └── 49 : processEnd (EndEvent, parent id 5 (active) 03:53:23,281 [main] INFO org.activiti.engine.impl.test.AbstractTestCase - database was clean 1.1.3. 信号事件1.1.3.1. 信号开始事件 信号开始事件的启动方式与普通开始事件启动方式很接近, 需要发出对应的信号去启动它 123456&lt;signal id="theSignal" name="The signal"/&gt;&lt;process id="processWithSignalStart1"&gt; &lt;startEvent id="theStart"&gt; &lt;signalEventDefinition id="theSignalEventDefinition" signalRef="theSignal"/&gt; &lt;/startEvent&gt;&lt;/process&gt; 1.1.3.2 信号中间事件123456789101112&lt;signal id="alterSignal" name="alter"/&gt;&lt;process id="catchSignal"&gt; &lt;!-- 信号抛出事件 --&gt; &lt;intermediateThrowEvent id="throwSignalEvent" name="Alter"&gt; &lt;signalEventDefinition signalRef="alterSignal"/&gt; &lt;/intermediateThrowEvent&gt; &lt;!-- 信号捕获事件 --&gt; &lt;intermediateCatchEvent id="throwSignalEvent" name="On Alter"&gt; &lt;signalEventDefinition signalRef="alterSignal"/&gt; &lt;/intermediateCatchEvent&gt;&lt;/process&gt; 1.1.4 消息事件 消息事件的定义和信号事件的定义非常相近 123456789101112&lt;message id="newInvoice" name="newInvoiceMessage"/&gt;&lt;message id="payment" name="paymentMessage"/&gt;&lt;process id="catchSignal"&gt; &lt;startEvent id="messageStart"&gt; &lt;messsageEventDefinition messageRef="newInvoice"/&gt; &lt;/startEvent&gt; &lt;!-- 信号捕获事件 --&gt; &lt;intermediateCatchEvent id="paymentEvt"&gt; &lt;messageEventDefinition messageRef="payment"/&gt; &lt;/intermediateCatchEvent&gt;&lt;/process&gt; 3. 顺序流和和网关顺序流的分类: 顺序流 条件顺序流 默认顺序流 3.1. 网关网关的分类: 排他网关(Exclusive Gateway) 并行网关(Parallel Gateway) 包容网关(Inclusive Gateway), 类似排他网关和并行网关的组合体, 即支持多条路, 有支持表达式 事件网关(Event-based Gateway), 每个分支都有一个捕获事件等待被触发, 一个触发后, 其他都会失效 3.1.1. 排他网关 分支判断只能选一支持默认 流程定义12345678910111213141516&lt;exclusiveGateway id="exclusiveGateway1" name="Exclusive Gateway"/&gt;&lt;userTask id="userTask1" name="精英"/&gt;&lt;userTask id="userTask2" name="优秀"/&gt;&lt;userTask id="userTask3" name="普通"/&gt;&lt;sequenceFlow id="flow2" sourceRef="exclusiveGateway1" targetRef="userTask1"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt; &lt;![CDATA[score &gt;= 90]]&gt; &lt;/conditionExpression&gt;&lt;/sequenceFlow&gt;&lt;sequenceFlow id="flow3" sourceRef="exclusiveGateway1" targetRef="userTask2"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt; &lt;![CDATA[score &gt;= 75 &amp;&amp; score &lt; 90]]&gt; &lt;/conditionExpression&gt;&lt;/sequenceFlow&gt;&lt;!-- 默认数据流 --&gt;&lt;sequenceFlow id="flow4" sourceRef="exclusiveGateway1" targetRef="userTask1"/&gt; 测试代码123456789101112@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-exclusive.bpmn20.xml"&#125;)public void testExclusiveGateway() &#123; Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;(); variables.put("key1", 3); variables.put("score", 91); ProcessInstance processInstance = activitiRule.getRuntimeService().startProcessInstanceByKey("my-process", variables); Task task = activitiRule.getTaskService().createTaskQuery().singleResult(); // org.destiny.activiti.bpmn20.GatewayTest - task.name = 精英 log.info("task.name = &#123;&#125;", task.getName()); assertEquals(task.getName(), "精英");&#125; 3.1.2. 并行网关 让流程从单线程变为并发情况, 原有的一条流转数据变为两条, 可以同时进行确认支付和确认收货, 当这两个条件同时满足时, 继续进行后面的操作 流程并发 分支 合并 忽略条件(即使填了条件也不会生效) 非对称(不要求所有的分支最终都合并在一起) 流程定义12345678910&lt;parallelGateway id="parallelGateway1" name="Parallel Gateway"/&gt;&lt;userTask id="userTask1" name="确认支付"/&gt;&lt;userTask id="userTask2" name="确认收货"/&gt;&lt;sequenceFlow id="flow3" sourceRef="parallelGateway1" targetRef="userTask1"/&gt;&lt;sequenceFlow id="flow4" sourceRef="parallelGateway1" targetRef="userTask2"/&gt;&lt;parallelGateway id="parallelGateway2" name="parallelGateway"/&gt;&lt;sequenceFlow id="flow8" sourceRef="userTask1" targetRef="parallelGateway2"/&gt;&lt;sequenceFlow id="flow9" sourceRef="userTask2" targetRef="parallelGateway2"/&gt;&lt;userTask id="userTask3" name="订单完成"/&gt;&lt;sequenceFlow id="flow10" sourceRef="parallelGateway2" targetRef="userTask3"/&gt; 测试代码12345678910111213141516171819202122232425@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-parallel.bpmn20.xml"&#125;)public void testParallelGateway() &#123; activitiRule.getRuntimeService().startProcessInstanceByKey("my-process"); List&lt;Task&gt; taskList = activitiRule.getTaskService().createTaskQuery().list(); log.info("过并行网关时的 task 数量: &#123;&#125;", taskList.size()); for (Task task : taskList) &#123; log.info("task name: &#123;&#125;", task.getName()); &#125; assertEquals(2, taskList.size()); activitiRule.getTaskService().complete(taskList.get(0).getId()); List&lt;Task&gt; taskList1 = activitiRule.getTaskService().createTaskQuery().list(); log.info("提交第 1 个任务时的 task 数量: [&#123;&#125;]", taskList1.size()); for (Task task : taskList1) &#123; log.info("task name: &#123;&#125;", task.getName()); &#125; assertEquals(1, taskList1.size()); activitiRule.getTaskService().complete(taskList.get(1).getId()); List&lt;Task&gt; taskList2 = activitiRule.getTaskService().createTaskQuery().list(); log.info("提交第 2 个任务时的 task 数量: [&#123;&#125;]", taskList2.size()); for (Task task : taskList2) &#123; log.info("task name: &#123;&#125;", task.getName()); &#125; assertEquals(1, taskList1.size());&#125; 日志输出06:17:51,705 [main] INFO org.destiny.activiti.bpmn20.GatewayTest - 过并行网关时的 task 数量: 2 06:17:51,705 [main] INFO org.destiny.activiti.bpmn20.GatewayTest - task name: 确认支付 06:17:51,706 [main] INFO org.destiny.activiti.bpmn20.GatewayTest - task name: 确认收货 06:17:51,710 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 06:17:51,721 [main] INFO org.destiny.activiti.bpmn20.GatewayTest - 提交第 1 个任务时的 task 数量: [1] 06:17:51,721 [main] INFO org.destiny.activiti.bpmn20.GatewayTest - task name: 确认收货 06:17:51,724 [main] INFO org.activiti.engine.impl.interceptor.DebugCommandInvoker - Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : 06:17:51,738 [main] INFO org.destiny.activiti.bpmn20.GatewayTest - 提交第 2 个任务时的 task 数量: [1] 06:17:51,738 [main] INFO org.destiny.activiti.bpmn20.GatewayTest - task name: 订单完成 3.1.3. 包容性网关 可以理解为排他网关和并行网关的结合体 排他网关有条件, 只能选择一条路径 并行网关不带条件, 所有路径都会执行 包容性网关有条件, 且支持并行运行 并发 分支 合并 条件 非对称 事件网关 会根据连接的捕获时间决定流程的走向, 只能走一条线路 流程暂停 事件订阅 捕获事件 单一执行]]></content>
      <categories>
        <category>Activiti</category>
        <category>工作流</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti6.0用户指引中文版]]></title>
    <url>%2Fblog%2F2018%2F12%2F05%2FActiviti6-0%E7%94%A8%E6%88%B7%E6%8C%87%E5%BC%95%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[1. 引导1.1. License 许可Activiti 是在 Apache V2 license 许可下发布的. 1.2. 下载http://activiti.org/download.html 1.3. 源代码该发行版以 jar 文件的形式包含了大多数源代码, Activiti 的源代码可以在 https://github.com/Activiti/Activiti 找到. 1.4. Required software 必需的软件1.4.1. JDK 7+Activiti 需要 JDK 版本高于或等于 7, 前往 Oracle Java SE downloads 进行下载. 在该页面上有相关的下载说明, 可以通过在命令行运行 java -version 命令来验证安装是否成功. 该命令会打印出安装的 JDK 版本. 1.4.2. IDE2. Getting Started 启动2.1. One minute version 一分钟版在从 Activiti website 下载了 Activiti UI 的 WAR 包之后, 按照这些步骤去以默认配置运行样例. 你需要安装 Java runtime 和 Apache Tomcat(实际上, 任意一个 web 容器都可以正常运行, 因为我们只依赖与 Servlet 的能力, 但我们主要在 Tomcat 上进行测试) 将下载的 activiti-app.war 文件复制到 Tomcat 的 webapps 路径下 通过 bin 路径下的 startup.sh 或 startop.bat 启动 Tomcat 当 Tomcat 启动后, 打开浏览器并前往 http://localhost:8080/activiti-app, 使用账号 admin, 密码 test 登录 这样就可以了, ActivitiUI 应用默认使用基于内存的 H2 数据库 2.2 Activiti setup Activiti 的安装要安装 Activiti, 需要安装 Java runtime 和 Apache Tomcat, 并且确认系统变量 JAVA_HOME 已经正确的设置, 具体设置的方式取决于你的操作系统. 只需要将 war 文件从 Activiti 下载页面下载到 Tomcat 安装路径下的 webapps 路径就可以让 Activiti UI 和 REST 应用启动. 默认情况下 UI 应用使用内存数据库运行. 示例用户: userId Password Security roles admin test admin 现在可以访问的应用: Webapp Name URL Description Activiti UI http://localhost:8080/activiti-app 流程引擎用户控制台, 通过该工具可以开启新的流程, 分配任务, 查看和认领任务等 需要注意的是, Activiti UI 项目实例的启动只是一个简单快速演示功能的方式, 并不是说只能使用这种方式使用 Activiti. Activiti 只是一个 jar 文件, 可以嵌入到任何 Java 环境中, 比如 swing, Tomcat, JBoss, WebSphere 等. 或者也可以选择将Activiti作为一个典型的独立BPM服务器来运行, 只要能在 Java 中完成的, 就能使用 Activiti. 2.3. Activiti database setup 数据库安装如同在一分钟版示例说的, Activiti UI 应用默认使用内存数据库 H2. 要让 Activiti UI 应用使用独立的 H2 或者其他的数据库, 可以修改 WEB-INF/classes/META-INF/activiti-app 路径下的 activiti-app.properties 文件 2.4 Include the Activiti jar and its denpendices 包含 jar 及其依赖为了包含 Activiti jar 和它的依赖库, 我们决定使用 maven, 因为它简化了我们双方的依赖管理. 根据引导 http://www.activiti.org/community.html#maven.repository 来引入必要的依赖. 作为选择, 如果你不想使用 maven, 可以直接在项目中引入 jar 文件. Activiti 下载的压缩包包含一个文件夹 libs, 其中包含了所有 Activiti jar 文件(以及源代码 jar). 依赖不是通过这种方式提供的, Activiti 必须的依赖如下所示(使用 mvn dependency:tree 生成): org.activiti:activiti-engine:jar:6.x +- org.activiti:activiti-bpmn-converter:jar:6.x:compile | \- org.activiti:activiti-bpmn-model:jar:6.x:compile | +- com.fasterxml.jackson.core:jackson-core:jar:2.2.3:compile | \- com.fasterxml.jackson.core:jackson-databind:jar:2.2.3:compile | \- com.fasterxml.jackson.core:jackson-annotations:jar:2.2.3:compile +- org.activiti:activiti-process-validation:jar:6.x:compile +- org.activiti:activiti-image-generator:jar:6.x:compile +- org.apache.commons:commons-email:jar:1.2:compile | +- javax.mail:mail:jar:1.4.1:compile | \- javax.activation:activation:jar:1.1:compile +- org.apache.commons:commons-lang3:jar:3.3.2:compile +- org.mybatis:mybatis:jar:3.3.0:compile +- org.springframework:spring-beans:jar:4.1.6.RELEASE:compile | \- org.springframework:spring-core:jar:4.1.6.RELEASE:compile +- joda-time:joda-time:jar:2.6:compile +- org.slf4j:slf4j-api:jar:1.7.6:compile +- org.slf4j:jcl-over-slf4j:jar:1.7.6:compile 注意, 如果需要使用 mail service task 才需要引入 mail 依赖 jar. 所有的依赖可以很轻松的通过使用 mvn denpendency:cpoy-dependencies 在 activiti源代码 上下载. 2.5. Next steps 下一步3. Configuration 配置3.1. Creating a ProcessEngine 创建一个流程引擎Activiti 流程引擎通过 XML 文件 activiti.cfg.xml 配置, 需要注意的是不适用于 Spring 风格下的流程引擎创建. 获取 流程引擎 最简单的方式是使用 org.activiti.engine.ProcessEngines 类: 1ProcessEngine processEngine = ProcessEngines.getDefauleProcesEngine(); 这样的方式会在 classpath 上寻找 activiti.cfg.xml 文件, 并且基于文件中的配置去构造引擎. 下面的片段展示了一个配置文件的样例, 后面的章节会给出配置参数的详细介绍. 1234567891011121314151617181920&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="jdbcUrl" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" /&gt; &lt;property name="jdbcDriver" value="org.h2.Driver" /&gt; &lt;property name="jdbcUsername" value="sa" /&gt; &lt;property name="jdbcPassword" value="" /&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;property name="asyncExecutorActivate" value="false" /&gt; &lt;property name="mailServerHost" value="mail.my-corp.com" /&gt; &lt;property name="mailServerPort" value="5025" /&gt; &lt;/bean&gt;&lt;/beans&gt; 值得注意的是, 这个 XML 配置文件实际上是一个 Spring 配置文件. 这并不意味着 Activiti 只能运行在 Spring 环境中. 我们仅仅是在内部利用 Spring 解析和依赖注入的能力来构建引擎. ProcessEngineConfiguration 对象也可以被配置文件编程式的创建, 也可以用一个不同 bean id. 12345678910// 基于默认配置文件 activiti.cfg.xmlProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault();// 指定路径ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource);// 指定路径和提取的 bean idProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName);// 指定输入流ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream);// 指定输入流和 bean idProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName); 与此同时, 也可以不使用配置文件, 直接通过默认创建配置(参考不同的支持类) 12ProcessEngineConfiguraion.createStandaloneProcessEngineConfiguration();ProcessEngineConfiguraion.createStandaloneInMemProcessEngineConfiguration(); 所有这些 ProcessEngineConfiguraion.createXXX() 方法返回一个后续可调整的 ProcessEngineConfiguraion 方便链式调用, 在调用 buildProcessEngine() 操作后, 就会创建一个 ProcessEngine 12345ProcessEngine processEngine = ProcessEngineConfiguraion.createStandaloneInMemProcessEngineConfiguration() .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE) .setJdbcUrl("jdbc:h2:mem:my-own-db;DB_CLOSE_DELAY=1000") .setAsyncExcutorActivate(false) .buildProcessEngine(); 3.2. ProcessEngineConfiguration beanactiviti.cfg.xml 必须包含一个 id 为 processEngineConfiguraion 的 bean 123&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;!-- ... --&gt;&lt;/bean&gt; 这个 bean 会用来构建 ProceeEngine, 有多个类可以用来定义 processEngineConfiguration, 这些类代表了不同的环境, 并且设置了对应的默认值. 最佳的实践是选择与你当前环境最符合的类, 这样可以少配置几个引擎的参数, 下面是当前可用的类: org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration: 这个 ProcessEngine 单独运行, Activiti 会自己处理事务, 默认情况下, 数据库只会在引擎启动的时候检查(并且如果没有 Activiti 的表或者表的版本不正确时会抛出异常); org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration: 这是一个方便的单元测试类, Activiti 会自己控制事务, 默认使用一个基于内存的 H2 数据库, 数据库分别会在启动和关闭的时候创建以及销毁, 当使用它的时候, 或许不需要额外的配置(除了使用 job 执行器或者邮件功能以外); org.activiti.spring.SpringProcessEngineConfiguration: 在 Spring 环境下使用流程引擎, 参考 Spring 集成; org.activiti.engine.impl.cfg.JtaProcessEngineConfiguration: 单独运行的流程引擎, 并使用 JTA 事务. 3.3. Database Configuration 数据库配置有两种方式配置数据库给 Activiti 引擎使用, 第一种方式是定义 JDBC 的数据库配置文件 jdbcUrl: 数据库连接 jdbcDriver: 驱动类 jdbcUsername: 数据库用户名 jdbcPassword: 数据库用户密码 基于 JDBC 配置文件构造出的数据源将默认使用 MyBatis 连接池, 下面的配置可以用来构造连接池: jdbcMaxActiveConnections: 任意时间数据库连接池中的最大连接数, 默认为 10; jdbcMaxIdleConnections: 连接池中处于空闲状态的连接的最大值; jdbcMaxCheckoutTime: 连接被取出使用的最长时间, 超过时间会被强制回收. 默认为20000(20 秒); jdbcMaxWaitTime: 这是一个底层配置, 当获得的时间较长时, 给连接池一个打印日志并重新尝试获得连接的机会, 默认为20000(20 秒). 数据库连接池默认配置: 1234&lt;property name="jdbcUrl" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" /&gt;&lt;property name="jdbcDriver" value="org.h2.Driver" /&gt;&lt;property name="jdbcUsername" value="sa" /&gt;&lt;property name="jdbcPassword" value="" /&gt; 我们的基准表明, MyBatis 连接池在大量并发请求下并不是最有效率的, 因此, 建议使用 javax.sql.DataSource 的实现 并且注入到 ProcessEngine 配置中(比如 DBCP, C3P0, Hikari, Tomcat Connection Pool等): 123456789101112&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" &gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/activiti" /&gt; &lt;property name="username" value="activiti" /&gt; &lt;property name="password" value="activiti" /&gt; &lt;property name="defaultAutoCommit" value="false" /&gt;&lt;/bean&gt;&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; ... 注意, Activiti 并没有包含这些数据源, 因此你必须确保这些类库在你的类路径下. 不管是采用 JDBC 还是 DataSource 的方式, 下面的配置可以被设置: databaseType: 通常是不需要去单独制定这项配置, 因为会被数据库连接的元数据自动分析出来, 只有当自动制定失败的时候才需要被设置. 可能的值有 {h2, mysql, oracle, postgres, mssql, db2}. 这项配置会决定哪些创建/删除脚本和查询语句会被使用. 参考 支持数据库章节 了解支持哪些类型. databaseSchemaUpdate: 允许设置的策略去决定数据库表在流程启动和结束的时候被如何处理: false(默认): 当 ProcessEngine 启动的时候, 检查数据库表的版本是否匹配依赖库的版本, 并在不匹配的时候抛出异常; true: 在 ProcessEngine 构建时, 执行检查, 如果有需要就执行更新, 如果数据库表不存在, 就重新创建; create-drop: 在 ProcessEngine 启动的时候创建数据库表, 并且在 ProcessEngine 关闭的时候删除数据库表. 4. The Activiti API Activiti API4.1. The Process Engine API ans Service ProcessEngine 的 API 和服务引擎的相关 API 是与 Activiti 交互最多的方式, 最重要的开始点就是 ProcessEngine, 它可以被多种在 配置部分 描述的方式创建, 你可以获得多种包含 工作流/BPM 方法的服务. ProcessEngine 和服务对象都是线程安全的, 因此可以在整个应用中维护一个实例. 12345678910ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();Engine.getRuntimeService();RepositoryService repositoryService = processEngine.getRepositoryService();TaskService taskService = processEngine.getTaskService();ManagementService managementService = processEngine.getManagementService();IdentityService identityService = processEngine.getIdentityService();HistoryService historyService = processEngine.getHistoryService();FormService formService = processEngine.getFormService();DynamicBpmnService dynamicBpmnService = processEngine.getDynamicBpmnService(); ProcessEngines.getDefaultProcessEngine() 会在第一次调用时初始化并构建一个 ProcessEngine, 并且后面始终返回相同的实例. 对应的可以创建和关闭所有 ProcessEngine: ProcessEngine.init() 和 ProcessEngine.destroy() ProcessEngine 类会扫描所有的 activiti.cfg.xml 和 activiti-context.xml 文件, 对于 activtivi.cfg.xml 文件, 流程引擎会使用专有的方式构建: ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()]]></content>
      <categories>
        <category>Activiti</category>
        <category>工作流</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti工作流引擎]]></title>
    <url>%2Fblog%2F2018%2F11%2F26%2FActiviti%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[前段时间入职字节跳动, 目前负责 Lark 工作流审批功能的开发, 选用工作流引擎 Activiti 进行开发, 因此在此记录下对 Activiti 的学习过程. 概念 工作流引擎是用来驱动业务, 按照流程图次逐步流转的核心框架, 在复杂多变的场景下采用工作流引擎可以大大降低业务部署成本. 通过标准的业务流程模型作为业务与开发工作的桥梁, 有效减少业务团队与技术交流的障碍. 工作流引擎最早用于企业 OA, CRM, 流程审批等系统的流程审批.现在的工作流引擎已经大量运用到互联网电商, 金融出行, 中台支撑等. 工作流引擎在互联网公司快速盛行, 掌握工作流引擎技术可以提升技术架构和业务建模能力. 目录: 工作流入门 Activiti 6.0 源码浅析 Activiti 6.0 引擎配置 Activiti 6.0 核心 API 数据设计与模型映射 BPMN 2.0 规范 集成 SpringBoot 2.0 搭建工作流平台 1. 工作流入门1.1 工作流介绍1.1.1 出差流程审批业务场景: 审批流程模型化: 从一个开始节点, 经过多个任务节点和分支节点, 最终流向结束节点. 1.1.2 电商购物流程 抽象成泳道图: 节点 抽象名称 功能 电商购物流程 泳池(Pool) 用户/电商平台/仓储物流 泳道(Line) 校验库存 服务任务(Service Task) 不需要人工参与, 需要系统自动化完成的操作节点 1.1.3 工作流是什么 工作流:是对工作流程以及各个步骤之间的业务规则的抽象, 概括描述. 工作流建模:将工作流程中的工作如何前后组织在一起的逻辑和规则, 在计算机中以恰当的模型表达并对其实施计算. 要解决的问题:为实现某个业务目标, 利用计算机在多个参与者之间按某种预定规则自动传递文档, 信息或任务. 关键词 概念 工作流管理系统 处理工作流的电脑软件系统, 主要功能是通过计算机技术的支持去定义, 执行和管理工作流, 协调工作流执行过程中工作之间以及群体之间的信息交互 计算机支持的协同工作 研究一个群体如何在计算机的帮助下实现协同工作的, 工作流属于计算机支持的协同工作的一部分 工作流管理联盟 工作流技术标准化的工业组织, 发布了用于工作流管理系统之间互操作的工作流参考模型, 并相继制定了一些列工业标准 1.1.4 为什么需要工作流日常开发中经常遇到的问题: 产品需求遗漏, 开发上线之后需求经常改; 业务代码复杂, 开发时间紧迫; 代码后期维护不足, 逐渐难以维护. 使用工作流能够带来的改变: 可以快速响应, 灵活调整线上产品流程; 业务和开发基于流程模型沟通, 基于业务建模快速部署; 流程可视化, 方便查看流程的运行进展. 使用工作流对团队的作用: 提高效率, 减少等待; 规范行为, 落实制度; 协同内外, 快速响应; 监控全面, 提升执行. 1.2 工作流技术选型 二者都是成熟的工作流框架 jBPM Activiti Hibernate ByBatis Drools Flow JBPM4 JPA Spring Message RESTful 1.3 Activiti6.0 快速体验1.3.1 准备物料 Activiti 软件包: activiti-6.0.0.zip JDK Servlet 容器 (如 Tomcat) 安装 sdkman12345curl -s "https://get.sdkman.io" | bashsource "$HOME/.sdkman/bin/sdkman-init.sh"sdk version 安装 JDK12345sdk install java 8u161-oraclejava -versionecho $JAVA_HOME 安装 Tomcat1234567wget http://mirror.bit.edu.cn/apache/tomcat/tomcat/8/v8.0.50/bin/apache-tomcat-8.0.50.ziptar -zxvf apache-tomcat-8.0.50.zip./apache-tomcat-8.0.50/bin/startup.shjdp-mlv 部署 Activiti123456wget https://github.com/Activiti/Activiti/releases/download/activiti-6.0.0/activiti-6.0.0.ziptar -zxvf activiti-6.0.0.zipcp activiti-6.0.0/wars/activiti-app.war apache-tomcat-8.0.50/webappscp activiti-6.0.0/wars/activiti-admin.war apache-tomcat-8.0.50/webapps 此时打开浏览器, 输入 http://localhost:8080/activiti-app 即可进入流程引擎的登录界面 账号: admin 密码: test 1.3.2 设计一个审批流程设计如下流程: 开始 -&gt; TL 审批 -&gt; HR 审批 -&gt; 结束 流程参与者 ID Email Name admin admin Administrator userdev userdev@126.com userdevDEV userhr userhr@126.com userhrHR usertl usertl@126.com usertlTL 2. 源码概述12345git clone git@github.com:DestinyWang/Activiti.gitgit checkout -b study6 activiti-6.0.0mvn clean test-compile 路径 功能 Activiti/activiti-engine/src/main/java/org/activiti/engine/cfg Activiti 的启动依赖 activiti.cfg.xml, 在该目录完成 Activiti/activiti-engine/src/main/java/org/activiti/engine/compatibility Activiti 从 5 升级到 6 的时候有部分不兼容, 在该目录完成适配 Activiti/activiti-engine/src/main/java/org/activiti/engine/debug 调试相关目录 Activiti/activiti-engine/src/main/java/org/activiti/engine/delegate 需要制定的节点 Task 都需要实现 JavaDelegate Activiti/activiti-engine/src/main/java/org/activiti/engine/event 定义了事件和监听机制 Activiti/activiti-engine/src/main/java/org/activiti/engine/form 通用表单 Activiti/activiti-engine/src/main/java/org/activiti/engine/history 历史数据归档 Activiti/activiti-engine/src/main/java/org/activiti/engine/identity 身份认证相关操作 Activiti/activiti-engine/src/main/java/org/activiti/engine/impl 各个接口层的实现 Activiti/activiti-engine/src/main/java/org/activiti/engine/logging LogMDC 将重要的变量(如流程 id 放在上下文, logback 可以打印出来) Activiti/activiti-engine/src/main/java/org/activiti/engine/management 管理相关 Activiti/activiti-engine/src/main/java/org/activiti/engine/parse 流程文件是 xml, 需要解析和验证 Activiti/activiti-engine/src/main/java/org/activiti/engine/query 抽象了一些查询接口, 基于 mybatis Activiti/activiti-engine/src/main/java/org/activiti/engine/repository 抽象流程部署到数据库的过程 Activiti/activiti-engine/src/main/java/org/activiti/engine/runtime 与 history 相对应, 是流程在流转过程中的数据 Activiti/activiti-engine/src/main/java/org/activiti/engine/task 每个流程在需要人工处理的时候都会对应一个 task Activiti/activiti-engine/src/main/java/org/activiti/engine/test 支持集成测试的帮助类 核心模块: module/activiti-engine: 核心引擎 module/activiti-spring: Spring 集成模块 module/activiti-spring-boot: SpringBoot 集成模块 module/activiti-rest: 对外提供 rest api 模块 module/activiti-form-engine: 表单引擎模块 module/activiti-ldap: 集成 ldap 用户模块 Activiti-engine 依赖的模块: bpmn-converter: 模型转换 process-validation: 流程校验 image-generator: 流程图绘制(BPMN 转 PNG) dmn-api: 决策标准 form-api/form-model: form 表单相关 2.1 基于源码运行 activiti-app2.1.1 启动 activiti-app12345cd modules/activiti-ui/activiti-appmvn clean tomcat7:runopen http://localhost:9999/activi-app 2.2 剖析 activiti-appactiviti-ui 的组成: activiti-app: 集成发布的 war 工程 activiti-app-conf: UI 独立域业务外的配置 activiti-app-logic: UI 的业务逻辑 activiti-app-rest: 提供接口的 rest api 3. HelloWorld 填写审批信息: 姓名, 时间, 是否提交 主管审批: 审批结果, 备注 审批结果, 备注 3.1 在 IDEA 中完成流程图的设计并配置 配置点: 节点 id, 名称; 对每个网关的分支做判断(基于填写信息); Task 节点接收的表单信息. 3.1.2 Task 节点接收的表单信息填写申请信息 Id Name Type Expression Variable Default Date Pattern Readable Writable Required Values message 申请信息 string True name 申请人姓名 string True submitTime 提交时间 date yyyy-MM-dd True submitType 确认申请 string True 主管审批 Id Name Type Expression Variable Default Date Pattern Readable Writable Required Values tlApprove 主管审批结果 string false tlMessage 主管审批备注 string true 人事审批 Id Name Type Expression Variable Default Date Pattern Readable Writable Required Values hrApprove 人事审批结果 string true hrMessage 人事审批备注 string true 3.1.3 排他网关配置 排他网关需要对流入网关的某个值做判断, 从而决定流程后续的流向 flow3 配置${submitType==&quot;Y&quot; || submitType==&quot;y&quot;} flow4 配置${submitType==&quot;N&quot; || submitType==&quot;n&quot;} flow6 配置${tlApprove == &quot;Y&quot; || tlApprove == &quot;y&quot;} flow7 配置${tlApprove == &quot;N&quot; || tlApprove == &quot;n&quot;} flow9 配置${hrApprove == &quot;Y&quot; || tlApprove == &quot;y&quot;} flow10 配置${hrApprove == &quot;N&quot; || tlApprove == &quot;n&quot;} 配置后的流程图 3.2 helloworld程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class DemoMain &#123; private static final Logger logger = LoggerFactory.getLogger(DemoMain.class); public static void main(String[] args) throws ParseException &#123; logger.info("----- 启动我们的程序 -----"); // 1. 创建流程引擎 ProcessEngine processEngine = getProcessEngine(); // 2. 部署流程定义文件 ProcessDefinition processDefinition = getProcessDefinition(processEngine); // 3. 启动运行流程 ProcessInstance processInstance = getProcessInstance(processEngine, processDefinition); // 4. 处理流程任务 processTask(processEngine, processInstance); logger.info("----- 结束我们的程序 -----"); &#125; /** * 处理流程任务 * * @param processEngine 流程引擎 * @param processInstance 流程实例 * @throws ParseException */ private static void processTask(ProcessEngine processEngine, ProcessInstance processInstance) throws ParseException &#123; Scanner scanner = new Scanner(System.in); while (processInstance != null &amp;&amp; !processInstance.isEnded()) &#123; logger.info("processInstanceId: [&#123;&#125;]", processInstance.getId()); logger.info("processInstance.processInstanceId: [&#123;&#125;]", processInstance.getProcessInstanceId()); TaskService taskService = processEngine.getTaskService(); List&lt;Task&gt; list = taskService.createTaskQuery().list(); logger.info("待处理任务数量: [&#123;&#125;]", list.size()); for (Task task : list) &#123; logger.info("待处理任务: [&#123;&#125;]", task.getName()); Map&lt;String, Object&gt; variables = getVariables(processEngine, scanner, task); taskService.complete(task.getId(), variables); processInstance = processEngine.getRuntimeService() .createProcessInstanceQuery() .processInstanceId(processInstance.getId()) .singleResult(); logger.info("当前 ProcessInstance :&#123;&#125;", processInstance); &#125; &#125; scanner.close(); &#125; /** * 获取变量 * * @param processEngine * @param scanner * @param task * @return * @throws ParseException */ private static Map&lt;String, Object&gt; getVariables(ProcessEngine processEngine, Scanner scanner, Task task) throws ParseException &#123; FormService formService = processEngine.getFormService(); TaskFormData taskFormData = formService.getTaskFormData(task.getId()); List&lt;FormProperty&gt; formProperties = taskFormData.getFormProperties(); Map&lt;String, Object&gt; variables = Maps.newHashMap(); for (FormProperty property : formProperties) &#123; String line = null; if (StringFormType.class.isInstance(property.getType())) &#123; // 如果是 String 类型, 不需要做任何格式化 logger.info("请输入 [&#123;&#125;] ?", property.getName()); line = scanner.nextLine(); variables.put(property.getId(), line); &#125; else if (DateFormType.class.isInstance(property.getType())) &#123; // 如果是日期类型 logger.info("请输入 [&#123;&#125;] ?, 格式 (yyyy-MM-dd)", property.getName()); line = scanner.nextLine(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); Date date = simpleDateFormat.parse(line); variables.put(property.getId(), date); &#125; else &#123; logger.info("类型不支持: &#123;&#125;", property.getType()); &#125; logger.info("您输入的内容是 [&#123;&#125;]", line); &#125; return variables; &#125; private static ProcessInstance getProcessInstance(ProcessEngine processEngine, ProcessDefinition processDefinition) &#123; RuntimeService runtimeService = processEngine.getRuntimeService(); ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinition.getId()); logger.info("启动流程: [&#123;&#125;]", processInstance.getProcessDefinitionKey()); return processInstance; &#125; private static ProcessDefinition getProcessDefinition(ProcessEngine processEngine) &#123; RepositoryService repositoryService = processEngine.getRepositoryService(); DeploymentBuilder deploymentBuilder = repositoryService.createDeployment(); deploymentBuilder.addClasspathResource("SecondApprove.bpmn20.xml"); Deployment deployment = deploymentBuilder.deploy(); String deploymentId = deployment.getId(); // deploymentId: 1 logger.info("deploymentId: [&#123;&#125;]", deploymentId); ProcessDefinition processDefinition = repositoryService. createProcessDefinitionQuery(). deploymentId(deploymentId) .singleResult(); // processDefinition.getId() 是 SecondApprove:1:4, 根据部署 id 和流程 id 组装出的数据 logger.info("流程定义文件: [&#123;&#125;], 流程 id: [&#123;&#125;]", processDefinition.getName(), processDefinition.getId()); return processDefinition; &#125; private static ProcessEngine getProcessEngine() &#123; ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration(); ProcessEngine processEngine = configuration.buildProcessEngine(); String name = processEngine.getName(); String version = ProcessEngine.VERSION; logger.info("流程引擎名称: [&#123;&#125;], 版本: [&#123;&#125;]", name, version); return processEngine; &#125;&#125; 4. Activiti 引擎配置4.1 流程引擎配置流程引擎配置的载体就是 ProcessEngineConfiguration 及其子类, Activiti 是通过 activiti.cfg.xml 来完成配置 然后构建出流程引擎 ProcessEngine, 最终获取业务开发中需要的各个 Service. ProcessorEngineConfiguration: 查找并解析 XML 配置文件 activiti.cfg.xml 提供多个静态方法创建配置对象 实现几个基于不同场景的子类, 配置方式灵活 123456789101112131415161718&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 ProcessEngineConfiguration --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;!-- 配置数据库连接 --&gt; &lt;property name="jdbcDriver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/activitiDB?createDatabaseIfNotExist=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8"/&gt; &lt;property name="jdbcUsername" value="root"/&gt; &lt;property name="jdbcPassword" value="root"/&gt; &lt;!-- false: 不会自动创建表, 没有表, 则抛异常 --&gt; &lt;!-- create-drop: 先删除, 再创建表 --&gt; &lt;!-- true: 没有表时，自动创建--&gt; &lt;property name="databaseSchemaUpdate" value="true"/&gt; &lt;/bean&gt;&lt;/beans&gt; ProcessEngineConfigurationImpl: 抽象类, 配置了 ProcessEngineConfiguration 大部分属性;StandaloneProcessEngineConfiguration: 独立部署运行, 可以通过 new 的方式创建;SpringProcessEngineConfiguration: 完成与 Spring 的集成, 同时扩展了数据源配置, 事务, 自动装载部署文件的目录. 4.2 数据库配置 缺省配置默认使用 H2 内存数据库; 配置 JDBC 属性, 使用 MyBatis 提供的连接池; 配置 DataSource, 可自选第三方实现. 配置 JDBC 属性使用 MyBatis 提供的连接池 基本属性 连接池配置 jdbcUrl jdbcMaxActiveConnections(最大活跃连接数) jdbcDriver jdbcMaxIdleConnections(最大空闲连接数) jdbcUsername jdbcMaxCheckoutTime(最大) jdbcPassword jdbcMaxWaitTIme(最大等待时间) 配置第三方实现的 DataSource Druid: 为监控而生的数据库连接池 Dbcp: Tomcat 自带 HikariCP: 极速数据源连接池, Spring 默认 4.2.1 Druid 数据源连接池123456789101112131415161718&lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration"&gt; &lt;!-- 配置数据库连接 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- false: 不会自动创建表, 没有表, 则抛异常 --&gt; &lt;!-- create-drop: 先删除, 再创建表 --&gt; &lt;!-- true: 没有表时，自动创建--&gt; &lt;property name="databaseSchemaUpdate" value="true"/&gt;&lt;/bean&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/activitiDB"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;property name="initialSize" value="1"/&gt; &lt;property name="maxActive" value="20"/&gt; &lt;property name="filters" value="stat,slf4f"/&gt;&lt;/bean&gt; 4.2.2 数据库更新策略 配置 databaseSchemaUpdate: false: 启动时检查数据库版本, 发生不匹配则抛出异常(线上默认) true: 启动时自动检查并更新数据库表, 不存在会创建(开发环境默认) create-drop: 启动时创建数据库表结构, 结束时删除表结构 4.3 日志和数据记录配置4.3.1 日志组件的关系及 MDC 日志分类 描述 分类内容 日志门面 直接应用在程序中记录日志的组件 slf4j, commons-logging, log4j 日志实现 日志门面不能直接打日志, 需要日志实现 logback, log4j, log4j2, Java util logging 桥接方式 有些特殊需求, 例如需要 slf4j 作为门面, 但需要以 log4j 作为实现 slf4j-log4j12, slf4j-jdk14, … 改变依赖 将原有门面的功能委托给其他实现, 主要用于解决历史软件内部依赖的改变 jcl-over-slf4j, log4j-over-slf4j, … 配置开启 MDC(Mapped Diagnostic Context): 可以理解为将上下文数据存储在 ThreadLocal 中 默认没有开启, 需要手动设置 LogMDC.setMDCEnable(true) 配置 logback.xml, 日志模板添加 %X{mdcProcessInstanceID}, 即打印当前 instance 的 id 流程只有在执行过程出现异常的时候才会记录 MDC 信息 4.3.1.1 默认日志输出测试类123456789101112131415161718public class ConfigMDCTest &#123; /** * 自动构建 ProcessEngine */ @Rule public ActivitiRule activitiRule = new ActivitiRule(); @Test @Deployment(resources = &#123;"my-process.bpmn20.xml"&#125;) public void test() &#123; ProcessInstance processInstance = activitiRule.getRuntimeService().startProcessInstanceByKey("my-process"); assertNotNull(processInstance); Task task = activitiRule.getTaskService().createTaskQuery().singleResult(); assertEquals("Activiti is awesome!", task.getName()); activitiRule.getTaskService().complete(task.getId()); &#125;&#125; logback.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration debug="false" scan="true" scanPeriod="30 seconds"&gt; &lt;property name="log.dir" value="target/logs"/&gt; &lt;property name="encoding" value="UTF-8"/&gt; &lt;property name="plain" value="%msg%n"/&gt; &lt;property name="std" value="%d&#123;HH:mm:ss.SSS&#125; [%thread] [%level] %msg %X&#123;user&#125; %logger&#123;10&#125;.%M:%L%n"/&gt; &lt;property name="normal" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;10&#125;.%M:%L - %msg%n"/&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;std&#125;&lt;/pattern&gt; &lt;charset&gt;$&#123;encoding&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; ... &lt;root&gt; &lt;appender-ref ref="stdout"/&gt; &lt;appender-ref ref="file"/&gt; &lt;/root&gt;&lt;/configuration&gt; 日志输出00:19:43.624 [main] [INFO] Loading XML bean definitions from class path resource [activiti.cfg.xml] o.s.b.f.x.XmlBeanDefinitionReader.loadBeanDefinitions:316 00:19:45.162 [main] [INFO] Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. o.a.e.c.DefaultActiviti5CompatibilityHandlerFactory.createActiviti5CompatibilityHandler:38 00:19:45.174 [main] [INFO] performing create on engine with resource org/activiti/db/create/activiti.mysql.create.engine.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:19:45.176 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:19:46.466 [main] [INFO] performing create on history with resource org/activiti/db/create/activiti.mysql.create.history.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:19:46.466 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:19:46.922 [main] [INFO] performing create on identity with resource org/activiti/db/create/activiti.mysql.create.identity.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:19:46.922 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:19:47.035 [main] [INFO] ProcessEngine default created o.a.e.i.ProcessEngineImpl.&lt;init&gt;:87 4.3.1.2 MDC 日志输出测试类1234567891011121314151617public class ConfigMDCTest &#123; @Rule public ActivitiRule activitiRule = new ActivitiRule(); @Test @Deployment(resources = &#123;"my-process.bpmn20.xml"&#125;) public void test() &#123; // 开启 MDC, 整个过程在正常情况下是不会激活 MDC 的 LogMDC.setMDCEnabled(true); ProcessInstance processInstance = activitiRule.getRuntimeService().startProcessInstanceByKey("my-process"); assertNotNull(processInstance); Task task = activitiRule.getTaskService().createTaskQuery().singleResult(); assertEquals("Activiti is awesome!", task.getName()); activitiRule.getTaskService().complete(task.getId()); &#125;&#125; BPMN 流程图1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;!-- org.destiny.activiti.delegate.MDCErrorDelegate 是一个会自动抛出异常 "test only" 的JavaDelegate --&gt; &lt;serviceTask id="someTask" activiti:class="org.destiny.activiti.delegate.MDCErrorDelegate"/&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; logback12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration debug="false" scan="true" scanPeriod="30 seconds"&gt; &lt;property name="log.dir" value="target/logs"/&gt; &lt;property name="encoding" value="UTF-8"/&gt; &lt;property name="plain" value="%msg%n"/&gt; &lt;property name="std" value="%d&#123;HH:mm:ss.SSS&#125; [%thread] [%level] %msg %X&#123;user&#125; %logger&#123;10&#125;.%M:%L%n"/&gt; &lt;!-- - MDC 配置: - ProcessDefinitionId: 流程定义 id - executionId: - mdcProcessInstanceId: 流程实例 id - mdcBusinessKey: 业务 key --&gt; &lt;property name="mdc" value="%d&#123;HH:mm:ss.SSS&#125; [%thread] [%level] %msg ProcessDefinitionId=%X&#123;mdcProcessDefinitionID&#125; executionId=%X&#123;mdcExecutionId&#125; mdcProcessInstanceId=%X&#123;mdcProcessInstanceId&#125; mdcBusinessKey=%X&#123;mdcBusinessKey&#125; %logger&#123;10&#125;.%M:%L%n"/&gt; &lt;property name="normal" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;10&#125;.%M:%L - %msg%n"/&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;!-- 此处将默认值输出由 std 改为 mdc --&gt; &lt;!--&lt;pattern&gt;$&#123;std&#125;&lt;/pattern&gt;--&gt; &lt;pattern&gt;$&#123;mdc&#125;&lt;/pattern&gt; &lt;!--&lt;pattern&gt;$&#123;mdc&#125;&lt;/pattern&gt;--&gt; &lt;charset&gt;$&#123;encoding&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; ... &lt;root&gt; &lt;appender-ref ref="stdout"/&gt; &lt;appender-ref ref="file"/&gt; &lt;/root&gt;&lt;/configuration&gt; 日志输出00:32:57.204 [main] [INFO] Loading XML bean definitions from class path resource [activiti.cfg.xml] ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.s.b.f.x.XmlBeanDefinitionReader.loadBeanDefinitions:316 00:32:58.659 [main] [INFO] Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.c.DefaultActiviti5CompatibilityHandlerFactory.createActiviti5CompatibilityHandler:38 00:32:58.671 [main] [INFO] performing create on engine with resource org/activiti/db/create/activiti.mysql.create.engine.sql ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:32:58.673 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:33:00.219 [main] [INFO] performing create on history with resource org/activiti/db/create/activiti.mysql.create.history.sql ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:33:00.220 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:33:00.657 [main] [INFO] performing create on identity with resource org/activiti/db/create/activiti.mysql.create.identity.sql ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:33:00.657 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:33:00.771 [main] [INFO] ProcessEngine default created ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.ProcessEngineImpl.&lt;init&gt;:87 00:33:00.932 [main] [INFO] MDCErrorDelegate.execute ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.d.MDCErrorDelegate.execute:24 00:33:00.935 [main] [ERROR] Error while closing command context ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.CommandContext.logException:122 java.lang.RuntimeException: test only ... 可以看到, 在 ERROR 行中, 打印出了 MDC 信息 4.3.1.3 使用拦截器让每个流程节点都把 MDC 信息打印出来新建拦截器12345678910111213141516171819202122232425262728public class MDCCommandInvoker extends DebugCommandInvoker &#123; /** * 先判断可运行的对象是不是 Activiti 支持的 Operation * 如果是, 将它强转, 并取出执行对象并输出 * * @param runnable */ @Override public void executeOperation(Runnable runnable) &#123; boolean mdcEnabled = LogMDC.isMDCEnabled(); LogMDC.setMDCEnabled(true); if (runnable instanceof AbstractOperation) &#123; AbstractOperation operation = (AbstractOperation) runnable; if (operation.getExecution() != null) &#123; // 如果是可操作对象, 将该信息放入 MDC 上下文对象 LogMDC.putMDCExecution(operation.getExecution()); &#125; &#125; super.executeOperation(runnable); LogMDC.clear(); if (!mdcEnabled) &#123; // 如果 MDC 原本不生效, 需要将 MDC 重新置为 false LogMDC.setMDCEnabled(false); &#125; &#125;&#125; 配置该拦截器 修改默认配置文件 activiti.cfg.xml, 新增该 MDCCommandInvoker 123456789101112131415161718&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 ProcessEngineConfiguration --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration"&gt; &lt;!-- 配置数据库连接 --&gt; &lt;property name="jdbcDriver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/activitiDB?createDatabaseIfNotExist=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false"/&gt; &lt;property name="jdbcUsername" value="root"/&gt; &lt;property name="jdbcPassword" value="123456"/&gt; &lt;property name="databaseSchemaUpdate" value="true"/&gt; &lt;property name="commandInvoker" ref="commandInvoker"/&gt; &lt;/bean&gt; &lt;bean id="commandInvoker" class="org.destiny.activiti.interceptor.MDCCommandInvoker"/&gt;&lt;/beans&gt; 最终产出日志00:56:35.631 [main] [INFO] Loading XML bean definitions from class path resource [activiti_mdc.cfg.xml] ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.s.b.f.x.XmlBeanDefinitionReader.loadBeanDefinitions:316 00:56:37.141 [main] [INFO] Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.c.DefaultActiviti5CompatibilityHandlerFactory.createActiviti5CompatibilityHandler:38 00:56:37.153 [main] [INFO] performing create on engine with resource org/activiti/db/create/activiti.mysql.create.engine.sql ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:56:37.154 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:56:38.655 [main] [INFO] performing create on history with resource org/activiti/db/create/activiti.mysql.create.history.sql ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:56:38.656 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:56:39.109 [main] [INFO] performing create on identity with resource org/activiti/db/create/activiti.mysql.create.identity.sql ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 00:56:39.110 [main] [INFO] Found MySQL: majorVersion=5 minorVersion=7 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.d.DbSqlSession.executeSchemaResource:1162 00:56:39.218 [main] [INFO] ProcessEngine default created ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.ProcessEngineImpl.&lt;init&gt;:87 00:56:39.403 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.407 [main] [INFO] 4 (process instance) └── 5 : start (StartEvent, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.409 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.410 [main] [INFO] 4 (process instance) └── 5 : start (StartEvent, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.411 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.412 [main] [INFO] 4 (process instance) └── 5 : start -&gt; someTask, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.412 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.412 [main] [INFO] 4 (process instance) └── 5 : someTask (UserTask, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.497 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.501 [main] [INFO] 4 (process instance) └── 5 : someTask (UserTask, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.502 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.503 [main] [INFO] 4 (process instance) └── 5 : someTask (UserTask, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.504 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.504 [main] [INFO] 4 (process instance) └── 5 : someTask -&gt; end, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.505 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.505 [main] [INFO] 4 (process instance) └── 5 : end (EndEvent, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.505 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.506 [main] [INFO] 4 (process instance) └── 5 : end (EndEvent, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 00:56:39.507 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.EndExecutionOperation : ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:33 00:56:39.507 [main] [INFO] 4 (process instance) └── 5 : end (EndEvent, parent id 4 (active) ProcessDefinitionId=my-process:1:3 executionId=5 mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.i.DebugCommandInvoker.executeOperation:34 可以看到最终所有级别的日志都输出了 MDC 信息 4.3.2 配置历史记录级别配置 HistoryLevel: none: 不记录历史记录, 性能高, 流程结束后不可读取; activiti: 归档流程实例和活动实例, 流程变量不同步; audit: 默认值, 在 activiti 基础上同步变量值, 保存表单属性; full: 性能较差, 记录所有实例和变量细节变化. 4.3.3 配置基于 DB 的事件日志配置 Event Logging 实验性的事件记录机制, 性能影响较大; 开启默认记录所有数据的变化过程, 导致表记录快速增长; 日志内容基于 JSON 格式, 建议存入 MongoDB, Elastic Search; 4.4 命令拦截器的配置4.4.1 命令模式与责任链模式4.4.1.1 Command 命令拦截器使用命令模式实现, 多个拦截器会组成一个拦截器链, 实现了责任链模式 Command: 命令接口 ConcreteCommand: 命令实现, 构造命令的时候, 需要传入接受者, 即 Received Receiver: Client 在实现 Command 接口的时候传入 Invoker: 调用者, 最终调用 ConcreteCommand 对象 4.4.1.2 Chain of Responsibility customPre, default, customPost 中 execute() 的实现基本都是调用了 next 的 execute(), 只有 CommandInvoker 真正完成了执行器. CustomPre: default 之前的拦截器 default: Activiti 默认的 CommandInterceptor CustomPost: default 之后的拦截器 CommandInvoker: 最终的命令执行者 4.4.2 命令拦截器的配置 配置Interceptor customProCommandInterceptors: 配置在默认拦截器之前 customPostCommandInterceptors: 配置在默认拦截器之后 commandInvoker: 配置在最后的执行器 4.4.3 示例 需求实现一个可以统计所有命令完成时间的拦截器 拦截器实现12345678910111213141516public class DurationCommandInterceptor extends AbstractCommandInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(DurationCommandInterceptor.class); @Override public &lt;T&gt; T execute(CommandConfig config, Command&lt;T&gt; command) &#123; // 记录当前时间 long start = System.currentTimeMillis(); try &#123; return this.getNext().execute(config, command); &#125; finally &#123; long duration = System.currentTimeMillis() - start; logger.info("&#123;&#125; 执行时长: &#123;&#125; 毫秒", command.getClass().getSimpleName(), duration); &#125; &#125;&#125; 配置文件1234567891011121314151617&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 ProcessEngineConfiguration --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration"&gt; &lt;property name="databaseSchemaUpdate" value="true"/&gt; &lt;property name="commandInvoker" ref="commandInvoker"/&gt; &lt;property name="customPreCommandInterceptors"&gt; &lt;list&gt; &lt;bean class="org.destiny.activiti.interceptor.DurationCommandInterceptor"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="commandInvoker" class="org.destiny.activiti.interceptor.MDCCommandInvoker"/&gt;&lt;/beans&gt; 日志输出10:10:09.371 [main] [INFO] SchemaOperationsProcessEngineBuild 执行时长: 113 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 10:10:09.372 [main] [INFO] ProcessEngine default created ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.a.e.i.ProcessEngineImpl.&lt;init&gt;:87 10:10:09.391 [main] [INFO] ValidateExecutionRelatedEntityCountCfgCmd 执行时长: 14 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 10:10:09.394 [main] [INFO] 执行时长: 1 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 10:10:09.401 [main] [INFO] GetNextIdBlockCmd 执行时长: 4 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 10:10:09.508 [main] [INFO] GetProcessDefinitionInfoCmd 执行时长: 2 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 10:10:09.513 [main] [INFO] DeployCmd 执行时长: 116 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 10:10:09.616 [main] [INFO] CompleteTaskCmd 执行时长: 22 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 10:10:09.630 [main] [INFO] DeleteDeploymentCmd 执行时长: 14 毫秒 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.i.DurationCommandInterceptor.execute:33 4.5 作业执行器 Job Executor4.5.1 作业执行器的配置 asyncExecutorActivate: 激活作业执行器 asyncExecutorXXX: 异步执行器的属性配置 asyncExecutor: 异步执行器 bean 定时开始事件 timeDate: 指定启动时间 timeDuration: 指定持续时间间隔后执行 timeCycle:R5/P1DT1H 指定时间段后周期执行 4.5.2 配置自定义线程池 corePoolSize: 核心线程数 maxPoolSize: 最大线程数 queueCapacity: 阻塞队列大小 如果核心线程数没满, 每当有一个任务, 不管原有线程是否空闲都会开启一个新的线程去执行, 直到达到核心线程数;如果所有核心线程都在运行, 每当有一个任务, 会先放在阻塞队列等待, 直到核心线程执行完上一个任务, 会取阻塞队列第一个任务继续执行;如果队列已满, 会继续创建新的线程, 直到达到最大线程数;如果最大线程数和队列都已满, 此时会执行拒绝策略. 4.5.3 流程定义定时启动流程4.5.4 Demo配置异步执行器12345678910111213141516171819202122232425262728293031323334&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 ProcessEngineConfiguration --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration"&gt; &lt;property name="databaseSchemaUpdate" value="true"/&gt; &lt;property name="commandInvoker" ref="commandInvoker"/&gt; &lt;!-- 打开异步执行器 --&gt; &lt;property name="asyncExecutorActivate" value="true"/&gt; &lt;property name="asyncExecutor" value="asyncExecutor"/&gt; &lt;!-- 事件监听 --&gt; &lt;property name="eventListeners"&gt; &lt;list&gt; &lt;bean class="org.destiny.activiti.listener.JobEventListener"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="asyncExecutor" class="org.activiti.engine.impl.asyncexecutor.DefaultAsyncJobExecutor"&gt; &lt;property name="executorService" ref="executorService"/&gt; &lt;/bean&gt; &lt;bean id="executorService" class="org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"&gt; &lt;property name="threadNamePrefix" value="activiti-job-"/&gt; &lt;property name="corePoolSize" value="5"/&gt; &lt;property name="maxPoolSize" value="20"/&gt; &lt;property name="queueCapacity" value="100"/&gt; &lt;property name="rejectedExecutionHandler"&gt; &lt;bean class="java.util.concurrent.ThreadPoolExecutor$AbortPolicy"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="commandInvoker" class="org.destiny.activiti.interceptor.MDCCommandInvoker"/&gt;&lt;/beans&gt; 流程定义文件12345678910111213&lt;process id="my-process"&gt; &lt;!--&lt;startEvent id="start"/&gt;--&gt; &lt;startEvent id="start"&gt; &lt;timerEventDefinition&gt; &lt;!-- 每 10 秒执行一次, 共执行 5 次 --&gt; &lt;timeCycle&gt;R5/PT10S&lt;/timeCycle&gt; &lt;/timerEventDefinition&gt; &lt;/startEvent&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;userTask id="someTask" name="Activiti is awesome!"/&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end"/&gt;&lt;/process&gt; 添加监听器12345678910111213141516171819public class JobEventListener implements ActivitiEventListener &#123; public static final Logger logger = LoggerFactory.getLogger(JobEventListener.class); @Override public void onEvent(ActivitiEvent event) &#123; ActivitiEventType eventType = event.getType(); String name = eventType.name(); if (name.startsWith("TIMER") || name.startsWith("JOB")) &#123; logger.info("监听 Job 事件: &#123;&#125; \t &#123;&#125;", eventType, event.getProcessInstanceId()); &#125; &#125; @Override public boolean isFailOnException() &#123; return false; &#125;&#125; 日志输出11:34:50.048 [main] [INFO] 监听 Job 事件: TIMER_SCHEDULED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:34:50.056 [main] [INFO] start ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.c.ConfigJobTest.test:33 11:34:50.080 [main] [INFO] 定时任务 TimerJobEntity [id=4], 默认重试次数: 3 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.c.ConfigJobTest.test:36 11:34:50.080 [main] [INFO] jobList.size: 1 ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.c.ConfigJobTest.test:38 11:35:09.981 [activiti-job-1] [INFO] 监听 Job 事件: TIMER_FIRED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:09.990 [activiti-job-1] [INFO] 监听 Job 事件: TIMER_SCHEDULED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:09.990 [activiti-job-1] [INFO] 监听 Job 事件: JOB_EXECUTION_SUCCESS null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:19.950 [activiti-job-2] [INFO] 监听 Job 事件: TIMER_FIRED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:19.951 [activiti-job-2] [INFO] 监听 Job 事件: TIMER_SCHEDULED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:19.951 [activiti-job-2] [INFO] 监听 Job 事件: JOB_EXECUTION_SUCCESS null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:29.958 [activiti-job-3] [INFO] 监听 Job 事件: TIMER_FIRED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:29.959 [activiti-job-3] [INFO] 监听 Job 事件: TIMER_SCHEDULED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:29.960 [activiti-job-3] [INFO] 监听 Job 事件: JOB_EXECUTION_SUCCESS null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:39.966 [activiti-job-4] [INFO] 监听 Job 事件: TIMER_FIRED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:39.970 [activiti-job-4] [INFO] 监听 Job 事件: TIMER_SCHEDULED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:39.971 [activiti-job-4] [INFO] 监听 Job 事件: JOB_EXECUTION_SUCCESS null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:49.975 [activiti-job-5] [INFO] 监听 Job 事件: TIMER_FIRED null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 11:35:49.975 [activiti-job-5] [INFO] 监听 Job 事件: JOB_EXECUTION_SUCCESS null ProcessDefinitionId= executionId= mdcProcessInstanceId= mdcBusinessKey= o.d.a.l.JobEventListener.onEvent:34 4.6 Activiti 与 Spring 集成4.6.1 集成 Spring 配置 添加依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt;&lt;/dependency&gt; 基于 Spring 的默认配置: activiti-context.xml, 如果配置该文件, Activiti 在启动过程中就会查找基于 Spring 的 ProcessEngineConfiguration 对象; Activiti 核心服务注入 Spring 容器 4.6.2 基于 Spring 对 Activiti 的管理4.6.2.1 集成 Spring 事务管理器activiti-context.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 ProcessEngineConfiguration --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; &lt;!-- Spring 需要单独配置 DataSource --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="transactionManager" ref="transactionManager"/&gt; &lt;property name="databaseSchemaUpdate" value="true"/&gt; &lt;/bean&gt; &lt;!-- 数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="org.h2.Driver"/&gt; &lt;property name="url" value="jdbc:h2:mem:activiti"/&gt; &lt;property name="username" value="sa"/&gt; &lt;property name="password" value=""/&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 流程引擎对象 --&gt; &lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration"/&gt; &lt;/bean&gt; &lt;!-- 将服务暴露给 Spring --&gt; &lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService"/&gt; &lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService"/&gt; &lt;bean id="formService" factory-bean="processEngine" factory-method="getFormService"/&gt; &lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService"/&gt; &lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService"/&gt; &lt;!-- 配置 activitiRule 用于测试 --&gt; &lt;bean id="activitiRule" class="org.activiti.engine.test.ActivitiRule"&gt; &lt;property name="processEngine" ref="processEngine"/&gt; &lt;/bean&gt;&lt;/beans&gt; 4.6.2.2 定义文件表达式中使用 Spring BeanHelloBean12345678public class HelloBean &#123; private static final Logger logger = LoggerFactory.getLogger(HelloBean.class); public void sayHello() &#123; logger.info("sayHello"); &#125;&#125; my-process-spring.bpmn20.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;userTask id="someTask" name="Activiti is awesome!"/&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="helloBean"/&gt; &lt;!-- 从 Spring 容器中查找 Hello bean, 并且调用 sayHello() 方法 --&gt; &lt;serviceTask id="helloBean" activiti:expression="$&#123;helloBean.sayHello()&#125;"/&gt; &lt;sequenceFlow id="flow3" sourceRef="helloBean" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试类12345678910111213141516171819202122232425262728@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;"classpath:activiti-context.xml"&#125;)public class ConfigSpringTest &#123; public static final Logger logger = LoggerFactory.getLogger(ConfigSpringTest.class); @Rule @Autowired public ActivitiRule activitiRule; @Autowired private RuntimeService runtimeService; @Autowired private TaskService taskService; @Test @Deployment(resources = &#123;"my-process-spring.bpmn20.xml"&#125;) public void test() &#123; ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process"); Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult(); taskService.complete(task.getId()); logger.info("processInstance: [&#123;&#125;]", processInstance); logger.info("task: [&#123;&#125;]", task); &#125;&#125; 4.6.2.3 自动部署资源文件4.6.3 基于 Spring 的流程单元测试 添加依赖 spring-test 辅助测试 Rule: ActivitiRule 辅助测试 TestCase: SpringActivitiTestCase 5. Activiti 核心 API 服务名称 功能 RepositoryServie 负责对静态文件的管理, 涉及部署对象和资源对象, 其二者是一对多的关系 RuntimeService 负责对流程进行控制的服务, 可以对流程实例完成启动, 暂停, 挂起等操作 TaskService 负责管理运行中的 UserTask(人工任务) IdentityService 负责对用户和用户组的管理 FormService 负责解析流程定义中的表单, 对表单的数据类型做渲染 HistoryService 提供了对运行结束的流程实例的查询和删除操作 ManagementService 提供了对流程引擎基础的管理, 提供对定时任务 Job 的管理, 获取表结构, 表明的操作 DynamicBpmnService 提供了对动态的流程定义模型做修改 5.1 RepositoryService 管理流程定义文件 xml 及静态资源服务 对特定的流程的暂停和激活 流程定义启动权限管理 部署文件构造器 DeploymentBuilder 部署文件查询器 DeploymentQuery 流程定义文件查询对象 ProcessDefinitionQuery 流程部署文件对象 Deployment 流程定义文件对象 ProcessDefinition 流程定义的 Java 格式 BpmnModel RepositoryService API: 方法名 功能 createDeployment 添加资源文件 deleteDeployment 删除资源文件 setDeploymentCategory 指定分类名称 createProcessDefinitionQuery 创建流程定义查询对象 createNativeProcessDefinitionQuery 通过 SQL 查询流程定义对象 suspendProcessDefinitionByXX 通过某些条件暂停/挂起流程定义对象, 使之不能再生成新的流程实例 activateProcessDefinitionByXX 通过某些条件激活流程定义对象, 使之可以继续生成新的流程实例 getProcssDiagram 获取流程图的数据流 getBpmnModel 获取 BpmnModel 对象 addCandidateStarterUser 设置某个流程文件只能由指定的用户去启动 addCandidateStarterGroup 设置某个流程文件只能由指定的用户组去启动 … … 5.1.1 ProcessDefinitionId 的含义1234567891011121314151617181920212223242526272829303132333435363738@Testpublic void testRepository() &#123; RepositoryService repositoryService = activitiRule.getRepositoryService(); DeploymentBuilder deploymentBuilder1 = repositoryService.createDeployment(); deploymentBuilder1 // 一个部署对象就记录了一次部署 .name("测试部署资源1") // 设置名称 .addClasspathResource("org/destiny/activiti/my-process.bpmn20.xml") .addClasspathResource("org/destiny/activiti/SecondApprove.bpmn20.xml") .deploy(); // 完成部署 DeploymentBuilder deploymentBuilder2 = repositoryService.createDeployment(); deploymentBuilder2 // 一个部署对象就记录了一次部署 .name("测试部署资源2") // 设置名称 .addClasspathResource("org/destiny/activiti/my-process.bpmn20.xml") .addClasspathResource("org/destiny/activiti/SecondApprove.bpmn20.xml") .deploy(); // 完成部署 // 查询部署对象 List&lt;Deployment&gt; deploymentList = repositoryService.createDeploymentQuery() .orderByDeploymenTime().asc() .list(); logger.info("size of deploymentList: &#123;&#125;", deploymentList.size()); for (Deployment deployment : deploymentList) &#123; logger.info("deployment: &#123;&#125;", deployment); &#125; // 流程定义 List&lt;ProcessDefinition&gt; processDefinitionList = repositoryService .createProcessDefinitionQuery() .orderByProcessDefinitionKey().asc() .listPage(0, 100); for (ProcessDefinition processDefinition : processDefinitionList) &#123; logger.info("processDefinition: &#123;&#125;, version: &#123;&#125;, key: &#123;&#125;, name: &#123;&#125;", processDefinition, processDefinition.getVersion(), processDefinition.getKey(), processDefinition.getName()); &#125;&#125; 生成的日志: 08:42:45,507 [main] INFO org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loading XML bean definitions from class path resource [activiti.cfg.xml] 08:42:47,193 [main] INFO org.activiti.engine.compatibility.DefaultActiviti5CompatibilityHandlerFactory - Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. 08:42:47,207 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on engine with resource org/activiti/db/create/activiti.h2.create.engine.sql 08:42:47,268 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on history with resource org/activiti/db/create/activiti.h2.create.history.sql 08:42:47,274 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on identity with resource org/activiti/db/create/activiti.h2.create.identity.sql 08:42:47,280 [main] INFO org.activiti.engine.impl.ProcessEngineImpl - ProcessEngine default created 08:42:49,736 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - size of deploymentList: 2 08:42:49,736 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - deployment: DeploymentEntity[id=1, name=测试部署资源1] 08:42:49,736 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - deployment: DeploymentEntity[id=7, name=测试部署资源2] 08:42:49,742 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - processDefinition: ProcessDefinitionEntity[SecondApprove:1:5], version: 1, key: SecondApprove, name: 二级审批 08:42:49,742 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - processDefinition: ProcessDefinitionEntity[SecondApprove:2:11], version: 2, key: SecondApprove, name: 二级审批 08:42:49,742 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - processDefinition: ProcessDefinitionEntity[my-process:1:6], version: 1, key: my-process, name: null 08:42:49,743 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - processDefinition: ProcessDefinitionEntity[my-process:2:12], version: 2, key: my-process, name: null 两个 DeploymentEntity, 一个 id 为 1, 一个 id 为 7, id 的设置使用全局自增, 说明在两个 Deployment 对象的部署过程中插入了 6 条记录: 1 个部署记录; 2 个流程定义记录; 2 个 xml 文件对应的数据流记录; 1 个流程定义所生成的图片记录;(my-process 没有生成图片) 5.1.2 流程挂起/激活测试代码: 1234567891011121314151617181920212223@Test@org.activiti.engine.test.Deployment(resources = "org/destiny/activiti/my-process.bpmn20.xml")public void testSuspend() &#123; RepositoryService repositoryService = activitiRule.getRepositoryService(); ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().singleResult(); String processDefinitionId = processDefinition.getId(); logger.info("processDefinitionId: &#123;&#125;", processDefinitionId); repositoryService.suspendProcessDefinitionById(processDefinitionId); try &#123; logger.info("开始启动"); activitiRule.getRuntimeService().startProcessInstanceById(processDefinitionId); logger.info("启动成功"); &#125; catch (Exception e) &#123; logger.error("启动失败, 原因: &#123;&#125;", e.getMessage()); &#125; repositoryService.activateProcessDefinitionById(processDefinitionId); logger.info("激活后开始启动"); activitiRule.getRuntimeService().startProcessInstanceById(processDefinitionId); logger.info("激活后启动成功");&#125; 输出日志: 09:12:42,071 [main] INFO org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loading XML bean definitions from class path resource [activiti.cfg.xml] 09:12:43,614 [main] INFO org.activiti.engine.compatibility.DefaultActiviti5CompatibilityHandlerFactory - Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. 09:12:43,627 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on engine with resource org/activiti/db/create/activiti.h2.create.engine.sql 09:12:43,682 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on history with resource org/activiti/db/create/activiti.h2.create.history.sql 09:12:43,688 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on identity with resource org/activiti/db/create/activiti.h2.create.identity.sql 09:12:43,692 [main] INFO org.activiti.engine.impl.ProcessEngineImpl - ProcessEngine default created 09:12:43,882 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - processDefinitionId: my-process:1:3 09:12:43,887 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - 开始启动 09:12:43,893 [main] ERROR org.activiti.engine.impl.interceptor.CommandContext - Error while closing command context org.activiti.engine.ActivitiException: Cannot start process instance. Process definition null (id = my-process:1:3) is suspended at org.activiti.engine.impl.util.ProcessInstanceHelper.createAndStartProcessInstance(ProcessInstanceHelper.java:67) at org.activiti.engine.impl.util.ProcessInstanceHelper.createAndStartProcessInstance(ProcessInstanceHelper.java:51) at org.activiti.engine.impl.cmd.StartProcessInstanceCmd.createAndStartProcessInstance(StartProcessInstanceCmd.java:109) at org.activiti.engine.impl.cmd.StartProcessInstanceCmd.execute(StartProcessInstanceCmd.java:102) at org.activiti.engine.impl.cmd.StartProcessInstanceCmd.execute(StartProcessInstanceCmd.java:37) at org.activiti.engine.impl.interceptor.CommandInvoker$1.run(CommandInvoker.java:37) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperation(CommandInvoker.java:78) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperations(CommandInvoker.java:57) at org.activiti.engine.impl.interceptor.CommandInvoker.execute(CommandInvoker.java:42) at org.activiti.engine.impl.interceptor.TransactionContextInterceptor.execute(TransactionContextInterceptor.java:48) at org.activiti.engine.impl.interceptor.CommandContextInterceptor.execute(CommandContextInterceptor.java:63) at org.activiti.engine.impl.interceptor.LogInterceptor.execute(LogInterceptor.java:29) at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:44) at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:39) at org.activiti.engine.impl.RuntimeServiceImpl.startProcessInstanceById(RuntimeServiceImpl.java:114) at org.destiny.activiti.coreapi.RepositoryServiceTest.testSuspend(RepositoryServiceTest.java:86) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.activiti.engine.test.ActivitiRule$1.evaluate(ActivitiRule.java:116) at org.junit.rules.RunRules.evaluate(RunRules.java:20) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229) at org.junit.runners.ParentRunner.run(ParentRunner.java:309) at org.junit.runner.JUnitCore.run(JUnitCore.java:160) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) 09:12:43,895 [main] ERROR org.destiny.activiti.coreapi.RepositoryServiceTest - 启动失败, 原因: Cannot start process instance. Process definition null (id = my-process:1:3) is suspended 09:12:43,897 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - 激活后开始启动 09:12:43,923 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - 激活后启动成功 5.1.3 绑定用户/用户组 测试代码: 123456789101112131415161718192021222324252627282930/** * 测试用户组 * repositoryService 只提供了构建关系的方式, 具体的校验逻辑需要自己完成 * 可以取出用户/用户组信息, 自行通过逻辑判断 */@Test@org.activiti.engine.test.Deployment(resources = "org/destiny/activiti/my-process.bpmn20.xml")public void testCandidateStarter() &#123; RepositoryService repositoryService = activitiRule.getRepositoryService(); ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().singleResult(); String processDefinitionId = processDefinition.getId(); logger.info("processDefinitionId: &#123;&#125;", processDefinitionId); // userId/groupM 是对应的用户/用户组管理服务中创建的 id repositoryService.addCandidateStarterUser(processDefinitionId, "user"); repositoryService.addCandidateStarterGroup(processDefinitionId, "groupM"); List&lt;IdentityLink&gt; identityLinkList = repositoryService.getIdentityLinksForProcessDefinition(processDefinitionId); for (IdentityLink identityLink : identityLinkList) &#123; logger.info("删除前: identityLink: [&#123;&#125;]", identityLink); &#125; repositoryService.deleteCandidateStarterGroup(processDefinitionId, "groupM"); repositoryService.deleteCandidateStarterUser(processDefinitionId, "user"); List&lt;IdentityLink&gt; identityLinkList1 = repositoryService.getIdentityLinksForProcessDefinition(processDefinitionId); for (IdentityLink identityLink : identityLinkList1) &#123; logger.info("删除后: identityLink: [&#123;&#125;]", identityLink); &#125;&#125; 日志输出: 10:08:35,380 [main] INFO org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loading XML bean definitions from class path resource [activiti.cfg.xml] 10:08:36,784 [main] INFO org.activiti.engine.compatibility.DefaultActiviti5CompatibilityHandlerFactory - Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. 10:08:36,796 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on engine with resource org/activiti/db/create/activiti.h2.create.engine.sql 10:08:36,842 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on history with resource org/activiti/db/create/activiti.h2.create.history.sql 10:08:36,846 [main] INFO org.activiti.engine.impl.db.DbSqlSession - performing create on identity with resource org/activiti/db/create/activiti.h2.create.identity.sql 10:08:36,849 [main] INFO org.activiti.engine.impl.ProcessEngineImpl - ProcessEngine default created 10:08:37,009 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - processDefinitionId: my-process:1:3 10:08:37,016 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - 删除前: identityLink: [IdentityLinkEntity[id=4, type=candidate, userId=user, processDefId=my-process:1:3]] 10:08:37,016 [main] INFO org.destiny.activiti.coreapi.RepositoryServiceTest - 删除前: identityLink: [IdentityLinkEntity[id=5, type=candidate, groupId=groupM, processDefId=my-process:1:3]] 5.2 RuntimeService 流程运行控制服务功能: 启动流程及对流程数据的控制 流程实例(ProcessInstance)与执行流(Execution)查询(当创建实例的时候, 一般也会创建一个执行流) 触发流程操作, 接受信号的消息 Runtime 启动流程及变量管理: 启动流程的常用方式(id, key, message) 启动流程可选参数: businessKey variables tenantId 变量(variables)的设置和获取 5.2.1 基本操作5.2.1.1 根据流程定义 key 启动流程 每次流程部署时, 对应 ProcessDefintion 的 id 和 version 都会改变, 根据 ProcessDefintionKey 默认取最后一个版本的数据 1234567891011@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process.bpmn20.xml"&#125;)public void testStartProcess() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("key1", "value1"); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process", variables); log.info("processInstance: &#123;&#125;", processInstance);&#125; 5.2.1.2 根据流程定义 id 使用 ProcessDefintionId 进行获取的时候, 需要先通过 RepositoryService 获取到对应的 id 1234567891011121314/** * 根据流程定义 id 启动流程 */@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process.bpmn20.xml"&#125;)public void testStartProcessById() &#123; RepositoryService repositoryService = activitiRule.getRepositoryService(); ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().singleResult(); RuntimeService runtimeService = activitiRule.getRuntimeService(); Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("key1", "value1"); ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinition.getId(), variables); log.info("processInstance: &#123;&#125;", processInstance);&#125; 5.2.1.3 通过 ProcessInstanceBuilder 完成流程的设置以及启动12345678910111213@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process.bpmn20.xml"&#125;)public void testProcessBuilder() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("key1", "value1"); ProcessInstance processInstance = runtimeService.createProcessInstanceBuilder() .businessKey("businessKey001") .processDefinitionKey("my-process") .variables(variables) .start(); log.info("processInstance: &#123;&#125;", processInstance);&#125; 5.2.1.4 设置和获取流程变量1234567891011121314151617@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process.bpmn20.xml"&#125;)public void testVariables() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("key1", "value1"); variables.put("key2", "value2"); variables.put("key3", "value3"); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process", variables); log.info("processInstance: &#123;&#125;", processInstance); // 覆盖原有内容 runtimeService.setVariable(processInstance.getId(), "key3", "newValue4"); runtimeService.setVariable(processInstance.getId(), "key4", "value4"); // 根据流程实例 id 获取流程变量 Map&lt;String, Object&gt; map = runtimeService.getVariables(processInstance.getId()); log.info("variable map: &#123;&#125;", map);&#125; 日志输出: 11:55:06.844 [main] [INFO] variable map: {key1=value1, key2=value2, key3=newValue4, key4=value4} o.d.a.c.RuntimeServiceTest.testVariables:94 5.2.1.5 对流程实例的查询123456789101112@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process.bpmn20.xml"&#125;)public void testProcessInstanceQuery() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); Map&lt;String, Object&gt; variables = Maps.newHashMap(); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process", variables); log.info("processInstance: &#123;&#125;", processInstance); ProcessInstance processInstance1 = runtimeService.createProcessInstanceQuery() .processInstanceId(processInstance.getId()) .singleResult(); log.info("processInstance1: &#123;&#125;", processInstance1);&#125; 5.2.1.6 对执行流的查询12345678910111213@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process.bpmn20.xml"&#125;)public void testExecutionQuery() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); Map&lt;String, Object&gt; variables = Maps.newHashMap(); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process", variables); log.info("processInstance: &#123;&#125;", processInstance); List&lt;Execution&gt; executionList = runtimeService.createExecutionQuery() .listPage(0, 100); for (Execution execution : executionList) &#123; log.info("execution: &#123;&#125;", execution); &#125;&#125; 5.2.2 流程实例与执行流 流程实例(ProcessInstance) 表示一次工作流业务的数据实体, 当每次启动流程的时候, 生成一个流程实例 执行流(Execution) 表示流程实例中具体的执行路径, 如果简单的流程只有一条执行路径, 那么此时流程实例和执行流是一对一的关系 流程实例接口继承与执行流 5.2.3 流程触发 使用 trigger 触发 receiveTask 节点 触发信号捕获事件 singalEventRecivied(信号可以全局发送) 触发消息捕获事件 messageEventReceived(消息只能针对某一个流程实例) 5.2.3.1 流程触发 trigger 流程配置文件12345678910111213141516&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;!--&lt;userTask id="someTask" name="Activiti is awesome!"/&gt;--&gt; &lt;receiveTask id="someTask"/&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试代码1234567891011121314151617@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-trigger.bpmn20.xml"&#125;)public void testTrigger() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process"); // 开始流程后流程实例就会在 receiveTask 节点等待处理 Execution execution = runtimeService.createExecutionQuery() .activityId("someTask") .singleResult(); log.info("execution: &#123;&#125;", execution); runtimeService.trigger(execution.getId()); // 再次查询 execution = runtimeService.createExecutionQuery() .activityId("someTask") .singleResult(); log.info("execution: &#123;&#125;", execution);&#125; 输出日志1214:59:58.256 [main] [INFO] execution: Execution[ id &apos;5&apos; ] - activity &apos;someTask - parent &apos;4&apos; o.d.a.c.RuntimeServiceTest.testTrigger:13714:59:58.291 [main] [INFO] execution: null o.d.a.c.RuntimeServiceTest.testTrigger:142] 当完成了触发之后, 执行对象已经执行完成 5.2.3.2 流程触发 singalEventReceived 流程开始后, 流程会暂停在中间节点(SingalCatchingEvent), 当它获取到信号时间的时候, 才会继续流转 流程定义文件12345678910111213141516171819&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;signal id="signalStart" name="my-signal"/&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="signal-received"/&gt; &lt;!-- 定义捕获边界事件, 当该节点接收到 my-signal 信号后会继续向后流转 --&gt; &lt;intermediateCatchEvent id="signal-received"&gt; &lt;signalEventDefinition signalRef="signalStart"/&gt; &lt;/intermediateCatchEvent&gt; &lt;!--&lt;userTask id="someTask" name="Activiti is awesome!"/&gt;--&gt; &lt;sequenceFlow id="flow2" sourceRef="signal-received" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试代码123456789101112131415161718@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-signal.bpmn20.xml"&#125;)public void testSignalEventReceived() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process"); // 查询数据库是否有一个正在等待信号的节点 Execution execution = runtimeService.createExecutionQuery() .signalEventSubscriptionName("my-signal") .singleResult(); log.info("execution: &#123;&#125;", execution); // 触发信号 runtimeService.signalEventReceived("my-signal"); // 重新执行查询 execution = runtimeService.createExecutionQuery() .signalEventSubscriptionName("my-signal") .singleResult(); log.info("execution: &#123;&#125;", execution);&#125; 日志输出15:14:42.184 [main] [INFO] execution: Execution[ id &apos;5&apos; ] - activity &apos;signal-received - parent &apos;4&apos; o.d.a.c.RuntimeServiceTest.testSignalEventReceived:155 15:14:42.216 [main] [INFO] execution: null o.d.a.c.RuntimeServiceTest.testSignalEventReceived:163 5.2.3.3 流程触发 messageEventReceived 消息触发与信号触发非常相似, 唯一的不同是: 信号与具体的流程实例无关, 消息在执行过程中必须制定流程实例 id 流程定义文件12345678910111213141516171819&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;message id="messageStart" name="my-message"/&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="message-received"/&gt; &lt;!-- 定义捕获边界事件, 当该节点接收到 my-message 消息后会继续向后流转 --&gt; &lt;intermediateCatchEvent id="message-received"&gt; &lt;messageEventDefinition messageRef="messageStart"/&gt; &lt;/intermediateCatchEvent&gt; &lt;!--&lt;userTask id="someTask" name="Activiti is awesome!"/&gt;--&gt; &lt;sequenceFlow id="flow2" sourceRef="message-received" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试代码123456789101112131415161718@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-message.bpmn20.xml"&#125;)public void testMessageEventReceived() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("my-process"); // 查询数据库是否有一个正在等待信号的节点 Execution execution = runtimeService.createExecutionQuery() .messageEventSubscriptionName("my-message") // 查询订阅了该信号的执行流 .singleResult(); log.info("execution: &#123;&#125;", execution); // 触发消息, 不同于信号的触发, message 在触发时需要指定 executionId runtimeService.messageEventReceived("my-message", execution.getId()); // 重新执行查询 execution = runtimeService.createExecutionQuery() .messageEventSubscriptionName("my-message") .singleResult(); log.info("execution: &#123;&#125;", execution);&#125; 日志输出15:37:52.024 [main] [INFO] execution: Execution[ id &apos;5&apos; ] - activity &apos;message-received - parent &apos;4&apos; o.d.a.c.RuntimeServiceTest.testMessageEventReceived:175 15:37:52.054 [main] [INFO] execution: null o.d.a.c.RuntimeServiceTest.testMessageEventReceived:183 5.2.3.4 流程基于 message 启动流程定义12345678910111213141516171819&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;!-- 此时既可以基于 key 启动, 也可以基于 message 启动 --&gt; &lt;message id="messageStart" name="my-message"/&gt; &lt;process id="my-process"&gt; &lt;!-- 需要将 messageEventDefinition 放在开始节点 --&gt; &lt;startEvent id="start"&gt; &lt;messageEventDefinition messageRef="messageStart"/&gt; &lt;/startEvent&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;userTask id="someTask" name="Activiti is awesome!"/&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试代码1234567@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-message-start.bpmn20.xml"&#125;)public void testMessageStart() &#123; RuntimeService runtimeService = activitiRule.getRuntimeService(); ProcessInstance processInstance = runtimeService.startProcessInstanceByMessage("my-message"); log.info("processInstance: &#123;&#125;", processInstance);&#125; 日志输出15:45:12.844 [main] [INFO] processInstance: ProcessInstance[5] o.d.a.c.RuntimeServiceTest.testMessageStart:195 基于 message 启动流程时, ProcessInstance 的 id 是 5, 意味着在流程订阅表中多插入了一条数据, 在实际启动过程中, 还是通过 message 找到 ProcessDefinition 的 key, 最终根据 key 来启动 5.3 TaskService 任务管理服务TaskService 提供的功能: 对用户任务管理和流程的控制 设置用户任务的权限信息(拥有者/候选人/办理人) 针对用户任务添加任务附件, 任务评论和事件记录 TaskService 对 Task 管理与流程控制: Task 对象的创建, 删除 查询 Task, 并驱动 Task 节点完成执行 Task 相关参数变量设置 local 变量 非 local 变量 5.3.1 基本操作5.3.1.1 获取 task/ 设置变量/ 驱动完成流程定义文件1234567891011121314151617181920&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;!-- 添加候选人 --&gt; &lt;userTask id="someTask" name="Activiti is awesome!" activiti:candidateUsers="destiny,destiny1,destiny2"&gt; &lt;!-- 添加描述, message 会根据上下文中传入的 message 变量值去替换 --&gt; &lt;documentation&gt; some task $&#123;message&#125; &lt;/documentation&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试代码12345678910111213141516171819202122232425262728293031323334@Test @Deployment(resources = &#123;"org/destiny/activiti/my-process-task.bpmn20.xml"&#125;) public void testTaskService() &#123; Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("message", "my test message"); TaskService taskService = activitiRule.getTaskService(); // 部署流程定义文件 ProcessInstance processInstance = activitiRule.getRuntimeService() .startProcessInstanceByKey("my-process", variables); Task task = taskService.createTaskQuery().singleResult(); log.info("task: &#123;&#125;", ToStringBuilder.reflectionToString(task, ToStringStyle.JSON_STYLE)); log.info("task.description: &#123;&#125;", task.getDescription()); // 设置变量 taskService.setVariable(task.getId(), "k1", "v1"); taskService.setVariableLocal(task.getId(), "localK1", "localV1"); // local 只在 task 范围可见 Map&lt;String, Object&gt; taskServiceVariables = taskService.getVariables(task.getId()); Map&lt;String, Object&gt; taskServiceVariablesLocal = taskService.getVariablesLocal(task.getId()); // 根据流程获取 Map&lt;String, Object&gt; processVariables = activitiRule.getRuntimeService().getVariables(task.getExecutionId()); log.info("taskServiceVariables: &#123;&#125;", taskServiceVariables); // &#123;k1=v1, localK1=localV1, message=my test message&#125; log.info("taskServiceVariablesLocal: &#123;&#125;", taskServiceVariablesLocal); // &#123;localK1=localV1&#125; log.info("processVariables: &#123;&#125;", processVariables); // &#123;k1=v1, message=my test message&#125; Map&lt;String, Object&gt; completeVar = Maps.newHashMap(); completeVar.put("cKey1", "cValue1"); taskService.complete(task.getId(), completeVar); Task task1 = taskService.createTaskQuery().taskId(task.getId()).singleResult(); log.info("task1: &#123;&#125;", task1); &#125; 日志输出16:13:26.654 [main] [INFO] Loading XML bean definitions from class path resource [activiti.cfg.xml] o.s.b.f.x.XmlBeanDefinitionReader.loadBeanDefinitions:316 16:13:28.438 [main] [INFO] Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. o.a.e.c.DefaultActiviti5CompatibilityHandlerFactory.createActiviti5CompatibilityHandler:38 16:13:28.451 [main] [INFO] performing create on engine with resource org/activiti/db/create/activiti.h2.create.engine.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 16:13:28.527 [main] [INFO] performing create on history with resource org/activiti/db/create/activiti.h2.create.history.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 16:13:28.535 [main] [INFO] performing create on identity with resource org/activiti/db/create/activiti.h2.create.identity.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 16:13:28.541 [main] [INFO] ProcessEngine default created o.a.e.i.ProcessEngineImpl.&lt;init&gt;:87 16:13:28.793 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.796 [main] [INFO] 4 (process instance) └── 6 : start (StartEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.798 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.799 [main] [INFO] 4 (process instance) └── 6 : start (StartEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.800 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.800 [main] [INFO] 4 (process instance) └── 6 : start -&gt; someTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.802 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.802 [main] [INFO] 4 (process instance) └── 6 : someTask (UserTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.878 [main] [INFO] task: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:0,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:null,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Activiti is awesome!&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:&quot;some task my test message&quot;,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Mon Dec 03 16:13:28 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;6&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;my-process:1:3&quot;,&quot;taskDefinitionKey&quot;:&quot;someTask&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;9&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.TaskServiceTest.testTaskService:33 16:13:28.878 [main] [INFO] task.description: some task my test message o.d.a.c.TaskServiceTest.testTaskService:34 16:13:28.893 [main] [INFO] taskServiceVariables: {k1=v1, localK1=localV1, message=my test message} o.d.a.c.TaskServiceTest.testTaskService:46 16:13:28.893 [main] [INFO] taskServiceVariablesLocal: {localK1=localV1} o.d.a.c.TaskServiceTest.testTaskService:47 16:13:28.893 [main] [INFO] processVariables: {k1=v1, message=my test message} o.d.a.c.TaskServiceTest.testTaskService:48 16:13:28.893 [main] [INFO] 4 (process instance) └── 6 : someTask (UserTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.893 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.893 [main] [INFO] 4 (process instance) └── 6 : someTask (UserTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.893 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.893 [main] [INFO] 4 (process instance) └── 6 : someTask -&gt; end, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.893 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.893 [main] [INFO] 4 (process instance) └── 6 : end (EndEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.893 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.893 [main] [INFO] 4 (process instance) └── 6 : end (EndEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.893 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.EndExecutionOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:13:28.893 [main] [INFO] 4 (process instance) └── 6 : end (EndEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:13:28.893 [main] [INFO] task1: null o.d.a.c.TaskServiceTest.testTaskService:55 5.3.1.2 TaskService 设置 Task 权限信息 候选用户(candidateUser) 和候选组(candidateGroup) 指定拥有人(Owner)和办理人(Assignee) 通过 claim 设置办理人(发现 task 已经有指定办理人且不是 claim 指定的人就会抛出异常) 流程定义1234567891011121314151617181920&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start"/&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;!-- 添加候选人 --&gt; &lt;userTask id="someTask" name="Activiti is awesome!" activiti:candidateUsers="destiny,destiny1,destiny2"&gt; &lt;!-- 添加描述, message 会根据上下文中传入的 message 变量值去替换 --&gt; &lt;documentation&gt; some task $&#123;message&#125; &lt;/documentation&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-task.bpmn20.xml"&#125;)public void testTaskServiceUser() &#123; Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("message", "my test message"); activitiRule.getRuntimeService().startProcessInstanceByKey("my-process", variables); TaskService taskService = activitiRule.getTaskService(); Task task = taskService.createTaskQuery().singleResult(); log.info("task: &#123;&#125;", ToStringBuilder.reflectionToString(task, ToStringStyle.JSON_STYLE)); log.info("task.description: &#123;&#125;", task.getDescription()); taskService.setOwner(task.getId(), "user1"); // 可能存在覆盖已有代办放的问题, 因此不推荐 // taskService.setAssignee(task.getId(), "destiny"); // 查询在候选人列表, 且未指定办理人的 task 列表 List&lt;Task&gt; taskList = taskService.createTaskQuery() .taskCandidateOrAssigned("destiny") .taskUnassigned() .listPage(0, 100); // 使用 claim 设置候选人 for (Task task1 : taskList) &#123; try &#123; taskService.claim(task1.getId(), "destiny"); &#125; catch (Exception e) &#123; log.warn(e.getMessage(), e); &#125; &#125; // 查看当前 task 的所有用户关系内容 List&lt;IdentityLink&gt; identityLinkList = taskService.getIdentityLinksForTask(task.getId()); for (IdentityLink identityLink : identityLinkList) &#123; log.info("identityLink: &#123;&#125;", identityLink); &#125; // 完成任务, 首先找到处于代办状态的所有 task List&lt;Task&gt; destinys = taskService.createTaskQuery().taskAssignee("destiny").listPage(0, 100); for (Task destiny : destinys) &#123; variables.clear(); variables.put("cKey1", "cValue1"); taskService.complete(destiny.getId(), variables); &#125; destinys = taskService.createTaskQuery().taskAssignee("destiny").listPage(0, 100); log.info("是否存在: &#123;&#125;", CollectionUtils.isEmpty(destinys));&#125; 输出日志16:41:28.534 [main] [INFO] Loading XML bean definitions from class path resource [activiti.cfg.xml] o.s.b.f.x.XmlBeanDefinitionReader.loadBeanDefinitions:316 16:41:30.373 [main] [INFO] Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. o.a.e.c.DefaultActiviti5CompatibilityHandlerFactory.createActiviti5CompatibilityHandler:38 16:41:30.385 [main] [INFO] performing create on engine with resource org/activiti/db/create/activiti.h2.create.engine.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 16:41:30.443 [main] [INFO] performing create on history with resource org/activiti/db/create/activiti.h2.create.history.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 16:41:30.449 [main] [INFO] performing create on identity with resource org/activiti/db/create/activiti.h2.create.identity.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 16:41:30.453 [main] [INFO] ProcessEngine default created o.a.e.i.ProcessEngineImpl.&lt;init&gt;:87 16:41:30.631 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.636 [main] [INFO] 4 (process instance) └── 6 : start (StartEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.638 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.638 [main] [INFO] 4 (process instance) └── 6 : start (StartEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.639 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.640 [main] [INFO] 4 (process instance) └── 6 : start -&gt; someTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.640 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.641 [main] [INFO] 4 (process instance) └── 6 : someTask (UserTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.715 [main] [INFO] task: {&quot;owner&quot;:null,&quot;assigneeUpdatedCount&quot;:0,&quot;originalAssignee&quot;:null,&quot;assignee&quot;:null,&quot;delegationState&quot;:null,&quot;parentTaskId&quot;:null,&quot;name&quot;:&quot;Activiti is awesome!&quot;,&quot;localizedName&quot;:null,&quot;description&quot;:&quot;some task my test message&quot;,&quot;localizedDescription&quot;:null,&quot;priority&quot;:50,&quot;createTime&quot;:&quot;Mon Dec 03 16:41:30 CST 2018&quot;,&quot;dueDate&quot;:null,&quot;suspensionState&quot;:1,&quot;category&quot;:null,&quot;isIdentityLinksInitialized&quot;:false,&quot;taskIdentityLinkEntities&quot;:[],&quot;executionId&quot;:&quot;6&quot;,&quot;execution&quot;:null,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;processInstance&quot;:null,&quot;processDefinitionId&quot;:&quot;my-process:1:3&quot;,&quot;taskDefinitionKey&quot;:&quot;someTask&quot;,&quot;formKey&quot;:null,&quot;isDeleted&quot;:false,&quot;isCanceled&quot;:false,&quot;eventName&quot;:null,&quot;currentActivitiListener&quot;:null,&quot;tenantId&quot;:&quot;&quot;,&quot;queryVariables&quot;:null,&quot;forcedUpdate&quot;:false,&quot;claimTime&quot;:null,&quot;variableInstances&quot;:null,&quot;usedVariablesCache&quot;:{},&quot;transientVariabes&quot;:null,&quot;cachedElContext&quot;:null,&quot;id&quot;:&quot;9&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.TaskServiceTest.testTaskServiceUser:69 16:41:30.715 [main] [INFO] task.description: some task my test message o.d.a.c.TaskServiceTest.testTaskServiceUser:70 16:41:30.739 [main] [INFO] identityLink: IdentityLinkEntity[id=10, type=candidate, userId=destiny, taskId=9] o.d.a.c.TaskServiceTest.testTaskServiceUser:94 16:41:30.740 [main] [INFO] identityLink: IdentityLinkEntity[id=12, type=candidate, userId=destiny1, taskId=9] o.d.a.c.TaskServiceTest.testTaskServiceUser:94 16:41:30.740 [main] [INFO] identityLink: IdentityLinkEntity[id=14, type=candidate, userId=destiny2, taskId=9] o.d.a.c.TaskServiceTest.testTaskServiceUser:94 16:41:30.740 [main] [INFO] identityLink: IdentityLinkEntity[id=null, type=assignee, userId=destiny, taskId=9] o.d.a.c.TaskServiceTest.testTaskServiceUser:94 16:41:30.740 [main] [INFO] identityLink: IdentityLinkEntity[id=null, type=owner, userId=user1, taskId=9] o.d.a.c.TaskServiceTest.testTaskServiceUser:94 16:41:30.749 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TriggerExecutionOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.751 [main] [INFO] 4 (process instance) └── 6 : someTask (UserTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.752 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.753 [main] [INFO] 4 (process instance) └── 6 : someTask (UserTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.754 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.754 [main] [INFO] 4 (process instance) └── 6 : someTask -&gt; end, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.755 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.755 [main] [INFO] 4 (process instance) └── 6 : end (EndEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.755 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.755 [main] [INFO] 4 (process instance) └── 6 : end (EndEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.757 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.EndExecutionOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 16:41:30.757 [main] [INFO] 4 (process instance) └── 6 : end (EndEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 16:41:30.770 [main] [INFO] 是否存在: true o.d.a.c.TaskServiceTest.testTaskServiceUser:106 5.3.2 TaskService 设置 Task 附加信息 任务附件(Attachment)创建与查询 任务评论(Comment)创建与查询 事件记录(Event)创建于查询 5.3.2.1 任务附件(Attachment)创建与查询流程定义同上 测试代码12345678910111213141516@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-task.bpmn20.xml"&#125;)public void testTaskAttachment() &#123; Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("message", "my test message"); activitiRule.getRuntimeService().startProcessInstanceByKey("my-process", variables); TaskService taskService = activitiRule.getTaskService(); Task task = taskService.createTaskQuery().singleResult(); // 可以上传数据流或 url Attachment attachment = taskService.createAttachment("url", task.getId(), task.getProcessInstanceId(), "name", "desc", "/url/test.png"); log.info("attachment: &#123;&#125;", attachment); List&lt;Attachment&gt; taskAttachments = taskService.getTaskAttachments(task.getId()); for (Attachment taskAttachment : taskAttachments) &#123; log.info("taskAttachment: &#123;&#125;", ToStringBuilder.reflectionToString(taskAttachment, ToStringStyle.JSON_STYLE)); &#125;&#125; 日志输出17:12:47.043 [main] [INFO] attachment: org.activiti.engine.impl.persistence.entity.AttachmentEntityImpl@72b16078 o.d.a.c.TaskServiceTest.testTaskAttachment:119 17:12:47.050 [main] [INFO] taskAttachment: {&quot;name&quot;:&quot;name&quot;,&quot;description&quot;:&quot;desc&quot;,&quot;type&quot;:&quot;url&quot;,&quot;taskId&quot;:&quot;9&quot;,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;url&quot;:&quot;/url/test.png&quot;,&quot;contentId&quot;:null,&quot;content&quot;:null,&quot;userId&quot;:null,&quot;time&quot;:&quot;Mon Dec 03 17:12:47 CST 2018&quot;,&quot;id&quot;:&quot;16&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.TaskServiceTest.testTaskAttachment:122 5.3.2.2 任务评论(Comment)创建与查询流程定义同上 测试代码123456789101112131415161718192021@Test@Deployment(resources = &#123;"org/destiny/activiti/my-process-task.bpmn20.xml"&#125;)public void testTaskComment() &#123; Map&lt;String, Object&gt; variables = Maps.newHashMap(); variables.put("message", "my test message"); activitiRule.getRuntimeService().startProcessInstanceByKey("my-process", variables); TaskService taskService = activitiRule.getTaskService(); Task task = taskService.createTaskQuery().singleResult(); // 添加评论 taskService.addComment(task.getId(), task.getProcessInstanceId(), "record note1"); taskService.addComment(task.getId(), task.getProcessInstanceId(), "record note2"); List&lt;Comment&gt; taskComments = taskService.getTaskComments(task.getId()); for (Comment taskComment : taskComments) &#123; log.info("taskComment: &#123;&#125;", ToStringBuilder.reflectionToString(taskComment, ToStringStyle.JSON_STYLE)); &#125; // 事件记录 List&lt;Event&gt; taskEvents = taskService.getTaskEvents(task.getId()); for (Event taskEvent : taskEvents) &#123; log.info("taskEvent: &#123;&#125;", ToStringBuilder.reflectionToString(taskEvent, ToStringStyle.JSON_STYLE)); &#125;&#125; 日志输出17:05:17.107 [main] [INFO] taskComment: {&quot;type&quot;:&quot;comment&quot;,&quot;userId&quot;:null,&quot;time&quot;:&quot;Mon Dec 03 17:05:17 CST 2018&quot;,&quot;taskId&quot;:&quot;9&quot;,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;action&quot;:&quot;AddComment&quot;,&quot;message&quot;:&quot;record note2&quot;,&quot;fullMessage&quot;:&quot;record note2&quot;,&quot;id&quot;:&quot;17&quot;,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.TaskServiceTest.testTaskComment:140 17:05:17.107 [main] [INFO] taskComment: {&quot;type&quot;:&quot;comment&quot;,&quot;userId&quot;:null,&quot;time&quot;:&quot;Mon Dec 03 17:05:17 CST 2018&quot;,&quot;taskId&quot;:&quot;9&quot;,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;action&quot;:&quot;AddComment&quot;,&quot;message&quot;:&quot;record note1&quot;,&quot;fullMessage&quot;:&quot;record note1&quot;,&quot;id&quot;:&quot;16&quot;,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.TaskServiceTest.testTaskComment:140 17:05:17.109 [main] [INFO] taskEvent: {&quot;type&quot;:&quot;comment&quot;,&quot;userId&quot;:null,&quot;time&quot;:&quot;Mon Dec 03 17:05:17 CST 2018&quot;,&quot;taskId&quot;:&quot;9&quot;,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;action&quot;:&quot;AddComment&quot;,&quot;message&quot;:&quot;record note2&quot;,&quot;fullMessage&quot;:&quot;record note2&quot;,&quot;id&quot;:&quot;17&quot;,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.TaskServiceTest.testTaskComment:146 17:05:17.110 [main] [INFO] taskEvent: {&quot;type&quot;:&quot;comment&quot;,&quot;userId&quot;:null,&quot;time&quot;:&quot;Mon Dec 03 17:05:17 CST 2018&quot;,&quot;taskId&quot;:&quot;9&quot;,&quot;processInstanceId&quot;:&quot;4&quot;,&quot;action&quot;:&quot;AddComment&quot;,&quot;message&quot;:&quot;record note1&quot;,&quot;fullMessage&quot;:&quot;record note1&quot;,&quot;id&quot;:&quot;16&quot;,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.TaskServiceTest.testTaskComment:146 Comment 和 Event 的区别所有对 task 的操作都会生成新的 Event 记录, comment 只是其中的一种, 比如在上例中新增 owner 或 assignee, 也会产生新的 event 记录 5.4 身份管理服务 Activiti 提供了相对比较简单的用户/用户组管理 主要功能: 管理用户(User) 管理用户组(Group) 用户与用户组的关系(Membership)(多对多关系) 5.4.1 创建用户/用户组/对应关系流程定义 此处不需要基于流程定义完成 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142@Slf4jpublic class IdentityServiceTest &#123; @Rule public ActivitiRule activitiRule = new ActivitiRule(); @Test public void testIdentity() &#123; IdentityService identityService = activitiRule.getIdentityService(); User user1 = identityService.newUser("user1"); user1.setEmail("destinywk@163.com"); User user2 = identityService.newUser("user2"); user2.setEmail("destinywk@126.com"); identityService.saveUser(user1); identityService.saveUser(user2); Group group1 = identityService.newGroup("group1"); identityService.saveGroup(group1); Group group2 = identityService.newGroup("group2"); identityService.saveGroup(group2); // 创建关系 identityService.createMembership("user1", "group1"); identityService.createMembership("user2", "group1"); identityService.createMembership("user1", "group2"); List&lt;User&gt; userList = identityService.createUserQuery() .memberOfGroup("group1") .listPage(0, 100); for (User user : userList) &#123; log.info("user: &#123;&#125;", ToStringBuilder.reflectionToString(user, ToStringStyle.JSON_STYLE)); &#125; List&lt;Group&gt; groupList = identityService.createGroupQuery() .groupMember("user1").listPage(0, 100); for (Group group : groupList) &#123; log.info("group: &#123;&#125;", ToStringBuilder.reflectionToString(group, ToStringStyle.JSON_STYLE)); &#125; &#125;&#125; 日志输出17:37:12.982 [main] [INFO] Loading XML bean definitions from class path resource [activiti.cfg.xml] o.s.b.f.x.XmlBeanDefinitionReader.loadBeanDefinitions:316 17:37:14.894 [main] [INFO] Activiti 5 compatibility handler implementation not found or error during instantiation : org.activiti.compatibility.DefaultActiviti5CompatibilityHandler. Activiti 5 backwards compatibility disabled. o.a.e.c.DefaultActiviti5CompatibilityHandlerFactory.createActiviti5CompatibilityHandler:38 17:37:14.910 [main] [INFO] performing create on engine with resource org/activiti/db/create/activiti.h2.create.engine.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 17:37:14.971 [main] [INFO] performing create on history with resource org/activiti/db/create/activiti.h2.create.history.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 17:37:14.978 [main] [INFO] performing create on identity with resource org/activiti/db/create/activiti.h2.create.identity.sql o.a.e.i.d.DbSqlSession.executeSchemaResource:1147 17:37:14.982 [main] [INFO] ProcessEngine default created o.a.e.i.ProcessEngineImpl.&lt;init&gt;:87 17:37:15.041 [main] [INFO] user: {&quot;firstName&quot;:null,&quot;lastName&quot;:null,&quot;email&quot;:&quot;destinywk@163.com&quot;,&quot;password&quot;:null,&quot;pictureByteArrayRef&quot;:&quot;ByteArrayRef[id=null, name=null, entity=null]&quot;,&quot;id&quot;:&quot;user1&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.IdentityServiceTest.testIdentity:46 17:37:15.042 [main] [INFO] user: {&quot;firstName&quot;:null,&quot;lastName&quot;:null,&quot;email&quot;:&quot;destinywk@126.com&quot;,&quot;password&quot;:null,&quot;pictureByteArrayRef&quot;:&quot;ByteArrayRef[id=null, name=null, entity=null]&quot;,&quot;id&quot;:&quot;user2&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.IdentityServiceTest.testIdentity:46 17:37:15.048 [main] [INFO] group: {&quot;name&quot;:null,&quot;type&quot;:null,&quot;id&quot;:&quot;group1&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.IdentityServiceTest.testIdentity:52 17:37:15.048 [main] [INFO] group: {&quot;name&quot;:null,&quot;type&quot;:null,&quot;id&quot;:&quot;group2&quot;,&quot;revision&quot;:1,&quot;isInserted&quot;:false,&quot;isUpdated&quot;:false,&quot;isDeleted&quot;:false} o.d.a.c.IdentityServiceTest.testIdentity:52 身份管理服务的调用过程: 会将 User 封装成一个 Command, 交由命令执行器去执行, 最后调用 MyBatis 底层接口去操作 DB 5.5 表单管理服务 FormService功能: 解析流程定义中表单项的配置 提供提交表单的方式驱动用户节点流转 获取自定义外部表单 key 5.5.1流程定义123456789101112131415161718192021222324&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" typeLanguage="http://www.w3.org/2001/XMLSchema" expressionLanguage="http://www.w3.org/1999/XPath" targetNamespace="http://www.activiti.org/test"&gt; &lt;process id="my-process"&gt; &lt;startEvent id="start" activiti:formKey="/rest/process/form/start"&gt; &lt;!-- 配置表单项 --&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="message" name="信息" type="string" required="true"/&gt; &lt;/extensionElements&gt; &lt;/startEvent&gt; &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="someTask"/&gt; &lt;userTask id="someTask" name="Activiti is awesome!" activiti:formKey="/rest/process/form/userTask"&gt; &lt;extensionElements&gt; &lt;!-- 配置表单项 --&gt; &lt;activiti:formProperty id="yesOrNo" name="审批" type="string" required="true"/&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;sequenceFlow id="flow2" sourceRef="someTask" targetRef="end"/&gt; &lt;endEvent id="end"/&gt; &lt;/process&gt;&lt;/definitions&gt; 测试代码1234567891011121314151617181920212223242526272829303132333435363738@Slf4jpublic class FormServiceTest &#123; @Rule public ActivitiRule activitiRule = new ActivitiRule(); @Test @Deployment(resources = &#123;"org/destiny/activiti/my-process-form.bpmn20.xml"&#125;) public void testFormService() &#123; FormService formService = activitiRule.getFormService(); // 获取流程定义文件 ProcessDefinition processDefinition = activitiRule.getRepositoryService().createProcessDefinitionQuery().singleResult(); // 获取 startForm 的 key 和 data String startFormKey = formService.getStartFormKey(processDefinition.getId()); log.info("startFormKey: &#123;&#125;", startFormKey); StartFormData startFormData = formService.getStartFormData(processDefinition.getId()); log.info("startFormKey: &#123;&#125;", ToStringBuilder.reflectionToString(startFormData, ToStringStyle.JSON_STYLE)); for (FormProperty startFormProperty : startFormData.getFormProperties()) &#123; log.info("startFormProperty: &#123;&#125;", ToStringBuilder.reflectionToString(startFormProperty, ToStringStyle.JSON_STYLE)); &#125; // 启动流程 Map&lt;String, String&gt; properties = Maps.newHashMap(); properties.put("message", "my test message"); formService.submitStartFormData(processDefinition.getId(), properties); // 查询 task Task task = activitiRule.getTaskService().createTaskQuery().singleResult(); // 获取 taskForm 的 data TaskFormData taskFormData = formService.getTaskFormData(task.getId()); log.info("taskFormData: &#123;&#125;", ToStringBuilder.reflectionToString(taskFormData, ToStringStyle.JSON_STYLE)); for (FormProperty taskFormProperty : taskFormData.getFormProperties()) &#123; log.info("taskFormProperty: &#123;&#125;", ToStringBuilder.reflectionToString(taskFormProperty, ToStringStyle.JSON_STYLE)); &#125; &#125;&#125; 日志输出18:15:27.539 [main] [INFO] startFormKey: /rest/process/form/start o.d.a.c.FormServiceTest.testFormService:36 18:15:27.547 [main] [INFO] startFormKey: {&quot;processDefinition&quot;:&quot;ProcessDefinitionEntity[my-process:1:3]&quot;,&quot;formKey&quot;:&quot;/rest/process/form/start&quot;,&quot;deploymentId&quot;:&quot;1&quot;,&quot;formProperties&quot;:[org.activiti.engine.impl.form.FormPropertyImpl@3bde62ff]} o.d.a.c.FormServiceTest.testFormService:38 18:15:27.547 [main] [INFO] startFormProperty: {&quot;id&quot;:&quot;message&quot;,&quot;name&quot;:&quot;信息&quot;,&quot;type&quot;:&quot;org.activiti.engine.impl.form.StringFormType@2baa8d82&quot;,&quot;isRequired&quot;:true,&quot;isReadable&quot;:true,&quot;isWritable&quot;:true,&quot;value&quot;:null} o.d.a.c.FormServiceTest.testFormService:40 18:15:27.561 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 18:15:27.564 [main] [INFO] 4 (process instance) └── 5 : start (StartEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 18:15:27.565 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.TakeOutgoingSequenceFlowsOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 18:15:27.566 [main] [INFO] 4 (process instance) └── 5 : start (StartEvent, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 18:15:27.567 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 18:15:27.567 [main] [INFO] 4 (process instance) └── 5 : start -&gt; someTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 18:15:27.568 [main] [INFO] Execution tree while executing operation class org.activiti.engine.impl.agenda.ContinueProcessOperation : o.a.e.i.i.DebugCommandInvoker.executeOperation:33 18:15:27.568 [main] [INFO] 4 (process instance) └── 5 : someTask (UserTask, parent id 4 (active) o.a.e.i.i.DebugCommandInvoker.executeOperation:34 18:15:27.602 [main] [INFO] taskFormData: {&quot;task&quot;:&quot;Task[id=10, name=Activiti is awesome!]&quot;,&quot;formKey&quot;:&quot;/rest/process/form/userTask&quot;,&quot;deploymentId&quot;:&quot;1&quot;,&quot;formProperties&quot;:[org.activiti.engine.impl.form.FormPropertyImpl@4e4efc1b]} o.d.a.c.FormServiceTest.testFormService:53 18:15:27.602 [main] [INFO] taskFormProperty: {&quot;id&quot;:&quot;yesOrNo&quot;,&quot;name&quot;:&quot;审批&quot;,&quot;type&quot;:&quot;org.activiti.engine.impl.form.StringFormType@2baa8d82&quot;,&quot;isRequired&quot;:true,&quot;isReadable&quot;:true,&quot;isWritable&quot;:true,&quot;value&quot;:null} o.d.a.c.FormServiceTest.testFormService:55 5.6 HistoryService 历史数据管理服务作用: 管理流程实例哦结束后的历史数据 构建历史数据的查询对象 根据流程实例 id 删除流程历史数据 历史数据实体 描述 HistoricProcessInstance 历史流程实例实体类 HistoricVariableInstance 流程或任务变量值的实体 HistoricActivityInstance 单个活动节点执行的信息 HistoricTaskInstance 用户任务实例的信息 HistoricDetail 历史流程活动任务详细信息 HistoryService 构建历史查询对象: create[历史数据实体]Query createNative[历史数据实体]Query createProcessInstanceHistoryLogQuery: 只能查出一个流程实例的一个对象, 每次只能查出一条记录, 包含流程实体所有的其他数据, 包括task, Activiti, comment 等信息 HistoryService 删除历史操作 deleteHistoricProcessInstance, 采用级联操作, 删除与流程实例相关的所有历史信息 deleteHistoricTaskInstance, 范围相对较小, 只删除 Task 及 Task 相关的变量 5.7 ManagementService 管理服务作用: Job 任务管理 数据库相关通用操作 执行流程引擎命令(Command) 5.7.1 Job 任务管理 工作查询对象 描述 JobQuery 查询一般工作 TimerJobQuery 查询定时任务 SuspendedKobQUery 查询中断工作 DeadLetterJobQuery 查询无法执行的工作(一般重试三次) 5.7.2 数据库相关操作 查询表结构元数据 通用表查询 执行自定义的 sql 查询 5.8 DynamicBpmnService 动态流程定义服务 不推荐使用 6 数据库设计和模型映射 数据表分类 描述 ACT_GE_* 通用数据表 ACT_RE_* 流程定义存储表 ACT_ID_* 身份信息表 ACT_RU_* 运行时数据库表 ACT_HI_* 历史数据库表 6.1 MySql 建表语句 除了核心引擎是必选的, 其他两个不是必须的 核心引擎: activiti.mysql.create.engine.sql 历史数据: activiti.mysql.create.history.sql 身份信息: activiti.mysql.create.identity.sql 6.1.1 通用数据库 数据表分类 描述 ACT_GE_PROPERTY 属性表(保存流程引擎的 key-value 键值属性) ACT_GE_BYTEARRAY 资源表(存储流程定义相关的资源) 7 BPMN2.0 概述 是一套业务流程模型与符号建模标准 精准的执行语义来描述元素的操作 以 XML 为载体, 以符号可视化业务 BPMN2.0元素: 流对象 连接对象 数据 泳道 描述对象 7.1 流对象 活动(Activities): User Task, Service Task… 事件(Events): Start Event, End Event… 网关(Gateway): Exclusive Gateway… 8 Activiti 集成 Spring BootActiviti6.0 依赖的 SpringBoot 版本是 1.2.6 如果直接与 SpringBoot 2.0.0 集成的话, 会出现 ClassNotFound 等问题 因此在集成 SpringBoot 2.0.0 的时候, 需要 Activiti6.0 源码进行部分改动 升级 Activiti 6.0 依赖 SpringBoot 版本为 2.0.0 的改动 升级 SpringBoot 依赖并解决编译错误 更新 activiti-spring-boot-starter-basic 版本并安装 集成使用 Activiti 的 AutoConfiguration 功能 如果直接将 SpringBoot 2.0.0 和 activiti-spring-boot-starter-basic 6.0.0 集成, 会发生如下错误: java.lang.IllegalStateException: Failed to load ApplicationContext Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;documentationPluginsBootstrapper&apos; defined in URL [jar:file:/Users/destiny/.m2/repository/io/springfox/springfox-spring-web/2.8.0/springfox-spring-web-2.8.0.jar!/springfox/documentation/spring/web/plugins/DocumentationPluginsBootstrapper.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;webMvcRequestHandlerProvider&apos; defined in URL [jar:file:/Users/destiny/.m2/repository/io/springfox/springfox-spring-web/2.8.0/springfox-spring-web-2.8.0.jar!/springfox/documentation/spring/web/plugins/WebMvcRequestHandlerProvider.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;requestMappingHandlerMapping&apos; defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy ... Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;webMvcRequestHandlerProvider&apos; defined in URL [jar:file:/Users/destiny/.m2/repository/io/springfox/springfox-spring-web/2.8.0/springfox-spring-web-2.8.0.jar!/springfox/documentation/spring/web/plugins/WebMvcRequestHandlerProvider.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;requestMappingHandlerMapping&apos; defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy ... Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;requestMappingHandlerMapping&apos; defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy ... Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy ... 真正的原因是对应的类无法找到 8.1 修改 activiti 源码以适应 SpringBoot 2.0.0 版本升级8.1.1 将 activiti 中 SpringBoot 依赖升级到 2.0.0修改 Activiti 源码中 modules/activiti-spring-boot/pom.xml pom 文件, 将其中 1&lt;spring.boot.version&gt;1.2.6.RELEASE&lt;/spring.boot.version&gt; 修改为 1&lt;spring.boot.version&gt;2.0.0.RELEASE&lt;/spring.boot.version&gt; 然后重新编译源码, 此时以下几个类会报错 8.1.1.1 org.activiti.spring.boot.actuate.endpoint.ProcessEngineEndpoint 主要的问题是 SpringBoot 从 1 升级到 2 的时候, 对 EndPoint 的使用方式发生了改变:1.x 是继承一个抽象类 AbstractEndpoint2.x 修改为使用对应的注解 修改后的源码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package org.activiti.spring.boot.actuate.endpoint;import org.activiti.engine.ProcessEngine;import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;import org.activiti.engine.impl.persistence.deploy.DefaultDeploymentCache;import org.activiti.engine.impl.persistence.deploy.DeploymentCache;import org.activiti.engine.impl.persistence.deploy.ProcessDefinitionCacheEntry;import org.activiti.engine.repository.ProcessDefinition;import org.springframework.boot.actuate.endpoint.annotation.Endpoint;import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;import java.util.*;/** * Registers a Boot Actuator endpoint that provides information on the * running process instance and renders BPMN diagrams of the deployed processes. * * @author Josh Long *///@ConfigurationProperties(prefix = "endpoints.activiti")@Endpoint(id = "activiti") // 使用注解 Endpointpublic class ProcessEngineEndpoint &#123; // 不再继承 AbstractEndpoint private final ProcessEngine processEngine; public ProcessEngineEndpoint(ProcessEngine processEngine) &#123; this.processEngine = processEngine; // 不再继承 Endpoint, 因此不需要调用 super 构造方法 &#125; @ReadOperation // 不需要 @Override public Map&lt;String, Object&gt; activiti() &#123; Map&lt;String, Object&gt; metrics = new HashMap&lt;String, Object&gt;(); // Process definitions metrics.put("processDefinitionCount", processEngine.getRepositoryService().createProcessDefinitionQuery().count()); // List of all process definitions List&lt;ProcessDefinition&gt; processDefinitions = processEngine.getRepositoryService().createProcessDefinitionQuery().orderByProcessDefinitionKey().asc().list(); List&lt;String&gt; processDefinitionKeys = new ArrayList&lt;String&gt;(); for (ProcessDefinition processDefinition : processDefinitions) &#123; processDefinitionKeys.add(processDefinition.getKey() + " (v" + processDefinition.getVersion() + ")"); &#125; metrics.put("deployedProcessDefinitions", processDefinitionKeys); // Process instances Map&lt;String, Object&gt; processInstanceCountMap = new HashMap&lt;String, Object&gt;(); metrics.put("runningProcessInstanceCount", processInstanceCountMap); for (ProcessDefinition processDefinition : processDefinitions) &#123; processInstanceCountMap.put(processDefinition.getKey() + " (v" + processDefinition.getVersion() + ")", processEngine.getRuntimeService().createProcessInstanceQuery().processDefinitionId(processDefinition.getId()).count()); &#125; Map&lt;String, Object&gt; completedProcessInstanceCountMap = new HashMap&lt;String, Object&gt;(); metrics.put("completedProcessInstanceCount", completedProcessInstanceCountMap); for (ProcessDefinition processDefinition : processDefinitions) &#123; completedProcessInstanceCountMap.put(processDefinition.getKey() + " (v" + processDefinition.getVersion() + ")", processEngine.getHistoryService().createHistoricProcessInstanceQuery().finished().processDefinitionId(processDefinition.getId()).count()); &#125; // Open tasks metrics.put("openTaskCount", processEngine.getTaskService().createTaskQuery().count()); metrics.put("completedTaskCount", processEngine.getHistoryService().createHistoricTaskInstanceQuery().finished().count()); // Tasks completed today metrics.put("completedTaskCountToday", processEngine.getHistoryService().createHistoricTaskInstanceQuery().finished().taskCompletedAfter( new Date(System.currentTimeMillis() - secondsForDays(1))).count()); // Process steps metrics.put("completedActivities", processEngine.getHistoryService().createHistoricActivityInstanceQuery().finished().count()); // Process definition cache DeploymentCache&lt;ProcessDefinitionCacheEntry&gt; deploymentCache = ((ProcessEngineConfigurationImpl) processEngine.getProcessEngineConfiguration()).getProcessDefinitionCache(); if (deploymentCache instanceof DefaultDeploymentCache) &#123; metrics.put("cachedProcessDefinitionCount", ((DefaultDeploymentCache) deploymentCache).size()); &#125; return metrics; &#125; private long secondsForDays(int days) &#123; int hour = 60 * 60 * 1000; int day = 24 * hour; return days * day; &#125;&#125; 8.1.1.2 org.activiti.spring.boot.actuate.endpoint.ProcessEngineMvcEndpoint 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.activiti.spring.boot.actuate.endpoint;import java.io.InputStream;import org.activiti.bpmn.BpmnAutoLayout;import org.activiti.bpmn.model.BpmnModel;import org.activiti.engine.RepositoryService;import org.activiti.engine.repository.ProcessDefinition;import org.activiti.image.ProcessDiagramGenerator;import org.activiti.image.impl.DefaultProcessDiagramGenerator;import org.springframework.core.io.InputStreamResource;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;/** * Renders a valid running BPMN process definition as a BPMN diagram. * * This is duplicative of the functionality in the full REST API implementation. * * @author Joram Barrez * @author Josh Long */public class ProcessEngineMvcEndpoint &#123; // 同样不再继承 EndpointMvcAdapter private final RepositoryService repositoryService; private final ProcessEngineEndpoint processEngineEndpoint; // 创建一个 ProcessEngineEndpoint 私有变量 public ProcessEngineMvcEndpoint(ProcessEngineEndpoint processEngineEndpoint, RepositoryService repositoryService) &#123;// super(processEngineEndpoint); this.processEngineEndpoint = processEngineEndpoint; this.repositoryService = repositoryService; &#125; /** * Look up the process definition by key. For example, * this is &lt;A href="http://localhost:8080/activiti/processes/fulfillmentProcess"&gt;process-diagram for&lt;/A&gt; * a process definition named &#123;@code fulfillmentProcess&#125;. */ @RequestMapping(value = "/processes/&#123;processDefinitionKey:.*&#125;", method = RequestMethod.GET, produces = MediaType.IMAGE_JPEG_VALUE) @ResponseBody public ResponseEntity processDefinitionDiagram(@PathVariable String processDefinitionKey) &#123; ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery() .processDefinitionKey(processDefinitionKey) .latestVersion() .singleResult(); if (processDefinition == null) &#123; return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null); &#125; ProcessDiagramGenerator processDiagramGenerator = new DefaultProcessDiagramGenerator(); BpmnModel bpmnModel = repositoryService.getBpmnModel(processDefinition.getId()); if (bpmnModel.getLocationMap().size() == 0) &#123; BpmnAutoLayout autoLayout = new BpmnAutoLayout(bpmnModel); autoLayout.execute(); &#125; InputStream is = processDiagramGenerator.generateJpgDiagram(bpmnModel); return ResponseEntity.ok(new InputStreamResource(is)); &#125;&#125; 8.1.1.3 org.activiti.spring.boot.EndpointAutoConfiguration 报错原因: SpringBoot2 不再使用 AbstractEndpoint开启该表达式 AutoConfiguration 不会生效, 因此需要删除 1234567891011121314151617181920212223242526272829303132package org.activiti.spring.boot;import org.activiti.engine.ProcessEngine;import org.activiti.engine.RepositoryService;import org.activiti.spring.boot.actuate.endpoint.ProcessEngineEndpoint;import org.activiti.spring.boot.actuate.endpoint.ProcessEngineMvcEndpoint;//import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * The idea behind this module is that Spring Security could * talk to the &#123;@link org.activiti.engine.IdentityService&#125; * as required. * * @author Josh Long */@Configuration//@ConditionalOnClass (name = "org.springframework.boot.actuate.endpoint.AbstractEndpoint")public class EndpointAutoConfiguration &#123; @Bean public ProcessEngineEndpoint processEngineEndpoint(ProcessEngine engine) &#123; return new ProcessEngineEndpoint(engine); &#125; @Bean public ProcessEngineMvcEndpoint processEngineMvcEndpoint( ProcessEngineEndpoint engineEndpoint, RepositoryService repositoryService) &#123; return new ProcessEngineMvcEndpoint(engineEndpoint, repositoryService); &#125;&#125; 8.1.1.4 org.activiti.spring.boot.DataSourceProcessEngineAutoConfiguration 报错原因: ConditionalOnMissingClass 注解中的 name 已经不能使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.activiti.spring.boot;import java.io.IOException;import javax.sql.DataSource;import org.activiti.spring.SpringAsyncExecutor;import org.activiti.spring.SpringProcessEngineConfiguration;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;/** * @author Joram Barrez * @author Josh Long */@Configuration@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class DataSourceProcessEngineAutoConfiguration &#123; @Configuration// @ConditionalOnMissingClass(name= "javax.persistence.EntityManagerFactory") @ConditionalOnMissingClass(value= "javax.persistence.EntityManagerFactory") // 将 name 替换为 value @EnableConfigurationProperties(ActivitiProperties.class) public static class DataSourceProcessEngineConfiguration extends AbstractProcessEngineAutoConfiguration &#123; @Bean @ConditionalOnMissingBean public PlatformTransactionManager transactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean @ConditionalOnMissingBean public SpringProcessEngineConfiguration springProcessEngineConfiguration( DataSource dataSource, PlatformTransactionManager transactionManager, SpringAsyncExecutor springAsyncExecutor) throws IOException &#123; return this.baseSpringProcessEngineConfiguration(dataSource, transactionManager, springAsyncExecutor); &#125; &#125;&#125; 8.1.1.4 org.activiti.spring.boot.SecurityAutoConfiguration 报错原因: 包结构发生改变, 导致原有的类全路径不可用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import org.activiti.engine.IdentityService;import org.activiti.rest.security.BasicAuthenticationProvider;import org.activiti.spring.security.IdentityServiceUserDetailsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.AutoConfigureBefore;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationProvider;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;/** * Installs a Spring Security adapter for the Activiti * &#123;@link org.activiti.engine.IdentityService&#125;. * * @author Josh Long */@Configuration//@AutoConfigureBefore(org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration.class)@AutoConfigureBefore(org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class) // 修改类路径public class SecurityAutoConfiguration &#123; @Configuration @ConditionalOnClass( UserDetailsService.class) public static class UserDetailsServiceConfiguration extends GlobalAuthenticationConfigurerAdapter &#123; @Override public void init(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService( userDetailsService()); &#125; @Bean public UserDetailsService userDetailsService() &#123; return new IdentityServiceUserDetailsService(this.identityService); &#125; @Autowired private IdentityService identityService; &#125; @Configuration @ConditionalOnClass(name = &#123;"org.activiti.rest.service.api.RestUrls", "org.springframework.web.servlet.DispatcherServlet"&#125;) @EnableWebSecurity public static class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Bean public AuthenticationProvider authenticationProvider() &#123; return new BasicAuthenticationProvider(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authenticationProvider(authenticationProvider()) .csrf().disable() .authorizeRequests() .anyRequest().authenticated() .and() .httpBasic(); &#125; &#125;&#125; 8.2 对 Activiti 版本做更改12345678910111213141516171819&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;activiti-spring-boot-starter-basic&lt;/artifactId&gt; &lt;!-- 在此处新增版本 --&gt; &lt;version&gt;6.0.0-boot2&lt;/version&gt; &lt;!-- &lt;properties&gt; &lt;spring.framework.version&gt;4.1.4.RELEASE&lt;/spring.framework.version&gt; &lt;/properties&gt; --&gt; ...&lt;/project&gt; 尝试执行 mvn clean install 此时 maven 会去尝试下载 6.0.0-boot2 版本, 但显然公网仓库中不会存在 [INFO] Scanning for projects... [INFO] [INFO] ----------&lt; org.activiti:activiti-spring-boot-starter-basic &gt;----------- [INFO] Building activiti-spring-boot-starter-basic 6.0.0-boot2 [INFO] --------------------------------[ jar ]--------------------------------- [WARNING] The POM for org.activiti:activiti-engine:jar:6.0.0-boot2 is missing, no dependency information available [WARNING] The POM for org.activiti:activiti-spring:jar:6.0.0-boot2 is missing, no dependency information available [WARNING] The POM for org.activiti:activiti-rest:jar:6.0.0-boot2 is missing, no dependency information available [WARNING] The POM for org.activiti:activiti-common-rest:jar:6.0.0-boot2 is missing, no dependency information available [WARNING] The POM for org.activiti:activiti-image-generator:jar:6.0.0-boot2 is missing, no dependency information available [WARNING] The POM for org.activiti:activiti-bpmn-model:jar:6.0.0-boot2 is missing, no dependency information available [WARNING] The POM for org.activiti:activiti-bpmn-layout:jar:6.0.0-boot2 is missing, no dependency information available [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 0.850 s [INFO] Finished at: 2018-12-03T23:15:57+08:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal on project activiti-spring-boot-starter-basic: Could not resolve dependencies for project org.activiti:activiti-spring-boot-starter-basic:jar:6.0.0-boot2: The following artifacts could not be resolved: org.activiti:activiti-engine:jar:6.0.0-boot2, org.activiti:activiti-spring:jar:6.0.0-boot2, org.activiti:activiti-rest:jar:6.0.0-boot2, org.activiti:activiti-common-rest:jar:6.0.0-boot2, org.activiti:activiti-image-generator:jar:6.0.0-boot2, org.activiti:activiti-bpmn-model:jar:6.0.0-boot2, org.activiti:activiti-bpmn-layout:jar:6.0.0-boot2: Failure to find org.activiti:activiti-engine:jar:6.0.0-boot2 in http://maven.aliyun.com/nexus/content/groups/public was cached in the local repository, resolution will not be reattempted until the update interval of nexus-aliyun has elapsed or updates are forced -&gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/DependencyResolutionException 错误原因: activiti-spring-boot-starter-basic 的版本号被修改为 6.0.0-boot2, 但安装的时候, 对应的 activiti-engine 版本只有 6.0.0, 并没有 6.0.0-boot2可以将所有需要找 6.0.0-boot2 的版本修改为去找 6.0.0 将根 pom 中所有的 ${project.version} 修改为 6.0.0]]></content>
      <categories>
        <category>Activiti</category>
        <category>Java</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java逃逸分析]]></title>
    <url>%2Fblog%2F2018%2F09%2F07%2FJava%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 逃逸概念的引入 我们都知道, Java 创建的对象都是被分配到堆内存上, 但是事实并不是这么绝对, 通过对Java对象分配的过程分析, 可以知道有两个地方会导致 Java 中创建出来的对象并不一定分别在所认为的堆上. 这两个点分别是 Java 中的 逃逸分析 和 TLAB(Thread Local Allocation Buffer)线程私有的缓存区。 2. 逃逸分析基本概念逃逸分析, 是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法. 通过逃逸分析, Hotspot编译器 能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上. 在计算机语言编译器优化原理中, 逃逸分析是指分析指针动态范围的方法, 它同编译器优化原理的指针分析和外形分析相关联. 当变量(或者对象)在方法中分配后, 其指针有可能被返回或者被全局引用, 这样就会被其他过程或者线程所引用, 这种现象称作指针(或者引用)的 逃逸(Escape) . 通俗点讲, 如果一个对象的指针被多个方法或者线程引用时, 那么我们就称这个对象的指针发生了逃逸. 2.1. 具体分析逃逸分析研究对于 java 编译器有什么好处呢? 我们知道 java 对象总是在堆中被分配的, 因此 java 对象的创建和回收对系统的开销是很大的. java 语言被批评的一个地方, 也是认为 java 性能慢的一个原因就是 java 不支持栈上分配对象, JDK6里的 Swing 内存和性能消耗的瓶颈就是由于 GC 来遍历引用树并回收内存的, 如果对象的数目比较多, 将给 GC 带来较大的压力, 也间接得影响了性能. 减少临时对象在堆内分配的数量, 无疑是最有效的优化方法. java 中应用里普遍存在一种场景, 一般是在方法体内, 声明了一个局部变量, 并且该变量在方法执行生命周期内未发生逃逸, 按照 JVM 内存分配机制, 首先会在堆内存上创建类的实例(对象), 然后将此对象的引用压入调用栈, 继续执行, 这是 JVM 优化前的方式. 当然, 我们可以采用逃逸分析对 JVM 进行优化, 即针对栈的重新分配方式, 首先我们需要分析并且找到未逃逸的变量, 将该变量类的实例化内存直接在栈里分配, 无需进入堆, 分配完成之后, 继续调用栈内执行, 最后线程执行结束, 栈空间被回收, 局部变量对象也被回收, 通过这种方式的优化, 与优化前的方案主要区别在于对象的存储介质, 优化前是在堆中, 而优化后的是在栈中, 从而减少了堆中临时对象的分配(较耗时), 最终完成性能的优化. 逃逸分析实际上是 JVM 的一种为优化提供支持的分析手段, 逃逸分析的范围分为两个, 方法逃逸和线程逃逸 2.2.1 方法逃逸 不逃逸出当前方法, 就是说在一个方法内 new 出来的对象, 它的引用没有泄露到这个方法之外123456789101112131415public class Foo &#123; int a; int b; public Foo() &#123; &#125;&#125;public int bar(int a, int b) &#123; Foo foo = new Foo(); foo.a = a; foo.b = b; // foo 对象没有逃逸出 bar 方法, 只在 bar 方法里当做局部变量存在 return foo.a + foo.b;&#125; 在上面的例子中, Foo 对象就没有逃逸出 bar 方法, 只有一个局部 foo 变量引用这个对象, foo 变量既没有被当做返回值, 也没有当做另一个方法的参数. 但其实我们一般写的普通 Java Bean 都会有 getter /setter 1234567891011121314151617public class Foo &#123; int a; int b; public Foo(int a, int b) &#123; this.a = a; this.b = b; &#125; public int getA() &#123; return a; &#125; public int getB() &#123; return b; &#125;&#125; 如果在 bar() 方法里依然给 Foo 实例对象赋值, 那肯定就会调用到 Foo 的成员方法 setA(), setB(), 把局部变量 foo 的 this 作为参数传递给 foo 的成员方法, 这个时候变量 foo 确实逃逸除了 bar 方法, 而 JIT 提供了 方法内联, 在完成方法内联后, 这个参数传递实际上优化掉了. 2.2.2 线程逃逸 不逃逸出当前线程, 指的是实例对象没有被别的类引用到. 该对象的引用赋值到其他对象的字段, 或其他类的静态字段上, 没办法让它进入一个全局可见的范围, 这个时候我们认为该实例没有逃逸出当前线程 12345678910public int bar(int a, int b) &#123; Foo foo = new Foo(); foo.a = a; foo.b = b; return doBar(foo);&#125;public int doBar(Foo foo) &#123; return foo.a + foo.b;&#125; bar() 方法调用了 doBar(), 把 foo 实例作为入参传入了 doBar(), 这个时候认为 foo 逃逸除了 bar 方法, 但是 bar 和 doBar 都在一个类中, 并没有被其他类引用, 我们认为 foo 对象没有逃逸出线程. 2.3. JVM 为逃逸分析所做的优化2.3.1 标量替换 Java 中标量的意思是不能再分割的量, 如基本类型和 Reference 类型, 反之成为聚合量, 如果把一个对象拆开, 将它的成员变量分割成标量, 这个就叫标量替换. 如果逃逸分析发现一个对象不会被外部访问, 并且该对象可以被拆散, 那么经过优化后, 并不直接生成该对象, 而是在栈上创建若干个成员变量, 原本的对象就无需再堆上整体分配空间了. 栈帧内分配对象的行为成为栈上分配, 目的是减少新生代的 GC 频率, 见解提高 JVM 性能, 通过 -XX+EliminateAllcations 可以开启标量替换. 2.3.2 锁消除优化 Java 方法中返回值如果没有被其他类用到, 那这个对象就不会逃逸出线程, 我们知道变量的读写竞争的时候需要加锁访问, 如果确定该变量不会逃逸出该线程, 那同步访问控制就可以优化掉. 2.4 实操12345678910111213141516171819public class User &#123; private Sting name; private int age; // getters / setters / constructors&#125;public int bar(Foo foo) &#123; User user = new User(23); return foo.getA() + foo.getB() + user.getAge();&#125;public static void main(String[] args) &#123; Foo foo = new Foo(); for(int i = 0; i &lt; 1000000000; ++i) &#123; foo.setA(4); foo.setB(45); &#125;&#125; 2.4.1 关闭逃逸分析启动 JVM 参数 -server -XX:-DoEscapeAnalysis 使用 jmap -histo 2.4.2 打开逃逸分析JVM 参数 -server -XX:+DoEscapeAnalysis 可以看到, 只有少量的对象在堆上实例化, 大部分对象的属性被标量替换了. 3. JIT 编译在 JVM 中触发 JIT 编译是基于两个计数器: 一个方法被调用的次数 存在有分支的方法中的循环次数, 如果方法里面有一个很长的循环, 这时候需要编译到这个循环, 每一次分支的循环被调用, 该分支的计数器都会增加 增加 -XX:+PrintCompileation 参数观察 JVM 输出的编译日志 - 96 1 3 java.lang.String::equals (81 bytes) 96 4 3 java.io.UnixFileSystem::normalize (75 bytes) 97 9 3 java.lang.String::hashCode (55 bytes) 97 8 3 java.lang.Object::&lt;init&gt; (1 bytes) 97 7 3 java.lang.AbstractStringBuilder::ensureCapacityInternal (16 bytes) 98 3 3 java.lang.String::length (6 bytes) 98 10 3 java.lang.Math::min (11 bytes) 98 2 3 java.lang.System::getSecurityManager (4 bytes) 98 6 3 java.util.Arrays::copyOf (19 bytes) 98 11 n 0 java.lang.System::arraycopy (native) (static) 98 12 3 java.lang.String::indexOf (70 bytes) 98 15 3 sun.nio.cs.UTF_8$Encoder::encode (359 bytes) 99 13 4 java.lang.String::charAt (29 bytes) 99 16 3 java.lang.String::lastIndexOf (52 bytes) 99 5 3 java.util.HashMap::hash (20 bytes) 100 18 3 java.lang.String::&lt;init&gt; (82 bytes) 100 14 3 java.lang.StringBuilder::toString (17 bytes) 100 19 3 java.lang.String::startsWith (72 bytes) 100 20 1 java.util.ArrayList::size (5 bytes) 100 17 1 java.lang.ref.Reference::get (5 bytes) 101 21 1 sun.instrument.TransformerManager::getSnapshotTransformerList (5 bytes) 101 22 3 java.lang.String::startsWith (7 bytes) 101 23 3 java.lang.String::indexOf (166 bytes) 102 26 1 java.lang.Object::&lt;init&gt; (1 bytes) 102 8 3 java.lang.Object::&lt;init&gt; (1 bytes) made not entrant 102 30 3 org.destiny.demo.Foo::setA (6 bytes) 102 31 3 org.destiny.demo.Foo::setB (6 bytes) 102 32 3 org.destiny.demo.User::bar (25 bytes) 102 33 3 org.destiny.demo.User::&lt;init&gt; (10 bytes) 103 34 1 org.destiny.demo.Foo::setA (6 bytes) 103 30 3 org.destiny.demo.Foo::setA (6 bytes) made not entrant 103 35 1 org.destiny.demo.Foo::setB (6 bytes) 103 31 3 org.destiny.demo.Foo::setB (6 bytes) made not entrant 103 27 1 org.destiny.demo.Foo::getA (5 bytes) 103 28 1 org.destiny.demo.Foo::getB (5 bytes) 103 29 1 org.destiny.demo.User::getAge (5 bytes) 103 24 3 java.lang.String::endsWith (17 bytes) 103 36 4 org.destiny.demo.User::bar (25 bytes) 103 25 3 java.lang.ref.SoftReference::get (29 bytes) 104 32 3 org.destiny.demo.User::bar (25 bytes) made not entrant 104 37 1 java.lang.ThreadLocal::access$400 (5 bytes) 106 38 3 java.lang.String::indexOf (7 bytes) 106 39 3 java.lang.Character::toLowerCase (9 bytes) 106 40 3 java.lang.CharacterDataLatin1::toLowerCase (39 bytes) 108 41 % 3 org.destiny.demo.User::main @ 18 (48 bytes) 108 42 3 org.destiny.demo.User::main (48 bytes) 109 43 % 4 org.destiny.demo.User::main @ 18 (48 bytes) 112 41 % 3 org.destiny.demo.User::main @ -2 (48 bytes) made not entrant 150 43 % 4 org.destiny.demo.User::main @ -2 (48 bytes) made not entrant 编译日志分为 7 列, 依次是 时间(基于 JVM 启动的时间戳) 编译任务 id(基本递增) 编译属性 tiered_level(分为 4 级) 方法信息 占用字节数 deopt 其中, 编译属性 attribute 分为: 属性值 属性描述 % The compilation is OSR s The method is synchronized ! The method has an exception handler b Compliation occurred in blocking mode n Compliation occurred for a wrapper to a native method tiered_level: 值 描述 0 Interpreted Code 1 Simple C1 Compiled Code 2 Limited C1 Compiled Code 3 Full C1 Compiled Code 4 C2 Compile Code]]></content>
      <categories>
        <category>JVM</category>
        <category>逃逸分析</category>
      </categories>
      <tags>
        <tag>逃逸分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式事务总结]]></title>
    <url>%2Fblog%2F2018%2F09%2F02%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 定义事务能够提供一种将一个活动涉及到的所有操作纳入到一个不可分割的执行单元的机制. 组成事务的操作只有在操作均能正常执行的情况下才能提交, 只要其中任意一步执行失败, 都将导致整个操作回滚. 2. 数据库本地事务2.1 ACID 特性 描述 原子性 一个事务的所有操作, 要么全部完成, 要么全部不完成, 不会结束在中间某个环节 一致性 在一个事务执行之前和执行之后, 数据库必须保持处于一致的状态. 如果事务成功执行, 系统中所有的变化都将正确地被应用, 反之, 所有变化都将被回滚 隔离性 当不同的事务操作相同的数据的时候, 每个事务都有各自的完整数据空间, 由事务所做的修改必须与任何其他事务所做的修改隔离, 事务不会看到数据的中间状态. 持久性 只要事务成功结束, 它对数据库所做的更新就必须永久保存下来 而事务的 ACID 是通过 InnoDB 日志和锁来保证. 事务的隔离性是通过数据库锁的机制来实现; 持久性是通过 redo log(重做日志) 来实现的 原子性和一致性是通过 undo log(回滚日志) Undo log: 为了满足事务的原子性, 在操作任何数据之前, 首先将数据备份到一个地方, 然后对数据进行修改, 如果出现了错误, 或者用户执行 RollBack, 系统可以利用 Undo log 中的备份将数据恢复到事务开始之前的状态 Redo log: 记录新数据的备份, 在事务提交之前, 只要将 Redo log 持久化即可, 当系统崩溃时, 虽然数据没有持久化, 但是 Redo log 已经持久化, 系统可以根据 Redo log 的内容, 将所有数据恢复到最新状态. 3. 分布式事务3.1 分布式事务概念指事物的参与者, 支持事务的服务器, 资源服务器以及事务管理器分别位于不同的分布式系统之上. 本质上讲, 分布式事务就是为了保证不同数据库的数据一致性. 3.2 场景3.2.1 service 多个节点 随着互联网快速发展, SOA, 微服务等架构模式正在被大规模使用, 一个公司内, 用户的资产可能被分为好多个部分, 比如余额, 积分, 优惠券等 这样的话传统的单机事务实现方式无法保证积分扣减成功之后, 优惠券也能正确完成扣减操作. 3.2.2 resource 多个节点 同样, 由于单表数据过大需要进行拆分, 一次转账业务需要在北京的 MySQL 实例向 上海的 MySQL 实例转账, 同样无法保证他们能同时成功. 3.3 分布式事务基础3.3.1 CAP C: 对某个执行的客户端来说, 读操作能返回最新的写操作. 对于数据分布在不同节点上的数据来说, 如果在某个节点更新了数据, 那么在其他节点都能读取到最新的数据, 那么就成为强一致, 反之就是分布式不一致; A: 非故障的节点在一定时间内返回合理的响应(不是错误或超时), 可用性的关键在于: 合理的时间 和 合理的响应, 请求不能无限期得不到响应, 并且需要得到系统正确的返回结果; P: 当出现网络分区后, 系统依然能够正常工作. 在分布式系统中, 网络永远无法 100% 可靠, 分区是一个一定会出现的情况, 如果我们选择 AC 而放弃 P, 当分区发生时, 为了保证一致性, 这个时候必须拒绝请求, 当时 A 又不允许拒绝, 所以分布式系统理论上不可能选择 CA 架构, 只能选择 CP 或者 AP 架构. 对于 CP 来说, 放弃可用性, 追求一致性和分区容错性, 比如 Zookeeper 就是追求强一致. 对于 AP 来说, 放弃一致性(强一致), 追求分区容错和可用, 这是很多分布式系统的选择. CAP 是忽略网络延迟的, 也就是当事务提交时, 从节点 A 复制到节点 B, 但是在现实中总会有一定的时间延迟. 3.3.2 BASE基本可用, 软状态, 最终一致性的缩写 本质上是 AP 的一个扩张, 通过软状态实现基本可用和最终一致性. BA: 基本可用, 分布式系统出现故障时, 允许损失部分可用功能, 保证核心功能可用; 软状态: 允许系统中存在中间状态, 这个状态不影响系统可用性, 这里指的是 CAP 中的不一致; 最终一致性: 经过一段时间后, 所有节点数据都将达到一致. 4. 分布式事务的解决方案4.1 是否真的需要分布式事务首先要明确是否真的需要分布式事务? 是否存在由于服务拆分过细导致不合理的分布式系统设计? 可以先考虑将多个微服务聚合成一个单机服务, 避免引入不必要的成本和复杂度. 4.2 2PC 第一阶段: 事务管理器要求每个涉及到事务的数据库预提交此操作, 并反映是否可以提交 第二节点: 事务协调器要求每个数据库提交数据, 或者回滚 优点: 保证数据强一致, 实现简单; 缺点: 事务管理器存在单机风险; 整个过程存在同步阻塞; 数据可能不一致; 不支持高并发. 4.3 TCC相比 2PC, 解决了以下问题 解决了协调者单点, 引入集群 引入超时, 超时后进行补偿, 并且不会锁定整个资源, 将资源转换为业务逻辑形式 数据一致性, 有了补偿机制后, 由业务管理其控制一致性 Try 阶段: 尝试执行, 完成所有业务检查(一致性), 预留必须业务资源(准隔离性) Confirm 阶段: 确认执行真正的业务, 不做任何业务检查, 只使用 Try 阶段预留的业务资源, Confirm 操作满足幂等性. 要求具备幂等设计, Confirm 失败后需要进行重试. Cancel 阶段: 取消执行, 释放 Try 阶段预留的业务资源, 也需要满足幂等性. 4.4 本地消息表将需要分布式处理的任务通过消息日至的方式来异步执行 消息日志可以存储到本地文本, 数据库或者消息队列, 再通过业务规则或人工发起重试, 人工重试更多应用于支付系统 举一个购物的例子 当账户扣款的时候, 需要在扣款相关的服务上新增一个本地消息表, 需要把记录扣款和写入扣减商品库存的本地消息表放入同一个事务. 有个定时任务去轮询本地事务表, 把没有发送的消息扔给商品服务, 让它扣减库存, 到达商品服务后, 先写入这个服务器的事务表, 再进行扣减, 扣减成功后, 更新事务表中的状态; 商品服务器通过定时任务扫描消息表或者直接通过扣款服务吗扣款服务本地消息表进行更新; 针对特定情况, 定时扫描未成功处理的消息, 进行重新发送, 在商品服务收到消息后, 先判断是否是重复消息, 如果已经接受, 再判断是否执行, 如果执行再马上又进行通知事务, 如果未执行, 就需要重新执行需要由业务保证幂等. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。 4.5 MQ 事务还是以转账的模型举例: 1. 先发送消息 如果消息发送成功，但是扣款失败，消费端就会消费此消息，进而向Smith账户加钱。 2. 先扣款 如果扣款成功，发送消息失败，就会出现Bob扣钱了，但是Smith账户未加钱。 3. RocketMQ 的实现 发送 Prepared 消息时，会拿到消息的地址; 执行本地事物; 通过第一阶段拿到的地址去访问消息, 并修改消息的状态. 这样可以保证消息发送消息和本地事务执行成功保持原子性操作. 问题1: 如果步骤 3 失败怎么办RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认，Bob的钱到底是减了还是没减呢？ 如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。 12345678910111213141516// =============================发送事务消息的一系列准备工作========================================// 未决事务，MQ服务器回查客户端// 也就是上文所说的，当RocketMQ发现`Prepared消息`时，会根据这个Listener实现的策略来决断事务TransactionCheckListener transactionCheckListener = new TransactionCheckListenerImpl();// 构造事务消息的生产者TransactionMQProducer producer = new TransactionMQProducer("groupName");// 设置事务决断处理类producer.setTransactionCheckListener(transactionCheckListener);// 本地事务的处理逻辑，相当于示例中检查Bob账户并扣钱的逻辑TransactionExecuterImpl tranExecuter = new TransactionExecuterImpl();producer.start()// 构造MSG，省略构造参数Message msg = new Message(......);// 发送消息SendResult sendResult = producer.sendMessageInTransaction(msg, tranExecuter, null);producer.shutdown(); 接着查看 sendMessageInTransaction 方法的源码，总共分为3个阶段：发送 Prepared 消息、执行本地事务、发送确认消息。 1234567891011// ================================事务消息的发送过程=============================================public TransactionSendResult sendMessageInTransaction(.....) &#123; // 逻辑代码，非实际代码 // 1.发送消息 sendResult = this.send(msg); // sendResult.getSendStatus() == SEND_OK // 2.如果消息发送成功，处理与消息关联的本地事务单元 LocalTransactionState localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg); // 3.结束事务 this.endTransaction(sendResult, localTransactionState, localException);&#125; endTransaction 方法会将请求发往 broker(mq server) 去更新事务消息的最终状态： 根据 sendResult 找到 Prepared 消息, sendResult 包含事务消息的 ID 根据 localTransaction 更新消息的最终状态 问题2: Consumer 消费失败怎么办如果 Bob 的账户的余额已经减少，且消息已经发送成功，Smith 端开始消费这条消息，这个时候就会出现消费失败和消费超时两个问题. 解决超时问题的思路就是一直重试，直到消费端消费消息成功，整个过程中有可能会出现消息重复的问题，按照前面的思路解决即可。]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现简易JVM]]></title>
    <url>%2Fblog%2F2018%2F06%2F24%2F%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93JVM%2F</url>
    <content type="text"><![CDATA[1. 概述 Java 源代码经过编译生成 class 文件 在不同的操作系统上分别实现 JVM, JVM 在不同操作系统上实现差异很大, 如线程, 图形界面等, 由 JVM 屏蔽与操作系统的接口 1.1 Class 文件格式 1.1.1 魔数 &amp; 版本 &amp; 常量池个数 Magic Number 确定这是一个 Java 文件 Minor / Major Version: 版本号 16 进制 Major Version (0x34) = 52 常量池个数 (0x36) = 54 大端模式(Big-Endian): 高位在前 00 36 而不是 36 00 1.1.2 常量池 0036 代表常量池常量的个数, 后面的 07 通过查表发现含义为 ClassInfo 的 tag 值, 而 name_index 值为 2, 代表类名在第二个常量中. 第二个常量开头为 01, 查表得知是一个 Utf8 字符串, 0021 代表长度 length 值为 33. 而后面 33 个字节 63 6F 6D 2F 63 6F 64 65 72 69 73 69 6E 67 2F 65 78 61 6D 70 6C 65 2F 45 6D 70 6C 6F 79 65 65 56 31 转换成字符串之后的值为 com/coderising/example/EmployeeV1 1234CONSTANT_Class_info &#123; u1 tag; // 值为7 u2 name_index; // 名称索引&#125; 12345CONSTANT_Utf8_info &#123; u1 tag; // 值为1 u2 length; // 长度 u1 bytes[length]; // 内容&#125; 1.1.2.1 常量池实例 索引 类型 操作数 1 操作数 2 含义 #1 ClassInfo #2 #2 Utf8 org/destiny/jvm/model/Employee #3 ClassInfo #4 #4 Utf8 java/lang/Object #5 Utf8 name #6 Utf8 Ljava/lang/String #7 Utf8 age #8 Utf8 I #9 Utf8 #10 Utf8 … #11 Utf8 … #12 MethodRef #3 #13 java.lang.Object&lt;init&gt;()V #13 NameAndType #9 #14 &lt;init&gt;()V #14 Utf8 ()V #15 FieldRef #1 #16 org/destiny/jvm/model/Employee 包含一个 Ljava/lang/String 类型的变量 name #16 NameAndType #5 #6 Ljava/lang/String 类型的变量 name 1.1.3 访问标志 标志名称 标志值 含义 ACC_PUBLIC 0x0001 public 类型 ACC_FINAL 0x0002 声明为 final 类型 ACC_SUPER 0x0020 是否允许使用 invokespecial 字节码指令的新语义 ACC_INTERFACE 0x0200 声明为接口 ACC_ABSTRACT 0x0400 Abstract 类型 ACC_SYNTHETIC 0x1000 这个类并非由用户代码产生 ACC_ANNOTATION 0x2000 注解 ACC_ENUM 0x4000 枚举 1.1.4 类索引, 父类索引类索引和父类索引都是指向常量池的索引 由于 Java 采用动态连接 动态连接是一个将符号引用解析为直接引用的过程。当java虚拟机执行字节码时，如果它遇到一个操作码，这个操作码第一次使用一个指向另一个类的符号引用 那么虚拟机就必须解析这个符号引用。在解析时，虚拟机执行两个基本任务 查找被引用的类，（如果必要的话就装载它） 将符号引用替换为直接引用，这样当它以后再次遇到相同的引用时，它就可以立即使用这个直接引用，而不必花时间再次解析这个符号引用了。 1.1.5 接口1.1.6 字段123456789u2 fields_count; // 字段数量field_info &#123; u2 access_flags; // 访问控制符 u2 name_index; // 指向常量池的入口 u2 descriptor_index; // 指向常量池的入口 u2 attribute_count; // 该字段的属性数量 attribute_info attributes[attribute_count]; // 属性信息&#125; 标志字符含义 header 1 header 2 B byte C char D double F float I int J long S short Z boolean V void L 对象类型的通用前缀, 如 Ljava/lang/Object 1.1.7 方法123456789u2 methods_count; // 方法数量method_info &#123; u2 access_flags; // 访问标志 u2 name_index; // 指向常量池的入口 u2 descriptor_index; // 指向常量池的入口 u2 attributes_count; // 该字段的属性数量 attribute_info attributes[attributes_count]; // 属性信息&#125; (Ljava/lang/String;)V 表示 参数为 String, 返回值为 void 的方法(Ljava/lang/String;IF)V 表示 参数为 String, int, float, 返回值为 void 的方法 1.1.8 属性 方法和字段都可能有属性 方法中可能有 Code 属性, 字段可能有 Constant Value 属性 属性中可能嵌套属性 code 属性中还可能有 Line Number Table, Local Variable Table, Stack Map Table 等属性 虚拟机的实现中还可以自定义属性 1.1.8.1 Constant Value如果某字段为静态类型(access_flag 中包含 ACC_STATIC 标志) 将会被分配 Constant Value 属性 12345ConstantValue_attribute &#123; u2 attribute_name_index; // 必须是对常量池的一个有效索引, 常量池在该索引处的项必须是 UTF8Info, 表示字符串 "ConstantValue" u4 attribute_length; // 固定为 2 u2 constantvalue_index; // 必须是对常量池的一个有效索引, 常量池在该索引处的项给出该属性表示的常量值, 可能的值有 Constant_String, Constant_Long 等&#125; 1.1.8.2 Code1234567891011121314151617Code_attribute &#123; u2 attribute_name_index; // 指向常量池, 应该是 UTF8Info, 且值为 "Code" u4 attribute_length; // 属性长度, 不包括开始的 6 个字节 u2 max_stack; // 操作数栈的最大深度 u2 max_locals; // 最大局部变量表个数 u4 code_length; // 该方法的代码长度 u1 code[code_length]; // 真正的字节码 u2 exception_table_length; // 捕获异常表的长度 &#123; u2 start_pc; // 捕获起始地址 u2 end_pc; // 捕获结束地址 u2 handler_pc; // u2 catch_type; // 异常类型 &#125; exception_table[exception_table_length]; // 捕获异常表 u2 attributes_count; // attribute_info attributes[attributes_count];&#125; Code 属性中的字节码 字节码 命令 含义 2A aload_0 从局部变量表第 0 个值压入操作数栈 B4 00 15 getfield #21 获取对象的字段值 10 1E bipush 30 将 30 压入栈中 A2 00 0E if_icmp_ge 20 将当前 1.1.8.3 LineNumbercode属性的一个子属性 可选的变长属性, 维护 Java 源代码行号与字节码行号(偏移量之间的对应关系) 123456789LineNumberTable_attribute &#123; u2 attribute_name_index; u4 attribute_length; u2 line_number_table_length; &#123; u2 start_pc; // 字节码偏移量 u2 line_number; // 行号 &#125; line_number_table[line_number_table_length];&#125; 1.1.8.4 LocalVariableTable 属性code属性的一个子属性 可选的变长属性, 维护栈帧中局部变量表中变量与 Java 源码中定义变量的关系 123456789101112LocalVariableTable_attribute &#123; u2 attribute_name_index; u4 attribute_length; u2 local_variable_table_length; &#123; u2 start_pc; // 局部变量位于 [start_pc, start_pc + length)之间 u2 length; u2 name_index; // 局部变量的名称索引 u2 descriptor_index; // 局部变量的描述符索引 u2 index; // 局部变量在栈帧中的索引 &#125; local_variable_table[local_variable_table_length];&#125; 1.2 JVM 运行时动态行为 线程中包含函数栈帧, 其中每个函数帧表示某一个函数的调用过程 在每一个函数帧的内部, JVM 又细分了 局部变量表, 操作数栈 等 局部变量和操作数栈中的变量会引用堆中的对象 常量池引用指向方法区, 方法区保存了类的元数据以及方法的字节码 1.2.1 实例Java 源码:123456789public class Test &#123; void add(int i, int j) &#123; int num = i + j; &#125; void demo() &#123; add(10, 20); &#125;&#125; 转换成字节码后:12345678910111213demo:0: aload_01: bipush 103: bipush 205: invokevirtial #28: returnadd:0: aload_11: aload_22: iadd3: istore_34: return 调用 add 函数, 生成新的函数帧 0: aload_1: 将局部变量表第 1 个变量压入操作数栈;1: aload_2: 将局部变量表第 2 个变量压入操作数栈;2: iadd: 将操作数栈顶端的两个元素弹出, 相加并将结果压入栈顶3: istore_3: 将操作数栈栈顶元素放在局部变量表第 3 个元素中4: return: 执行完毕 2. ClassLoader2.1 Java 是动态链接 C: 编译 -&gt; 链接 -&gt; 生成 .exe -&gt; 执行 函数 A 调用函数 B, 在链接时会直接在函数 A 中记录函数 B 的地址 Java: 编译 -&gt; .class -&gt; 装载执行 类 A 中使用了另一个类 B, 在 A.class 中只保存类 B 的名称, 而不会保留 B 的 “地址” 在运行时根据名称来查找类, 装载类 2.2 类加载器的委托模型 工作原理 2.3 类加载器的命名空间 类加载器 + 类名 唯一确定一个类, 只有同一个加载器加载的类才是相同的类. 2.4 验证 2.5 自定义类加载器12345678910111213141516171819202122232425262728293031public class MyClassLoader extends ClassLoader &#123; private List&lt;String&gt; classPaths = new LinkedList&lt;&gt;(); protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] byteCodes = loadByteCode(name); if (byteCodes == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, byteCodes, 0, byteCodes.length); &#125; &#125; private byte[] loadClassFile(String classFileName) &#123; for (String classPath: classPaths) &#123; String realPath = classPath + File.separatorChar + classFileName.replace('.', File.separatorChar) + ".class"; File file = new File(classFileName); if (file.exists()) &#123; try &#123; return IOUtils.toByteArray(new FileInputStream(file)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; DefineClass 方法 protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int length) throws ClassFormatError; 只要传递给该方法一个合法字节数组, 就可以转化成一个 Class 对象, 这就意味着可以从任何地方组装类: 磁盘 zip 文件 网络 运行时动态生成 3. 常量池3.1 常见结构 123456789101112131415161718192021222324252627282930313233CONSTANT_Class_info &#123; u1 tag; // 7 u2 name_index; &#125;CONSTANT_Utf8_info &#123; u1 tag; // 1 u2 length; // 长度 u1 bytes[length]; // content&#125;CONSTANT_String_info &#123; u1 tag; // u2 string_index;&#125;CONSTANT_Fieldref_info &#123; u1 tag; // 9 u2 class_index; // u2 name_and_type_index;&#125;CONSTANT_Methodref_info &#123; u1 tag; // 10 u2 class_index; u2 name_and_type_index;&#125;CONSTANT_NameAndType_info &#123; u1 tag; // 12 u2 class_index; u2 descriptor_index;&#125; 3.2 访问标志 标志名称 标志值 含义 ACC_PUBLIC 0x0001 public 类型 ACC_FINAL 0x0002 声明为 final 类型 ACC_SUPER 0x0020 是否允许使用 invokespecial 字节码指令的新语义 ACC_INTERFACE 0x0200 声明为接口 ACC_ABSTRACT 0x0400 Abstract 类型 ACC_SYNTHETIC 0x1000 这个类并非由用户代码产生 ACC_ANNOTATION 0x2000 注解 ACC_ENUM 0x4000 枚举 4. 字段 &amp; 方法4.1 字段123456789u2 fields_count; // 字段数量field_info &#123; u2 access_flags; // 访问控制符 u2 name_index; // 指向常量池的入口 u2 descriptor_index; // 指向常量池的入口 u2 attribute_count; // 该字段的属性数量 attribute_info attributes[attribute_count]; // 属性信息&#125; 可以看到上图中有两个字段, 分别为 String 类型的 name, 和 int 类型的 age Name Index 表示常量池中变量名称的索引 Desc Index 表示常量池中变量类型的索引 4.2 方法123456789u2 methods_count; // 方法数量method_info &#123; u2 access_flags; // 访问标志 u2 name_index; // 指向常量池的入口 u2 descriptor_index; // 指向常量池的入口 u2 attributes_count; // 该字段的属性数量 attribute_info attributes[attributes_count]; // 属性信息&#125; 以第一个方法为例: Name Index 表示方法名称为 &lt;init&gt;, 即构造方法 Desc Index 表示方法签名为 (Ljava/lang/String;I)V, 即 (String, int):void 4.3 属性4.3.1 Code 属性1234567891011121314151617Code_attribute &#123; u2 attribute_name_index; // 指向常量池, 应该是 UTF8Info, 且值为 "Code" u4 attribute_length; // 属性长度, 不包括开始的 6 个字节 u2 max_stack; // 操作数栈的最大深度 u2 max_locals; // 最大局部变量表个数 u4 code_length; // 该方法的代码长度 u1 code[code_length]; // 真正的字节码 u2 exception_table_length; // 捕获异常表的长度 &#123; u2 start_pc; // 捕获起始地址 u2 end_pc; // 捕获结束地址 u2 handler_pc; // u2 catch_type; // 异常类型 &#125; exception_table[exception_table_length]; // 捕获异常表 u2 attributes_count; // 嵌套属性数量 attribute_info attributes[attributes_count]; // 嵌套属性&#125; code 属性一般由两个常见的子属性, 分别是: LineNumberTable LocalVariableTable 4.3.2 LocalLineTable通过该属性可以完成字节码与 Java 源码的行号映射 可以在 debug 的时候准确找到源码 并且抛出异常的时候堆栈信息可以找到对应行号 12345678910LineNumberTable_arrtibute &#123; u2 attribute_name_index; // 指向常量池, 必须是值为 "LineNumberTable" 的 Utf8 常量 u4 arrtibute_length; // 当前属性长度, 不包括开始的 6 个字节 u2 line_number_table_length; // line_number_table 数组元素个数 &#123; u2 start_pc; // start_pc 值必须是 code[] 数组的一个索引 u2 line_number; // 源文件的行号 &#125; line_number_table[line_number_table_length];&#125; 4.3.3 LocalVariableTableLocalVariableTable 属性建立了方法中的局部变量与源代码中的局部变量之间的对应关系。 每个 LocalVariableTable 的 local_variable_table 部分可以看做是一个数组， 每个数组项是一个叫做local_variable_info的结构， 该结构描述了某个局部变量的变量名和描述符， 还有和源代码的对应关系。 下面讲解 local_variable_info 的各个部分： start_pc 是当前 local_variable_info 所对应的局部变量的作用域的起始字节码偏移量； length 是当前 local_variable_info 所对应的局部变量的作用域的大小。 也就是从字节码偏移量 start_pc 到 start_pc+length 就是当前局部变量的作用域范围； name_index 指向常量池中的一个 CONSTANT_Utf8_info ， 该 CONSTANT_Utf8_info 描述了当前局部变量的变量名； descriptor_index 指向常量池中的一个 CONSTANT_Utf8_info ， 该 CONSTANT_Utf8_info 描述了当前局部变量的描述符； index 描述了在该方法被执行时，当前局部变量在栈中局部变量表中的位置。 由此可知， 方法中的每个局部变量都会对应一个local_variable_info 。 12345678910111213LocalVariableTable_attribute &#123; u2 attribute_name_index; // 指向常量池, 必须是值为 "LocalVariableTable_attribute" 的 Utf8 常量 u4 attribute_length; // 当前属性长度, 不包括开始的 6 个字节 u2 local_variable_table_length; // local_variable_table[] 的元素个数 &#123; u2 start_pc; // 局部变量的索引都在范围 [start_pc, start_pc + length) u2 length; u2 name_index; // 变量名索引, 在常量池中 u2 descriptor_index; // 变量描述索引(在常量池中) u2 index; // 此局部变量在当前栈帧的局部变量表中的索引 &#125; local_variable_table[local_variable_table_length]&#125; 解析以上字节码得到: start pc length slot name descript 0 15 0 this Lorg/destiny/jvm/model/Employee 0 15 1 name Ljava/lang/String 0 15 2 age I 在解析 code 属性时需要注意的两点: code 属性中包含了方法真正的字节码 code 属性中包含几个子属性, 包括 LineNumberTable, LocalVariableTable等, 也需要进行解析. 在 Field, Method, Attribute 三者中, 我们可以抽象出如下的关系: 4.3.4 Exceptions如果代码中出现了try{}catch{}块,那么try{}块内的机器指令的地址范围记录下来, 并且记录对应的catch{}块中的起始机器指令地址. 当运行时在try块中有异常抛出的话, JVM会将catch{}块对应懂得其实机器指令地址传递给PC寄存器，从而实现指令跳转. 1234567u2 exception_table_length; // 捕获异常表的长度&#123; u2 start_pc; // 捕获起始地址 u2 end_pc; // 捕获结束地址 u2 handler_pc; // u2 catch_type; // 异常类型&#125; exception_table[exception_table_length]; // 捕获异常表 exception_table 记录了该 code 属性中所有显示抛出的异常信心, 包括异常的作用于及类型. 5. 字节码指令5.1 main 方法字节码Employee 的 main 方法:1234public static final main(String[] args) &#123; Employee employee = new Employee("destiny", 24); employee.sayHello();&#125; 经过编译后的字节码: 5.1.1 newnew indexbyte1 indexbyte2 操作: 创建一个对象 (indexbyte1 &lt;&lt; 8) | indexbyte2 得到一个指向常量池的索引 BB 00 01 对应 new #1, 对应的类就是 org/destiny/jvm/model/Employee 在堆中创建一个新对象 将该对象的引用压入栈中 5.1.2 dup 操作: 复制操作数栈栈顶的值, 并压入栈中 5.1.3 ldcldc index 操作: 从运行时常量池中提取数据压入栈中 ldc #43, 43 在常量池中的值为字符串 destiny 5.1.4 bipushbipush byte 将有符号 byte 扩展为一个 int 类型的值 value, 然后将 value 压入到操作数栈中. byte 是一个立即数而非常量池引用 5.1.5 invokespecial indexbyte1 indexbyte2 操作: 对一个对象进行初始化, 父类的初始化, 调用私有方法(因为没有多态性为) (indexbyte1 &lt;&lt; 8) | indexbyte2 得到一个指向常量池的索引 invokespecial #45 常量池 #45 是一个 methodref: &lt;init&gt;:(Ljava/lang/String;I)V 需要形成新的栈帧 5.1.6 astore_n 操作: 将栈顶的 reference 类型数据保存到局部变量表中 astore_0 astore_1 astore_2 astore_3 5.1.7 aload_n 操作: 从局部变量表中加载一个 reference 类型的值到操作数栈中 aload_0 aload_1 aload_2 aload_3 5.1.8 invokevirtual indexbyte1 indexbyte2 操作: 调用实例方法, 依据实例的具体类型进行分派(多态) (indexbyte1 &lt;&lt; 8) | indexbyte2 invokevirtual #47 =&gt; sayHello: ()V 也需要形成新的栈帧 5.1.9 return 操作: 方法返回, 从当前函数栈帧退出, 无返回值. 5.2 方法指令1234public Employee(String name, int age) &#123; this.name = name; this.age = age;&#125; 5.2.1 aload_0 操作: 从局部变量表中加载 index 为 0 的 reference 类型的值到操作数栈中 5.2.2 aload_1 5.2.3 putfield indexbyte1 indexbyte2 操作: 给一个对象字段赋值 (indexbyte1 &lt;&lt; 8) | indexbyte2 putfield #15 =&gt; putfield name:Ljava/lang/String 5.3.3 iload_2 操作: 从局部变量中把 index 为 2 的 int 类型的值加载到操作数栈中 reference 类型使用 aload, int 类型使用 iload 5.4 字节码指令的设计实现使用 命令模式 来抽象该场景, 即将所有字节码指令抽象为命令对象, 基类声明 command 方法, 再根据操作数的不同泛化出不同的抽象子类 6 JVM 执行引擎 6.1 Java 命令1java -cp path1;path2 org.destiny.jvm.Employee cp: classpath(s), 默认是当前路径 class name: 系统需要找到这个类的 main 方法, 然后执行它的字节码 6.2 执行过程 加载类 工具: ClassFileLoader 目的地: 方法区 获取类的 public static void main(String[] args) 方法 从方法区寻找 执行 main 方法的字节码 字节码指令 栈帧(StackFrame) 堆(Heap) 6.3 字节码指令的分类 类型 指令 依次执行 newbipushldcdup 暂停当前栈帧并创建新栈帧 invokespecialinvokevirtual 跳转到另一行去执行 if_icmp_geif_icmplegoto 退出当前栈帧 return 7. 垃圾回收机制7.1 Java 对象的内存布局 MarkWord: 标注对象的元信息 GC 年龄 锁的标志位 ClassPointer: 指向方法区的类信息的指针 InstanceData: 类实例对象的数据 方法信息保存在方法区 padding: 填充 7.2 对象分配和垃圾回收 对象优先分配在新生代 如果 Eden 区没有足够的空间, 则触发一次 MinorGC Java 对象大多具有生命周期短暂的特点, MinorGC 非常频繁, 速度也很快 大对象直接进入老年代 可以根据参数设置阈值 长期存活对象进入老年代 每个对象都有一个年龄(age), 在 MarkWord 中 如果 age 超过阈值, 则晋升到老年代 动态年龄判断 如果在 Survivor 空间中相同年龄的所有对象大小的总数和大于 Survivor 空间的一半, 年龄大于或等于该年龄的对象可以直接进入老年代 MinorGC 时 新生代与老年代的关系]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo踩坑总结]]></title>
    <url>%2Fblog%2F2018%2F05%2F20%2Fdubbo%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2. 注册服务 IP 解析异常在使用 dubbo 注册服务的时候遇到了 IP 解析错误导致无法正常访问的问题。 在实际问题中，consumer 无法连接到 provider 的服务。其具体表现为： 本机的 IP 设置为 192.168.1.116，但 dubbo 绑定的却是 dubbo://30.250.11.135:20880，本机 ping 30.250.11.135 提示连接超时，provider 可以启动成功，但是 consumer 无法连接，提示连接超时。 2.1 复现场景2.1.1 provider1234567891011121314151617181920212223&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd "&gt; &lt;!-- 具体的实现 bean --&gt; &lt;bean id="provider" class="org.destiny.dubbo.impl.ProviderImpl"/&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="demo-provider"/&gt; &lt;!-- 使用 Zookeeper 注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://10.211.55.4:2181"/&gt; &lt;!-- 用 dubbo 协议在 20880 端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 增加暴露远程服务配置，写操作可以设置 retries=0 避免重复调用 SOA 服务 --&gt; &lt;dubbo:service retries="0" interface="org.destiny.dubbo.Provider" ref="provider"/&gt;&lt;/beans&gt; provider 的启动日志如下： 2.1.2 consumer12345678910111213141516171819&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd "&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="demo-consumer"/&gt; &lt;!-- 使用 Zookeeper 注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://10.211.55.4:2181"/&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!-- 生成远程代理，可以像本地使用 bean 一样使用 demoService，检查级联依赖默认为 true，当有依赖服务的时候，需要根据需求进行设置 --&gt; &lt;dubbo:reference id="consumer" interface="org.destiny.dubbo.Provider" check="false"/&gt;&lt;/beans&gt; consumer 启动日志如下： 2.2 定位问题 在 provider 启动时，定位到日志中第一次出现 30.250.11.135 的的位置： current host 然后全局搜索 current host，定位到对应源码：com.alibaba.dubbo.common.logger.support.FailsafeLogger 怀疑 NetUtils.getLocalHost() 获取到的 IP 就是 30.250.11.135 单独执行 System.out.println(NetUtils.getLocalHost())，发现结果确实是 30.250.11.135 此时结果已经很明确了，是 NetUtils.getLocalHost() 返回的 IP 地址已经错误，导致上面的问题发生。 2.3 分析问题通过阅读 dubbo 相关部分源码，其大致运行过程如下： dubbo 在获取本地 IP 的时候，先调用 NetUtils.getLocalHost()，如果该方法返回一个合法的地址，则直接认为是一本地 IP 的地址。 如果 NetUtils.getLocalHost() 没有返回合法地址，则会遍历本地所有网卡，并返回第一个合法的 IP 作为本地 IP。 而问题就出在 NetUtils.getLocalHost() 返回的并不是真正的本机 IP，却被 dubbo 误认为正确。 NetUtils.getLocalHost() 的原理是通过获取本机的 hostname，然后对此 hostname 做解析，从而获取 IP 地址； 而如果在本机的 /etc/hosts/ 文件中对这个主机名指向了一个错误的 IP 地址，那么 NetUtils.getLocalHost() 就会返回这个错误的 IP 地址； 如果 hostname 是到 DNS 中去解析的，而碰巧 DNS 也是错误的，那么返回的同样是错误的 IP。 因此就可以解释我们遇到的问题了： provider 实际上是运行在 A 地址上，但是 dubbo 检测到本地的 IP 是 B，然后在 Zookeeper 上注册自己服务地址的时候，使用的是 B 地址，那么当 consumer 连接到 Zookeeper 上的时候，查询到 provider 是在 B 地址上，但显然 B 地址上没有该服务，甚至根本无法连接到。因此就出现了该问题。 这个地址就是一开始被 dubbo 意外解析到的 30.250.11.135。 2.4 解决问题 先检查 /etc/hosts 文件中设置的 A 地址指向哪里 再检查 DNS 解析出的地址 /etc/hosts 文件修改前： 向 /etc/hosts 文件中追加 destiny 127.0.0.1 /etc/hosts 文件修改后： 2.5 引申 —— 如何在 Java 代码中正确的读取本地 IP 地址目前最普遍的方法是使用 `InetAddress.getLocalHost().getHostAddress()` 获取 但该方法只能获取简单网络环境下的 IP 地址 如果当前的网络环境比较复杂，存在多个网卡，则会被忽视 比如列出我当前本机的 ifconfig 命令直接结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374$ ifconfiglo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384 options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201&lt;PERFORMNUD,DAD&gt;gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280stf0: flags=0&lt;&gt; mtu 1280XHC20: flags=0&lt;&gt; mtu 0en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 98:01:a7:a2:9a:c1 inet6 fe80::1ca6:7ed1:3b63:235f%en0 prefixlen 64 secured scopeid 0x5 inet 192.168.1.103 netmask 0xffffff00 broadcast 192.168.1.255 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect status: activep2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304 ether 0a:01:a7:a2:9a:c1 media: autoselect status: inactiveawdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1484 ether ba:98:20:03:2e:f7 inet6 fe80::b898:20ff:fe03:2ef7%awdl0 prefixlen 64 scopeid 0x7 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect status: activeen1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether 6a:00:02:3e:5e:80 media: autoselect &lt;full-duplex&gt; status: inactiveen2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether 6a:00:02:3e:5e:81 media: autoselect &lt;full-duplex&gt; status: inactivebridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt; ether 6a:00:02:3e:5e:80 Configuration: id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0 ipfilter disabled flags 0x2 member: en1 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 8 priority 0 path cost 0 member: en2 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 9 priority 0 path cost 0 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: &lt;unknown type&gt; status: inactiveutun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000 inet6 fe80::a5b9:4c1f:b4b8:9414%utun0 prefixlen 64 scopeid 0xb nd6 options=201&lt;PERFORMNUD,DAD&gt;utun1: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1380 inet6 fe80::3de1:6926:1140:2956%utun1 prefixlen 64 scopeid 0xc inet6 fdd5:8db9:2302:60f0:3de1:6926:1140:2956 prefixlen 64 nd6 options=201&lt;PERFORMNUD,DAD&gt;utun2: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1380 inet6 fe80::4568:978c:85d3:ecd9%utun2 prefixlen 64 scopeid 0xd nd6 options=201&lt;PERFORMNUD,DAD&gt;vnic0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=3&lt;RXCSUM,TXCSUM&gt; ether 00:1c:42:00:00:08 inet 10.211.55.2 netmask 0xffffff00 broadcast 10.211.55.255 media: autoselect status: activevnic1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=3&lt;RXCSUM,TXCSUM&gt; ether 00:1c:42:00:00:09 inet 10.37.129.2 netmask 0xffffff00 broadcast 10.37.129.255 media: autoselect status: active 可以看到有很多类型的网络接口(network interfaces)： loopback 地址: 最常见的就是 127.0.0.1，即本地回环地址，只对本机可见，一般用于调试。 site local address 地址: private 私有地址，属于本地组织内部访问，只能在本地局域网可见，同样 10.xxx.xxx.xxx 等也属于私有地址 link local 地址: 属于连接本地地址，在单独网段可用 UP BROADCAST RUNNING MULTICAST 地址：如果网卡信息中包含 UP BROADCAST RUNNING MULTICAST，则支持广播和组播 除此之外的地址都是点对点可用的刚开的 IPv4 地址 刚才提到的 InetAddress.getLocalHost().getHostAddress() 一般情况下只会在如下两种情况中返回正确结果： 只使用 wifi 只使用网线 而在复杂环境下，获取 IP 地址最好能够遍历所有的网卡，然后依次筛选，最终找到符合条件的网卡的 IP：1234567891011121314151617181920212223242526272829303132public static InetAddress getLocalHostLANAddress() throws SocketException &#123; try &#123; InetAddress candidateAddress = null; // 遍历所有网络接口 Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces(); while (networkInterfaces.hasMoreElements()) &#123; NetworkInterface networkInterface = networkInterfaces.nextElement(); // 在所有的接口下再遍历 IP Enumeration&lt;InetAddress&gt; inetAddresses = networkInterface.getInetAddresses(); while (inetAddresses.hasMoreElements()) &#123; InetAddress inetAddress = inetAddresses.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; // 排除 loopback 类型地址 if (inetAddress.isSiteLocalAddress()) &#123; // 如果是 site-local 地址，直接返回 return inetAddress; &#125; else if (candidateAddress == null) &#123; // 如果是 site-local 地址未被发现，先记录候选地址 candidateAddress = inetAddress; &#125; &#125; &#125; &#125; if (candidateAddress != null) &#123; return candidateAddress; &#125; &#125;catch (Exception e) &#123; System.err.println("获取本机 IP 失败"); e.printStackTrace(); &#125; return null;&#125;]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>踩坑总结</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quartz 入门]]></title>
    <url>%2Fblog%2F2018%2F04%2F25%2Fquartz-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. 任务调度概述各种企业应用几乎都会碰到任务调度的需求。 在特定的时间点执行指定的操作。 任务调度本身涉及多线程并发、运行时间规则指定和解析、运行现场保持和恢复、线程池维护等诸多方面的问题。 2. Quartz Quartz允许开发人员灵活地定义触发器的调度时间，并可对触发器和任务进行关联映射； Quartz提供了调度运行环境的持久化和保存； Quartz还提供了组件式的侦听器、插件、线程池等功能。 2.1 Quartz基础结构Quartz对任务调度领域的问题进行了高度的抽象，提出了调度器、任务、触发器这3个核心的概念。 2.1.1 Job是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者通过实现该接口来定义需要执行的任务，JobExecutionContext 类提供了调度上下文的各种信息。Job 运行时的信息保存在 JobDataMap 实例中。 2.1.2 JobDetailQuartz 在每次执行 Job 的时候，都重新创建一个 Job 实例，所以它不是直接接收一个 Job 实例，而是接收一个 Job 实现类，以便运行时通过 newInstance() 反射调用机制实例化 Job。因此需要通过一个类来描述 Job 的实现类及其他相关信息，如 Job 名称、描述、关联监听器等信息，而 JobDetail 承担了这一角色。通过该类的构造函数 JobDetail(java.lang.String name, java.lang.String group, java.lang.Class jobClass)，可以更具体地了解它的功能。该构造函数要求指定 Job 的实现类，以及任务在 Schedule 中的组名和 Job 名称。 2.1.3 Trigger描述触发 Job 执行的时间触发规则。主要有 SimpleTrigger 和 CronTrigger 这两个子类。当仅需要触发一次或者以固定间隔周期性执行的时候， SimpleTrigger 是最佳选择；而 CronTrigger 则可以通过 Cron 表达式定义出各种复杂的调度方案，如每天早上 9:00 执行，每周一、周三下午 5:00 执行等。 2.1.4 Calendarorg.quartz.Calendar 和 java.util.Calendar 不同，它是一些日历特定时间点的集合。一个 Trigger 可以和多个 Calendar 关联，以便排除或包含某些时间点。假设安排每周一早晨 10:00 执行任务，但是如果遇到法定节假日不执行任务，这时就需要在 Trigger 触发机制的基础上使用 Calendar 进行定点排除。针对不同的时间段类型，如 AnnualCalendar、MonthlyCalendar、WeeklyCalendar 分别针对每年、每月和每周进行定义。 2.1.5 Scheduler代表一个 Quartz 的独立运行容器，Trigger 和 JobDetail 可以注册到 Scheduler 中，二者在 Scheduler 中拥有各自的组及名称。组及名称是 Scheduler 查找定位容器中某个对象的依据， Trigger 的组及明恒的组合必须唯一， JobDetail 的组及名称的组合也必须唯一（但可以和 Trigger 的组及名称相同，因为二者处在不同的容器中）。Scheduler 定义了多个接口方法，允许外部通过组及名称访问和控制容器中的 Trigger 和 JobDetail。Scheduler 可以将 Trigger 绑定到某一个 JobDetail 中，这样当 Trigger 被触发时，对应的 Job 就会被执行。一个 Job 可以对应多个 Trigger，但一个 Trigger 只能对应一个 Job。可以通过 SchedulerFactory 创建一个 Scheduler 实例。Scheduler 拥有一个 SchedulerContext，保存着 Scheduler 上下文信息，可以对照 ServletContext 来理解 SchedulerContext。 Job 和 Trigger 都可以访问 SchedulerContext 内的信息。SchedulerContext 内部通过一个 Map，以键值对的方式维护这些上下文数据。SchedulerContext 为保存和获取数据提供了多个 put() 和 getXxx() 方法。可以通过 Scheduler#getContext() 方法获取 SchedulerContext 实例。 2.1.6 ThreadPoolSchedule 使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程来提高效率。 Job 有一个 StatefulJob 子接口，代表有状态的任务。该接口是一个没有方法的标签接口，其目的是让 Quartz 知道任务类型，以便采取不同的措施。无状态任务在执行时拥有自己的 JobDataMap 复制，对 JobDataMap 的更改不会影响下次执行。而有状态任务共享同一个 JobDataMap 实例，每次任务执行时对 JobDataMap 所做的更改会保存下来。后面的执行可以看到更改。 因此，无状态任务可以并发执行，而有状态任务的 StatefulJob 不能并发执行。如果上一次的 StatefulJob 还没有执行完成，则下次的任务将阻塞等待。有状态任务比无状态任务需要考虑更多的因素，所以尽量避免使用无状态任务。 如果 Quartz 使用了数据库持久化任务调度信息，则无状态的 JobDataMap 仅会在 Scheduler 注册的任务时保存一次，而有状态任务对应的 JobDataMap 在每次执行任务后都会进行保存。 Trigger 自身也可以拥有一个 JobDataMap，其关联的 JobDataMap 可以通过 JobExecutionContext#getTrigger().getJobDataMap() 方法获取。不管是有状态还是无状态的任务，在任务执行期间对 Trigger 的 JobDataMap 所做的更改都不会进行持久化。 Quartz 拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、执行后事件、触发器触发前事件、触发器触发后事件、调度器开始事件、调度器关闭事件等。可以注册相应的监听器处理感兴趣的事件。 2.2 SimpleTriggerSimpleTrigger 有多个重载的构造函数，用于在不同场合下构造出对应的实例。 SimpleTrigger(String name, String group)：指定所属组和名称； SimpleTrigger(String name, String group, Date startTime)：指定触发的开始时间； SimpleTrigger(String name, String group, Date startTime, Date endTime, int repeatCount, long repeatInterval)：指定开始时间、结束时间、重复执行次数、时间间隔； SimpleTrigger(String name, String group, String jobName, String jobGroup, Date startTime, Date endTime, int repeatCount, long repeatInterval)：最复杂的一个构造函数，通过 jobName 和 jobGroup，使该 Trigger 和 Scheduler 中的某个任务关联起来。 2.2.1 代码实例 2.2.1.1 SimpleJob123456public class SimpleJob implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; System.out.println(jobExecutionContext.getTrigger().getName() + " triggered. time is:" + System.currentTimeMillis()); &#125;&#125; 2.2.1.2 SimpleTriggerRunner12345678910111213141516171819202122232425262728293031public class SimpleTriggerRunner &#123; public static void main(String[] args) &#123; try &#123; // 创建一个 JobDetail 实例，指定 SimpleJob JobDetail jobDetail = JobBuilder.newJob(SimpleJob.class) .withIdentity("jName", "jGroup") .build(); // 通过 SimpleTrigger 定义调度规则：【立即启动】、【每2秒运行一次】、【用运行10次】 SimpleTrigger simpleTrigger = TriggerBuilder.newTrigger() .withIdentity("tName", "tGroup") .startNow() .withSchedule( SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(2) // 调度间隔 .withRepeatCount(10) // 调度次数 ).build(); // 通过 SchedulerFactory 获取一个调度器实例 SchedulerFactory factory = new StdSchedulerFactory(); Scheduler scheduler = factory.getScheduler(); scheduler.scheduleJob(jobDetail, simpleTrigger); scheduler.start(); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.2.1.3 运行结果tName1 triggered. time is:1524563336613 tName1 triggered. time is:1524563338522 tName1 triggered. time is:1524563340522 tName1 triggered. time is:1524563342524 tName1 triggered. time is:1524563344523 tName1 triggered. time is:1524563346523 tName1 triggered. time is:1524563348523 tName1 triggered. time is:1524563350524 tName1 triggered. time is:1524563352524 tName1 triggered. time is:1524563354524 tName1 triggered. time is:1524563356523 2.3 使用 CronTriggerCronTrigger 能够提供比 SimpleTrigger 更有实际意义的调度方案，调度规则基于 Cron表达式。 CronTrigger 支持日历相关的周期性时间间隔（比如每月第一个周一执行），而不是简单的周期时间间隔。 2.3.1 Cron 表达式Quartz 使用类似 Linux 下的 Cron 表达式定义时间规则。Cron 表达式由 6 或 7 个空格分割的时间字段组成。 位置 时间域名 允许值 允许的特殊字符 1 秒 [0, 60) ,-*/ 2 分钟 [0, 60) ,-*/ 3 小时 [1, 24) ,-*/ 4 日期 [1, 32) ,-*?/LWC 5 月份 [1, 13) ,-*/ 6 星期 [1, 8) ,-*/LC?# 7 年（可选） 空值 或 [1970, 2100) ,-*/ 特殊字符： 特殊字符 作用 * 表示对应时间域的每一个时刻，如 * 在分钟时段就表示每分钟 ? 只能在日期和星期中使用，占位符，无意义 - 表达范围，如在小时中使用 10-12，表示从 10 点到 12 点 , 列表纸，如在星期中使用 MON,WED,FRI，表示周一、周三、周五 / x/y 表示等步长序列，x 为起始值，y 为增量步长，如在分钟中使用 0/15，表示0、15、30、45秒 L 只能在日期和星期中使用，代表 Last 的意思，日期中表示当月最后一天，星期表示周六 W 只能出现在日期中，是对前导日期的修饰，表示里该日期最近的工作日 LW 只能出现在日期中，表示当月最后一个工作日 # 只能在星期字段中使用，表示当月的某个工作日，6#3表示当月第三个周五，4#5 表示当月第五个周三，如果不存在则不触发 C 只能在日期和星期中使用，Calendar，表示计划所关联的日期。5C 在日期中相当于 5日之后的那一天，1C 在星期中相当于 周天后的那一天 示例 表达式 说明 0 0 12 * * ? 每天 12:00 运行 0 15 10 ? * * 每天 10:15 运行 0 15 10 * * ? 每天 10:15 运行 0 15 10 * * ? * 每天 10:15 运行 0 15 10 * * ? 2008 在 2008 年的每天 10:15 运行 0 * 14 * * ? 每天 14 点到 15 点每分钟运行一次，开始于 14:00，结束于 14:59 0 0/5 14 * * ? 每天 14 点到 15 点每 5 分钟运行一次，开始于 14:00，结束语 14:55 0 0/5 14,18 * * ? 每天 14 点到 15 点每 5 分钟运行一次，此外每天 18 点到 19 点每 5 分钟也运行一次 0 10,44 14 ? 3 WED 3 月的每周三的 14:10 到 14:44，每分钟运行一次 0 15 10 ? * MON-FRI 每个工作日的 10:15 运行一次 0 15 10 15 * ? 每月 15 日的 10:15 运行一次 0 15 10 L * ? 每月最后一天的 10:15 运行一次 0 15 10 ? * 6L 每月的最后一个周五的 10:15 运行一次 0 15 10 ? * 6L 2014-2016 2014、2015、2016 年每个月的最后一个周五的 10:15 运行 0 15 10 ? * 6#3 每月第三个周五的 10: 15 运行 2.3.2 示例123456789101112131415161718192021222324public class CronTriggerRunner &#123; public static void main(String[] args) &#123; try &#123; JobDetail jobDetail = new JobDetail("jName1", "jGroup1", SimpleJob.class); // 创建 CronTrigger 指定组及名称 CronTrigger cronTrigger = new CronTrigger("tName1", "tGroup1"); // 新建并设置 Cron 表达式：从每分钟的 0 秒开始，每隔5秒触发一次 CronExpression cronExpression = new CronExpression("0/5 * * * * ?"); cronTrigger.setCronExpression(cronExpression); SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); scheduler.scheduleJob(jobDetail, cronTrigger); scheduler.start(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.3.3 运行结果tName1 triggered. time is:1524645830011 tName1 triggered. time is:1524645835006 tName1 triggered. time is:1524645840006 tName1 triggered. time is:1524645845002 tName1 triggered. time is:1524645850003 tName1 triggered. time is:1524645855004 tName1 triggered. time is:1524645860003 tName1 triggered. time is:1524645865003 tName1 triggered. time is:1524645870005 tName1 triggered. time is:1524645875006 tName1 triggered. time is:1524645880000 tName1 triggered. time is:1524645885000 tName1 triggered. time is:1524645890007 tName1 triggered. time is:1524645895005 tName1 triggered. time is:1524645900005 由于打印的时间是以毫秒作为单位的，因此可以看毫秒数的倒数第4位，都是以 5 作为步长的。 2.4 Calendar在实际任务调度中，不可能一成不变地按照某个特定周期调度任务，必须考虑到现实生活中日历上的特殊日期。 下面的例子中，该任务每小时运行一次，并将 五一劳动节 和 国庆节 排除在外 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142public class CalendarExample &#123; public static void main(String[] args) throws SchedulerException &#123; SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); // 法定节日是以年作为周期的，所以使用 AnnualCalendar AnnualCalendar holidays = new AnnualCalendar(); // 五一劳动节 Calendar laborDay = new GregorianCalendar(); laborDay.add(Calendar.MONTH, 5); laborDay.add(Calendar.DATE, 1); // 国庆节 Calendar nationalDay = new GregorianCalendar(); nationalDay.add(Calendar.MONTH, 10); nationalDay.add(Calendar.DATE, 1); ArrayList&lt;Calendar&gt; calendarList = new ArrayList&lt;&gt;(); calendarList.add(laborDay); calendarList.add(nationalDay); // 排除这两个日期 holidays.setDaysExcluded(calendarList); // 向 Scheduler 注册日历 scheduler.addCalendar("holidays", holidays, false, false); // 4月1日上午10点 Date runDate = TriggerUtils.getDateOf(0, 0, 10, 1, 4); JobDetail jobDetail = new JobDetail("jName1", "jGroup1", SimpleJob.class); SimpleTrigger trigger = new SimpleTrigger( "tName1", "tGroup1", runDate, null, SimpleTrigger.REPEAT_INDEFINITELY, 60L * 60L * 1000L); // 让 Trigger 应用指定的日历规则 trigger.setCalendarName("holidays"); scheduler.scheduleJob(jobDetail, trigger); scheduler.start(); &#125; &#125; 2.5 任务调度信息存储在默认情况下，Quartz 将任务调度的运行信息保存在内存中。这种方法提供了最佳的性能，但缺乏持久性。 如果需要持久化任务调度信息，则 Quartz 允许用户通过调整其属性文件，将这些信息保存到数据库中。 2.5.1 通过配置文件调整任务调度信息Quartz JAR 文件的 org.quartz 包含了一个 quartz.properties 属性配置文件，并提供了默认属性。可以通过在类路径下新建一个 quartz.properties 文件来覆盖默认配置。 # 集群的配置，这里不使用集群 org.quartz.scheduler.instanceName = DefaultQuartzScheduler org.quartz.scheduler.rmi.export= false org.quartz.scheduler.warpJobExecutionInUserTransaction = false # 配置调度器的线程池 org.quartz.threadPool.class = org.quartz.simple.SimpleThreadPool org.quartz.threadPool.threadCount = 10 org.quartz.threadPool.threadPriority = 5 org.quartz.threadPool.threadInheritContextClassLoaderOfInitializingThread # 配置任务调度现场数据保存机制 org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore 如果任务数目很大，则可以通过增大线程池获得更好的性能。 默认情况下，Quartz 采用 org.quartz.simpl.RAMJobStore 保存任务的现场数据，而通过以下设置可以将任务调度现场数据保存到数据库中 org.quartz.jobStore.class = org.quratz.impl.jdbcjobstore.JobStoreTX # 数据库表前缀 org.quartz.jobStore.tablePrefix = QRTZ_ # 数据源名称 org.quartz.jobStore.dataSource = qzDS # 定义数据源的具体属性 org.quartz.dataSource.qzDS.driver = com.mysql.jdbc.Driver org.quartz.dataSource.qzDS.URL = jdbc:mysql://localhost:3306/quartz org.quartz.dataSource.qzDS.user = root org.quartz.dataSource.qzDS.password = 123456 org.quartz.dataSource.qzDS.maxConnections = 10 要将任务调度数据保存到数据库中，就必须使用 org.quratz.impl.jdbcjobstore.JobStoreTX，并提供相应的数据库配置信息。 用户必须事先在相应的数据库中创建 Quartz 的数据表，在 Quartz 的完整发布包的 docs/dbTables 目录下拥有对应不同数据库的 SQL 脚本。 选择自己使用的数据库对应的脚本执行即可。 执行结果： 2.5.2 查询数据库中的运行信息首先，引入依赖：1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 任务的现场保存对于上层的 Quartz 来说是完全透明的。使用该配置文件后将之前的代码重新运行，就能在数据库中看到对应的数据。 当调度程序中途停止之后，任务调度的现场数据将记录在数据库表中，在系统重启时就可以在此基础上继续任务的调度。 1234567891011121314151617181920212223242526public class JDBCJobStoreRunner &#123; public static void main(String[] args) &#123; try &#123; SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); // 获取调度器中所有的触发组 String[] triggerGroups = scheduler.getTriggerGroupNames(); // 重新恢复在 tGroup1 组中名为 tName1 的触发器的运行 for (int i = 0; i &lt; triggerGroups.length; ++ i) &#123; String[] triggerNames = scheduler.getTriggerNames(triggerGroups[i]); for (int j = 0; j &lt; triggerNames.length; ++ j) &#123; Trigger trigger = scheduler.getTrigger(triggerGroups[i], triggerNames[j]); if (trigger instanceof SimpleTrigger &amp;&amp; trigger.getFullName().equals("tGroup1.tName1")) &#123; // 恢复运行 scheduler.rescheduleJob(triggerNames[j], triggerGroups[i], trigger); &#125; &#125; &#125; scheduler.start(); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 如果调度程序执行后非正常退出，就可以通过 JDBCJobStoreRunner 根据记录在数据库中的现场数据恢复任务的调度。Scheduler 中的所有 Trigger 及 JobDetail 的运行信息都会保存在数据库中，这里仅恢复 tGroup1 组中名为 tName1 的触发器。触发器采用 GROUP.TRIGGER_NAME 的全名格式，通过 Scheduler#reschduleJob(String triggerName, String groupName, Trigger trigger) 方法即可重新调度关联某个 Trigger 任务。 2.5.3 不同时期 QRTZ_SIMPLE_TRIGGERS 表的数据 执行 代码 中的 SimpleTriggerRunner 一段时间后退出 quartz 数据库状态如下 这时 QRTZ_SIMPLE_TRIGGERS 表中的数据如下 REPEAT_COUNT: 触发器器需要执行的总次数 REPEAT_INTERVAL: 调度间隔(单位：毫秒) TIMES_TRIGGERED: 触发器已经调度的次数 1234567891011121314151617181920212223242526public class JDBCJobStoreRunner &#123; public static void main(String[] args) &#123; try &#123; SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); JobKey jobKey = new JobKey("jName", "jGroup"); List&lt;? extends Trigger&gt; triggers = scheduler.getTriggersOfJob(jobKey); // SELECT TRIGGER_NAME, TRIGGER_GROUP FROM &#123;QRTZ_&#125;TRIGGERS WHERE SCHED_NAME = &#123;DefaultQuartzScheduler&#125; AND JOB_NAME = ? AND JOB_GROUP = ? // 其中 &#123;QRTZ_&#125; 和 &#123;DefaultQuartzScheduler&#125; 均来自 quartz.properties 的配置 // 重新恢复在jGroup1组中，名为job1_1的 job的触发器运行 if(triggers.size() &gt; 0)&#123; for (Trigger tg : triggers) &#123; // 根据类型判断 if ((tg instanceof CronTrigger) || (tg instanceof SimpleTrigger)) &#123; // 恢复job运行 scheduler.resumeJob(jobKey); &#125; &#125; scheduler.start(); &#125; &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 此时原先被中断的任务已经恢复。 可以看到，将剩余12次全部执行完成。 再次查看 QRTZ_SIMPLE_TRIGGER 表，发现触发器已经完成调度并被清除。 3. 集成 SpringSpring 为创建 Quartz 的 Scheduler、Trigger、JobDetail 提供了便利的 FactoryBean 类，以便能够在 Spring 容器中享受注入的好处。 Spring 提供了两方面的支持： 为 Quartz 的主要组件提供了更具 Bean 风格的扩展类 提供创造 Scheduler 的BeanFactory 类，方便在 Spring 环境下创建对应的组件对象，并结合 Spring 容器生命周期执行启动和停止的动作。 3.1 创建 JobDetail由于 JobDetail 使用带参构造函数，不方便通过 Spring 配置，因此 Spring 通过扩展 JobDetail 提供了更具 Bean 风格的 JobDetailFactoryBean，此外，Spring 还提供了 MethodInvokingJobDetailFactoryBean，用于将 Spring 容器中 Bean 的方法包装成 Quartz 任务，使开发者不必为 Job 创建对应的类。 3.1.1 JobDetailFactoryBean12345678910111213141516171819@Configuration@ComponentScan(basePackages = &#123;"example5"&#125;)public class QuartzConf &#123; @Bean public JobDetailFactoryBean jobDetailFactoryBean() &#123; JobDetailFactoryBean jobDetailFactoryBean = new JobDetailFactoryBean(); jobDetailFactoryBean.setJobClass(SimpleJob.class); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("size", 10); jobDetailFactoryBean.setJobDataAsMap(map); jobDetailFactoryBean.setApplicationContextJobDataKey("applicationContext"); return jobDetailFactoryBean; &#125;&#125; JobDetailFactoryBean 封装了 SimpleJob 任务类，并为 Job 对应的 JobDataMap 设置了一个 key 为 size，value 为 10的数据。此外，通过指定 ApplicationContextJobDataKey，让 Job 的JobDataMap 持有 Spring ApplicationContext 的引用。 jobClass：实现 Job 接口的任务类； beanName：默认为 bean 的id，显示指定 Bean 名称，对应任务的名称； jobDataAsMap：类型为 Map，为任务所对应的 JobDataMap 提供值。提供这个数据是因为用户无法在 Spring 配置文件中为 JobDataMap 类型的属性提供信息； applicationContextJobDataKey：用户可以将 Spring ApplicationContext 的引用保存到 JobDataMap 中，以便在 Job 的代码中访问 ApplicaitonContext。为了达到这个目的，用户需要指定一个 key 对应这个 ApplicationContext，如果不设置就不会将 ApplicationContext 放入 JobDataMap中； jobListenerNames：类型为 String[]，指定注册在 Scheduler 中的 JobListener 名称。 3.2 创建 TriggerSpring 按照相似的思路分为 SimpleTrigger 和 CronTrigger 提供了更具 Bean 风格的 SimpleTriggerFactoryBean 和 CronTriggerFactoryBean 的扩展类， 3.2.1 SimpleTriggerFactoryBean1234567891011121314@Bean(name = "simpleTrigger")public SimpleTriggerFactoryBean simpleTriggerFactoryBean() &#123; SimpleTriggerFactoryBean simpleTriggerFactoryBean = new SimpleTriggerFactoryBean(); simpleTriggerFactoryBean.setJobDetail(jobDetailFactoryBean().getObject()); simpleTriggerFactoryBean.setStartDelay(1000); simpleTriggerFactoryBean.setRepeatInterval(2000); simpleTriggerFactoryBean.setRepeatCount(20); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("count", 10); simpleTriggerFactoryBean.setJobDataAsMap(map); return simpleTriggerFactoryBean;&#125; 定义了一个 Trigger，该 Trigger 和 JobDetail 相关联，延迟 1 秒后启动，时间间隔为 2 秒，重复执行 20 次。 Trigger 中设置的 JobDataMap 在执行任务时必须通过以下方式获取12345public class SimpleJob implements StatefulJob &#123; public void execute(JobExecutionContext context) throws JobExecutionException &#123; Map dataMap = context.getTrigger().getJobDataMap(); &#125;&#125; 3.2.2 CronTriggerFactoryBean1234567@Bean(name = "cronTriggerFactoryBean")public CronTriggerFactoryBean cronTriggerFactoryBean() &#123; CronTriggerFactoryBean cronTriggerFactoryBean = new CronTriggerFactoryBean(); cronTriggerFactoryBean.setJobDetail(jobDetailFactoryBean().getObject()); cronTriggerFactoryBean.setCronExpression("0/5 * * * * ?"); return cronTriggerFactoryBean;&#125; 3.3 SchedulerQuartz 的 SchedulerFactory 是标准的工厂类，不太适合在 Spring 环境下使用。此外，为了保证 Scheduler 能够感知到 Spring 的生命周期，Spring 提供了 SchedulerFactory。 12345678910111213@Beanpublic SchedulerFactoryBean schedulerFactoryBean() &#123; SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean(); // 注册一个或多个 Trigger schedulerFactoryBean.setTriggers(simpleTriggerFactoryBean().getObject()); // 以 Map 类型设置 SchedulerContext Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("timeout", 30); schedulerFactoryBean.setSchedulerContextAsMap(map); // 显示指定 Quartz 配置文件的路径 schedulerFactoryBean.setConfigLocation(new ClassPathResource("quartz.properties")); return schedulerFactoryBean;&#125; triggers：属性为 trigger[]，可以注册多个 Trigger schedulerContextAsMap：Scheduler拥有类似 ServletContext 的 SchedulerContext，允许用户以 Map 的形式设置 SchedulerContext 的参数值 configLocation：指定配置文件路径 calendars：类型为 Map，通过该属性向 Scheduler 注册 JobDetail jobDetails：类型为 JobDetail[]，通过该属性向 Scheduler 注册 JobDetail autoStartup：SchedulerFactoryBean 初始化之后是否立即启动，默认为 true startupDelay：SchedulerFactoryBean 启动后的延迟时间，默认为 0 SchedulerFactoryBean 的一项重要功能是允许用户将 Quartz 配置文件中的信息转移到 Spring 配置文件中 12345678910111213141516171819@Beanpublic SchedulerFactoryBean schedulerFactoryBean() &#123; SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean(); // 注册一个或多个 Trigger schedulerFactoryBean.setTriggers(simpleTriggerFactoryBean().getObject()); // 以 Map 类型设置 SchedulerContext Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("timeout", 30); schedulerFactoryBean.setSchedulerContextAsMap(map); // 显示指定 Quartz 配置文件的路径 schedulerFactoryBean.setConfigLocation(new FileSystemResource("classpath:quartz.properties")); //------------------ 集成 Quartz 配置文件 ------------------// Properties properties = new Properties(); properties.setProperty("org.quartz.threadPool.class", "org.quartz.simpl.SimpleThreadPool"); properties.setProperty("org.quartz.threadPool.threadCount", "10"); schedulerFactoryBean.setQuartzProperties(properties); return schedulerFactoryBean;&#125; 3.4 测试代码此处有一个坑，就说从 Spring 容器中根据 beanName 获取的 schedulerFactoryBean 其实是 org.quartz.impl.StdScheduler 对象，如果使用 org.springframework.scheduling.quartz.SchedulerFactoryBean 会抛出以下异常 从 Spring 容器中直接获取 Scheduler 即可。1234567891011public class SimpleTriggerRunner &#123; public static void main(String[] args) throws SchedulerException &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(QuartzConf.class); // 此处一定要取 Scheduler 而不是 SchedulerFactoryBean，因为它是一个工厂bean，得到的不是它本身，而是它负责创建的 org.quartz.impl.StdScheduler 对象 Scheduler scheduler = context.getBean("schedulerFactoryBean", Scheduler.class); scheduler.start(); &#125;&#125; 4. 附录4.1 tables_mysql_innodb.sql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151-- In your Quartz properties file, you'll need to set -- org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate-- By: Ron Cordell - roncordell-- I didn't see this anywhere, so I thought I'd post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.DROP TABLE IF EXISTS QRTZ_JOB_LISTENERS;DROP TABLE IF EXISTS QRTZ_TRIGGER_LISTENERS;DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;DROP TABLE IF EXISTS QRTZ_LOCKS;DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;DROP TABLE IF EXISTS QRTZ_TRIGGERS;DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;DROP TABLE IF EXISTS QRTZ_CALENDARS;CREATE TABLE QRTZ_JOB_DETAILS(JOB_NAME VARCHAR(200) NOT NULL,JOB_GROUP VARCHAR(200) NOT NULL,DESCRIPTION VARCHAR(250) NULL,JOB_CLASS_NAME VARCHAR(250) NOT NULL,IS_DURABLE VARCHAR(1) NOT NULL,IS_VOLATILE VARCHAR(1) NOT NULL,IS_STATEFUL VARCHAR(1) NOT NULL,REQUESTS_RECOVERY VARCHAR(1) NOT NULL,JOB_DATA BLOB NULL,PRIMARY KEY (JOB_NAME,JOB_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_JOB_LISTENERS (JOB_NAME VARCHAR(200) NOT NULL,JOB_GROUP VARCHAR(200) NOT NULL,JOB_LISTENER VARCHAR(200) NOT NULL,PRIMARY KEY (JOB_NAME,JOB_GROUP,JOB_LISTENER),INDEX (JOB_NAME, JOB_GROUP),FOREIGN KEY (JOB_NAME,JOB_GROUP)REFERENCES QRTZ_JOB_DETAILS(JOB_NAME,JOB_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_TRIGGERS (TRIGGER_NAME VARCHAR(200) NOT NULL,TRIGGER_GROUP VARCHAR(200) NOT NULL,JOB_NAME VARCHAR(200) NOT NULL,JOB_GROUP VARCHAR(200) NOT NULL,IS_VOLATILE VARCHAR(1) NOT NULL,DESCRIPTION VARCHAR(250) NULL,NEXT_FIRE_TIME BIGINT(13) NULL,PREV_FIRE_TIME BIGINT(13) NULL,PRIORITY INTEGER NULL,TRIGGER_STATE VARCHAR(16) NOT NULL,TRIGGER_TYPE VARCHAR(8) NOT NULL,START_TIME BIGINT(13) NOT NULL,END_TIME BIGINT(13) NULL,CALENDAR_NAME VARCHAR(200) NULL,MISFIRE_INSTR SMALLINT(2) NULL,JOB_DATA BLOB NULL,PRIMARY KEY (TRIGGER_NAME,TRIGGER_GROUP),INDEX (JOB_NAME, JOB_GROUP),FOREIGN KEY (JOB_NAME,JOB_GROUP)REFERENCES QRTZ_JOB_DETAILS(JOB_NAME,JOB_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_SIMPLE_TRIGGERS (TRIGGER_NAME VARCHAR(200) NOT NULL,TRIGGER_GROUP VARCHAR(200) NOT NULL,REPEAT_COUNT BIGINT(7) NOT NULL,REPEAT_INTERVAL BIGINT(12) NOT NULL,TIMES_TRIGGERED BIGINT(10) NOT NULL,PRIMARY KEY (TRIGGER_NAME,TRIGGER_GROUP),INDEX (TRIGGER_NAME, TRIGGER_GROUP),FOREIGN KEY (TRIGGER_NAME,TRIGGER_GROUP)REFERENCES QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_CRON_TRIGGERS (TRIGGER_NAME VARCHAR(200) NOT NULL,TRIGGER_GROUP VARCHAR(200) NOT NULL,CRON_EXPRESSION VARCHAR(120) NOT NULL,TIME_ZONE_ID VARCHAR(80),PRIMARY KEY (TRIGGER_NAME,TRIGGER_GROUP),INDEX (TRIGGER_NAME, TRIGGER_GROUP),FOREIGN KEY (TRIGGER_NAME,TRIGGER_GROUP)REFERENCES QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_BLOB_TRIGGERS (TRIGGER_NAME VARCHAR(200) NOT NULL,TRIGGER_GROUP VARCHAR(200) NOT NULL,BLOB_DATA BLOB NULL,PRIMARY KEY (TRIGGER_NAME,TRIGGER_GROUP),INDEX (TRIGGER_NAME, TRIGGER_GROUP),FOREIGN KEY (TRIGGER_NAME,TRIGGER_GROUP)REFERENCES QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_TRIGGER_LISTENERS (TRIGGER_NAME VARCHAR(200) NOT NULL,TRIGGER_GROUP VARCHAR(200) NOT NULL,TRIGGER_LISTENER VARCHAR(200) NOT NULL,PRIMARY KEY (TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_LISTENER),INDEX (TRIGGER_NAME, TRIGGER_GROUP),FOREIGN KEY (TRIGGER_NAME,TRIGGER_GROUP)REFERENCES QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_CALENDARS (CALENDAR_NAME VARCHAR(200) NOT NULL,CALENDAR BLOB NOT NULL,PRIMARY KEY (CALENDAR_NAME))TYPE=InnoDB;CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (TRIGGER_GROUP VARCHAR(200) NOT NULL,PRIMARY KEY (TRIGGER_GROUP))TYPE=InnoDB;CREATE TABLE QRTZ_FIRED_TRIGGERS (ENTRY_ID VARCHAR(95) NOT NULL,TRIGGER_NAME VARCHAR(200) NOT NULL,TRIGGER_GROUP VARCHAR(200) NOT NULL,IS_VOLATILE VARCHAR(1) NOT NULL,INSTANCE_NAME VARCHAR(200) NOT NULL,FIRED_TIME BIGINT(13) NOT NULL,PRIORITY INTEGER NOT NULL,STATE VARCHAR(16) NOT NULL,JOB_NAME VARCHAR(200) NULL,JOB_GROUP VARCHAR(200) NULL,IS_STATEFUL VARCHAR(1) NULL,REQUESTS_RECOVERY VARCHAR(1) NULL,PRIMARY KEY (ENTRY_ID))TYPE=InnoDB;CREATE TABLE QRTZ_SCHEDULER_STATE (INSTANCE_NAME VARCHAR(200) NOT NULL,LAST_CHECKIN_TIME BIGINT(13) NOT NULL,CHECKIN_INTERVAL BIGINT(13) NOT NULL,PRIMARY KEY (INSTANCE_NAME))TYPE=InnoDB;CREATE TABLE QRTZ_LOCKS (LOCK_NAME VARCHAR(40) NOT NULL,PRIMARY KEY (LOCK_NAME))TYPE=InnoDB;INSERT INTO QRTZ_LOCKS values('TRIGGER_ACCESS');INSERT INTO QRTZ_LOCKS values('JOB_ACCESS');INSERT INTO QRTZ_LOCKS values('CALENDAR_ACCESS');INSERT INTO QRTZ_LOCKS values('STATE_ACCESS');INSERT INTO QRTZ_LOCKS values('MISFIRE_ACCESS');commit;]]></content>
      <categories>
        <category>quartz</category>
      </categories>
      <tags>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(翻译)In Search of an Understandable Consensus Algorithm —— Raft算法]]></title>
    <url>%2Fblog%2F2018%2F04%2F15%2F%E7%BF%BB%E8%AF%91-In-Search-of-an-Understandable-Consensus-Algorithm-%E2%80%94%E2%80%94-Raft%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本篇博客为著名的 RAFT 一致性算法论文的中文翻译，论文名为《In search of an Understandable Consensus Algorithm (Extended Version)》(寻找一种易于理解的一致性算法) Raft 是一种用来管理日志复制的一致性算法。它和 Paxos 的性能和功能是一样的，但是它和 Paxos 的结构不一样；这使得 Raft 更容易理解并且更易于建立实际的系统。为了提高理解性，Raft 将一致性算法分为了几个部分，例如领导选取（leader selection），日志复制（log replication）和安全性（safety），同时它使用了更强的一致性来减少了必须需要考虑的状态。从用户学习的结果来看，Raft 比 Paxos 更容易学会。Raft 还包括了一种新的机制来使得动态改变集群成员，它使用重叠大多数（overlapping majorities）来保证安全。 1. 引言一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器出了错误也能正常工作。正因为此，他们扮演着建立大规模可靠的软件系统的关键角色。在过去的十年中 Paxos 一直都主导着有关一致性算法的讨论：大多数一致性算法的实现都基于它或者受它影响，并且 Paxos 也成为了教学生关于一致性知识的主要工具。 不幸的是，尽管在降低它的复杂性方面做了许多努力，Paxos 依旧很难理解。并且，Paxos 需要经过复杂的修改才能应用于实际中。这些导致了系统构构建者和学生都十分头疼。 在被 Paxos 折磨之后，我们开始寻找一种在系统构建和教学上更好的新的一致性算法。我们的首要目标是让它易于理解：我们能不能定义一种面向实际系统的一致性算法并且比 Paxos 更容易学习呢？并且，我们希望这种算法能凭直觉就能明白，这对于一个系统构建者来说是十分必要的。对于一个算法，不仅仅是让它工作起来很重要，知道它是如何工作的更重要。 我们工作的结果是一种新的一致性算法，叫做 Raft。在设计 Raft 的过程中我们应用了许多专门的技巧来提升理解性，包括算法分解（分为领导选取（leader selection），日志复制（log replication）和安全性（safety）） 和 减少状态（state space reduction）（相对于 Paxos，Raft 减少了非确定性的程度和服务器互相不一致的方式）。在两所学校的43个学生的研究中发现，Raft 比 Paxos 要更容易理解：在学习了两种算法之后，其中的33个学生回答 Raft 的问题要比回答 Paxos 的问题要好。 在许多方面，Raft与现有的协商一致意见相似(最值得注意的是，Oki和Liskov的Viewstamped复制)，但它有几个新的特点: 强领导者（Strong Leader） : Raft使用一种比其他共识算法更强的领导方式。例如，日志条目只从Leader流向其他服务器。这样就简化了复制日志的管理，使Raft更容易理解。 领导选取（Leader Selection）: Raft 使用随机定时器选举领导人。这只增加了对任何协商一致算法所需的心跳的一小部分机制，同时快速地解决冲突。 成员变化（Membership Change）: Raft 为了调整集群中成员关系使用了新的联合一致性（joint consensus）的方法，这种方法中大多数不同配置的机器在转换关系的时候会交迭（overlap）。这使得在配置改变的时候，集群能够继续操作。 我们认为，Raft 在教学方面和实际实现方面比 Paxos 和其他算法更出众。 它比其他算法更简单、更容易理解； 它能满足一个实际系统的需求； 它拥有许多开源的实现并且被许多公司所使用； 它的安全特性已经被证明； 并且它的效率和其他算法相比也具有竞争力。 这篇论文剩下的部分会讲如下内容： 复制状态机（replicated state machine）问题（第2节）; 讨论 Paxos 的优缺点（第3节）; 讨论我们用的为了达到提升理解性的方法（第4节）; 陈述 Raft 一致性算法（第5~8节）; 评价 Raft 算法（第9节）; 对相关工作的讨论（第10节）。 2. 复制状态机（Replicated State Machine）复制状态机在分布式领域是一个常用且重要的技术。 通过复制服务副本，并和副本一起来协调客户端的交互，来实现容错服务。 这个方法同样提供了一个框架，来理解和设计复制管理协议。 一致性算法是在复制状态机的背景下提出来的。在这个方法中，在一组服务器的状态机产生同样的状态的副本因此即使有一些服务器崩溃了这组服务器也还能继续执行。复制状态机在分布式系统中被用于解决许多有关容错的问题。例如，GFS，HDFS还有 RAMCloud 这些大规模的系统都是用一个单独的集群领导者，使用一个单独的复制状态机来进行领导选取和存储配置信息来应对领导者的崩溃。使用复制状态机的例子有 Chubby 和 ZooKeeper。 复制状态机的架构。一致性算法管理来自客户端状态命令的复制日志。状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。 复制状态机是通过复制日志来实现的。每一台服务器保存着一份日志，日志中包含一系列的命令，状态机会按顺序执行这些命令。因为每一台计算机的状态机都是确定的，所以每个状态机的状态都是相同的，执行的命令是相同的，最后的执行结果也就是一样的了。 如何保证复制日志一致就是一致性算法的工作了。在一台服务器上，一致性模块接受客户端的命令并且把命令加入到它的日志中。它和其他服务器上的一致性模块进行通信来确保每一个日志最终包含相同序列的请求，即使有一些服务器宕机了。一旦这些命令被正确的复制了，每一个服务器的状态机都会按同样的顺序去执行它们，然后将结果返回给客户端。最终，这些服务器看起来就像一台可靠的状态机。 应用于实际系统的一致性算法一般有以下特性： 确保安全性（从来不会返回一个错误的结果），即使在所有的非拜占庭（Non-Byzantine）情况下，包括网络延迟、分区、丢包、冗余和乱序的情况下。 高可用性，只要集群中的大部分机器都能运行，可以互相通信并且可以和客户端通信，这个集群就可用。因此，一般来说，一个拥有 5 台机器的集群可以容忍其中的 2 台的失败（fail）。服务器停止工作了我们就认为它失败（fail）了，没准一会当它们拥有稳定的存储时就能从中恢复过来，重新加入到集群中。 不依赖时序保证一致性，时钟错误和极端情况下的消息延迟在最坏的情况下才会引起可用性问题。 通常情况下，一条命令能够尽可能快的在大多数节点对一轮远程调用作出相应时完成，一少部分慢的机器不会影响系统的整体性能。 3. Paxos算法的不足在过去的10年中，Leslie Lamport 的 Paxos 算法几乎已经成为了一致性算法的代名词：它是授课中最常见的算法，同时也是许多一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，例如一个单一复制日志条目（single replicated log entry）。我们把这个子集叫做单一决策 Paxos（single-decree Paxos）。之后 Paxos通过组合多个这种协议来完成一系列的决策，例如一个日志（multi-Paxos）。Paxos 确保安全性和活跃性（liveness），并且它支持集群成员的变更。它的正确性已经被证明，通常情况下也很高效。 不幸的是，Paxos 有两个致命的缺点。 Paxos 太难以理解。它的完整的解释晦涩难懂；很少有人能完全理解，只有少数人成功的读懂了它。并且大家做了许多努力来用一些简单的术语来描述它。尽管这些解释都关注于单一决策子集问题，但仍具有挑战性。在 NSDI 2012 会议上的一次非正式调查显示，我们发现大家对 Paxos 都感到不满意，其中甚至包括一些有经验的研究员。我们自己也曾深陷其中，我们在读过几篇简化它的文章并且设计了我们自己的算法之后才完全理解了 Paxos，而整个过程花费了将近一年的时间。我们假定 Paxos 的晦涩来源于它将单决策子集作为它的基础。单决策（Single-decree）Paxos 是晦涩且微妙的：它被划分为两个没有简单直观解释的阶段，并且难以独立理解。正因为如此，它不能很直观的让我们知道为什么单一决策协议能够工作。为多决策 Paxos 设计的规则又添加了额外的复杂性和精巧性。我们相信多决策问题能够分解为其它更直观的方式。 它难以在实际环境中实现。其中一个原因是，对于多决策 Paxos （multi-Paxos） ，大家还没有一个一致同意的算法。Lamport 的描述大部分都是有关于单决策 Paxos （single-decree Paxos）；他仅仅描述了实现多决策的可能的方法，缺少许多细节。有许多实现 Paxos 和优化 Paxos 的尝试，但是他们都和 Lamport 的描述有些出入。例如，Chubby 实现的是一个类似 Paxos 的算法，但是在许多情况下的细节没有公开。 另外，Paxos 的结构也是不容易在一个实际系统中进行实现的，这是单决策问题分解带来的又一个问题。例如，从许多日志条目中选出条目然后把它们融合到一个序列化的日志中并没有带来什么好处，它仅仅增加了复杂性。围绕着日志来设计一个系统是更简单、更高效的：新日志按照严格的顺序添加到日志中去。另一个问题是，Paxos 使用对等的点对点的实现作为它的核心（尽管它最终提出了一种弱领导者的形式来优化性能）。这种方法在只有一个决策被制定的情况下才显得有效，但是很少有现实中的系统使用它。如果要做许多的决策，选择一个领导人，由领带人来协调是更简单有效的方法。 因此，在实际的系统应用中和 Paxos 算法都相差很大。所有开始于 Paxos 的实现都会遇到很多问题，然后由此衍生出了许多与 Paxos 有很大不同的架构。这是既费时又容易出错的，并且理解 Paxos 的难度又非常大。Paxos 算法在它正确性的理论证明上是很好的，但是在实现上的价值就远远不足了。来自 Chubby 的实现的一条评论就能够说明： There are signiﬁcant gaps between the description of the Paxos algorithm and the needs of a real-world system... the ﬁnal system will be based on an unproven protocol 翻译：Paxos 算法的描述与实际实现之间存在巨大的鸿沟... 最终的系统往往建立在一个没有被证明的算法之上。 正因为存在这些问题，我们认为 Paxos 不仅对于系统的构建者来说不友好，同时也不利于教学。鉴于一致性算法对于大规模软件系统的重要性，我们决定试着来设计一种另外的比 Paxos 更好的一致性算法。Raft 就是这样的一个算法。 4. 易于理解的设计设计 Raft 的目标有如下几个： 它必须提供一个完整的、实际的基础来进行系统构建，为的是减少开发者的工作； 它必须在所有情况下都能保证安全可用； 它对于常规操作必须高效； 最重要的目标是：易于理解，它必须使得大多数人能够很容易的理解； 另外，它必须能让开发者有一个直观的认识，这样才能使系统构建者们去对它进行扩展。 在设计 Raft 的过程中，我们不得不在许多种方法中做出选择。当面临这种情况时，我们通常会权衡可理解性：每种方法的可理解性是如何的？（例如，它的状态空间有多复杂？它是不是有很细微的含义？）它的可读性如何？读者能不能轻易地理解这个方法和它的含义？ 我们意识到对这种可理解性的分析具有高度的主观性；尽管如此，我们使用了两种适用的方式。 第一种是众所周知的问题分解：我们尽可能将问题分解成为若干个可解决的、可被理解的小问题。例如，在 Raft 中，我们把问题分解成为了领导选取（leader election）、日志复制（log replication）、安全（safety）和成员变化（membership changes）。 我们采用的第二个方法是通过减少需要考虑的状态的数量将状态空间简化，这能够使得整个系统更加一致并且尽可能消除不确定性。特别地，日志之间不允许出现空洞，并且 Raft 限制了限制了日志不一致的可能性。尽管在大多数情况下，我们都都在试图消除不确定性，但是有时候有些情况下，不确定性使得算法更易理解。尤其是，随机化方法使得不确定性增加，但是它减少了状态空间。我们使用随机化来简化了 Raft 中的领导选取算法。 5. Raft 一致性算法Raft是一种用于管理第2节中描述的表单的复制日志的算法。表2总结了压缩格式的算法，表3列出了算法的关键属性;这些数字的组成部分是分段讨论的。 状态 表-2-1 在所有服务器上持久存在的 名称 描述 currentTerm 服务器最后知道的任期号（从0开始递增） votedFor 当前任期内收到选票的 候选人 id（如果没有就为null） log[] 日志条目；，诶个条目包含状态机的要执行命令和从 `领导者 出收到的任期号 在所有服务器上不稳定存在的 名称 描述 commitIndex 已知的被提交的最大日志条目的索引值（从0开始递增） lastApplied 被状态机执行的额最大日志条目的索引值（从0开始递增） 在领导人服务器上不稳定存在的（在选举之后初始化的） 名称 描述 nextIndex[] 对于每个服务器，记录需要发给它的下一个日志条目的索引（初始化为Leader上一条日志索引+1） natchIndex[] 对于每一个服务器，记录已经复制到该拂去其的日志的最高索引值（从0开始递增） 附加日志远程调用（AppendEntries RPC）由领导人来调用复制日志 表-2-2 参数 描述 term 领导人的任期号 leaderId 领导人的id，为了其他服务器能重定向到Leader prevLogIndex 最新日志之前的日志的索引值 prevLogTerm 最新日志之前的日志的领导人任期号 entries[] 要存储的日志条目（表示heartbeat时为空，有时会为了效率发送多条） leaderCommit 领导人提交的日志条目索引值 返回值 描述 term 当前的任期号，用于 Leader 更新自己的任期号 success 如果其他服务器包含能够匹配上 prevLogIndex 和 prevLogTerm 的日志时为真 Follower需要实现： 如果 term &lt; currentTerm 返回false 如果在 prevLogIndex 处的日志的任期号与 prevLogTerm 不匹配时，返回false 如果一条已经存在的日志与新的冲突（index 相同但任期号 term 不同），则删除已经存在的日志和它之后的所有日志 添加任何在以后日志中不存在的条目 如果 leaderCommit &gt; commitIndex，将 commitIndex 设置为 leaderCommit 和最新日志条目索引号中较小的一个 投票请求RPC（RequestVote RPC）由候选人发起收集选票 表-2-3 参数 描述 term 领导人的任期号 candidateId 请求投票的候选人id lastLogIndex 候选人最新日志条目的索引值 lastLogTerm 候选人最新日志条目对应的任期号 返回值 描述 term 当前的任期号，用于 候选人 更新自己的任期号 voteGranted 如果候选人收到选票为true 接受者需要实现 如果 term &lt; currentTerm 返回false 如果 votedFor 为空或者与 candidateId 相同，并且候选人的日志和自己的日志一样新，则给候选人投票。 服务器需要遵守的规则所有服务器 如果 commitIndex &gt; lastApplied，lastApplied 自增，将 log[lastApplied] 应用到状态机； 如果RPC的请求或者响应中包含一个 Term &gt; currentTerm，则 currentTerm 赋值为 Term，并切换状态为Follower； Follower 响应来自候选人和领导人的RPC请求 如果在超过选取 Leader 时间之前没有收到来自领导人的 AppendEntries RPC 或者没有收到候选人的投票请求，则自己转换状态为候选人 Candidate 转变为 Candidate 之后开始选举 currentTerm 自增 给自己投票 重置选举计时器 向其他服务器发送 RequestVote RPC 如果收到了来自大多数服务器的投票，则成为领导人 如果收到了来自新 Leader 的 AppendEntries RPC(heartbeat)，则成为 Follower 如果选举超时，开始新一轮选举 Leader 一旦成为领导人：想起他所有服务器发送空的 AppendEntries PRC(heartbeat)；在空闲时间重复发送以防止选举超时 如果收到来自客户端的请求，向本地日子增加条目，在该条目应用到状态机后响应客户端 对于一个 Followed 来说，如果上一次收到的日志索引大于将要收到的日志索引(nextIndex)：通过 AppendEntries RPC 将 nextIndex 之后的所有日志条目发送出去 如果发送成功：将该 Follower 的 nextIndex 和 matchIndex 更新 如果由于日志不一致导致 AppendEntries RPC 失败：nextIndex 递减并且重新发送 如果存在一个满足 N &gt; commitIndex 和 matchIndex[i] &gt;= N 并且 log[N].term == currentTerm的 N，则将 commitIndex 赋值为N Raft 一致性算法的总结（不包括成员变化和日志压缩） 表-3 Raft 算法保证这些特性任何时刻都能成立 性质 描述 选举安全原则(Election Safety) 一个任期 (Term) 内最多允许有一个 Leader 被选上 领导者只增加原则(Leader Append-Only) Leader 永远不会覆盖或删除自己的日志，只会增加条目 日志匹配原则(Log Matching) 如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置的条目完全相同。 领导者完全原则(Leader Completeness) 如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期更大的 Leader 中 状态机安全原则(State Machine Safely) 如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目 Raft 通过首先选出一个领导人来实现一致性，然后给予领导人完全管理复制日志（replicated log）的责任。领导人接收来自客户端的日志条目，并把它们复制到其他的服务器上，领带人还要告诉服务器们什么时候将日志条目应用到它们的状态机是安全的。通过选出领导人能够简化复制日志的管理工作。例如，领导人能够决定将新的日志条目放到哪，而并不需要和其他的服务器商议，数据流被简化成从领导人流向其他服务器。如果领导人宕机或者和其他服务器失去连接，就可以选取下一个领导人。 通过选出 Leader 的方法，Raft 将共识问题分解为三个相对独立的子问题，这些子问题在下面的子部分中讨论: Leader 选举: 当现有 Leader 失败时，必须选出新的 Leader。 日志复制（Log replication）： 领导人必须从客户端接收日志然后复制到集群中的其他服务器，并且强制要求其他服务器的日志保持和自己相同 安全性（Safety）： Raft 的关键的安全特性是 表-3 中提到的状态机安全原则（State Machine Safety）:如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目。5.4节阐述了 Raft 是如何保证这条原则的，解决方案涉及到一个对于选举机制另外的限制，这一部分会在 5.2节 中说明。 在说明了一致性算法之后，本章会讨论有关可用性（availability）的问题和系统中时序（timing）的问题。 5.1. Raft基础一个 Raft 集群包括若干服务器；对于一个典型的 5 服务器集群，该集群能够容忍 2 台机器不能正常工作，而整个系统保持正常。在任意的时间，每一个服务器一定会处于以下三种状态中的一个：领导人、候选人、追随者。在正常情况下，只有一个服务器是领导人，剩下的服务器是追随者。追随者们是被动的：他们不会发送任何请求，只是响应来自领导人和候选人的请求。领导人来处理所有来自客户端的请求（如果一个客户端与追随者进行通信，追随者会将信息发送给领导人）。候选人是用来选取一个新的领导人的，这一部分会在 5.2节 进行阐释。图-4 阐述了这些状态，和它们之间的转换；它们的转换会在下边进行讨论。 服务器的状态。追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。 时间被分为一个个的任期（term），每一个任期的开始都是领导人选举。在成功选举之后，一个领导人会在任期内管理整个集群。如果选举失败，该任期就会因为没有领带人而结束。这个转变会在不同的时间的不同服务器上观察到。 如 图-5 所示，Raft 算法将时间划分成为任意不同长度的 任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），就像 5.2 节 所描述的那样，一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最少要有一个领导人。 不同的服务器可能会在任期内观察到多次不同的状态转换，在某些情况下，一台服务器可能看不到一次选举或者一个完整的任期。任期在 Raft 中充当逻辑时钟的角色，并且它们允许服务器检测过期的信息，比如过时的领导人。每一台服务器都存储着一个当前任期的数字，这个数字会单调的增加。当服务器之间进行通信时，会互相交换当前任期号；如果一台服务器的当前任期号比其它服务器的小，则更新为较大的任期号。如果一个候选人或者领导人意识到它的任期号过时了，它会立刻转换为追随者状态。如果一台服务器收到的请求的任期号是过时的，那么它会拒绝此次请求。 Raft 中的服务器通过远程过程调用（RPC）来通信，基本的 Raft 一致性算法仅需要 2 种 RPC。RequestVote RPC 是候选人在选举过程中触发的（5.2节），AppendEntries RPC 是领导人触发的，为的是复制日志条目和提供一种 心跳（heartbeat） 机制（5.3节）。第7章加入了第三种 RPC 来在各个服务器之间传输 快照（snapshot）。如果服务器没有及时收到 RPC 的响应，它们会重试，并且它们能够并行的发出 RPC 来获得最好的性能。 5.2. 领导人选举Raft 使用一种 心跳机制（heartbeat） 来触发领导人的选取。当服务器启动时，它们会初始化为追随者。一太服务器会一直保持追随者的状态只要它们能够收到来自领导人或者候选人的有效 RPC。领导人会向所有追随者周期性发送 心跳（heartbeat，不带有任何日志条目的 AppendEntries RPC） 来保证它们的领导人地位。如果一个追随者在一个周期内没有收到心跳信息，就叫做 选举超时（election timeout） ,然后它就会假定没有可用的领导人并且开始一次选举来选出一个新的领导人。 为了开始选举，一个追随者会自增它的当前任期并且转换状态为候选人。然后，它会给自己投票并且给集群中的其他服务器发送 RequestVote RPC 。一个候选人会一直处于该状态，直到下列三种情形之一发生： 它赢得了选举； 另一台服务器赢得了选举； 一段时间后没有任何一台服务器赢得了选举 一个候选人如果在一个任期内收到了来自集群中大多数服务器的投票就会赢得选举。在一个任期内，一台服务器最多能给一个候选人投票，按照 先到先服务原则（first-come-first-served） （注意：在 5.4节 针对投票添加了一个额外的限制）。大多数原则使得在一个任期内最多有一个候选人能赢得选举 （表-3 中提到的选举安全原则） 。一旦有一个候选人赢得了选举，它就会成为 领导人 。然后它会像其他服务器发送心跳信息来建立自己的领导地位并且组织新的选举。 当一个 候选人 等待别人的选票时，它有可能会收到来自其他服务器发来的声明其为领导人的 AppendEntries RPC 。如果这个领导人的 任期（包含在它的 RPC 中） 比当前候选人的当前任期要大，则候选人认为该领导人合法，并且转换自己的状态为 追随者 。如果在这个 RPC 中的任期小于候选人的当前任期，则候选人会拒绝此次 RPC， 继续保持候选人 状态。 第三种情形是一个 候选人 既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。 Raft 使用 随机的选举超时时间 来确保第三种情形很少发生，并且能够快速解决。为了防止在一开始是选票就被瓜分，选举超时时间是在一个固定的间隔内随机选出来的（例如，150~300ms）。这种机制使得在大多数情况下只有一个服务器会率先超时，它会在其它服务器超时之前赢得选举并且向其它服务器发送心跳信息。同样的机制被用于选票一开始被瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，在超时进行下一次选举之前一直等待。这能够减小在新的选举中一开始选票就被瓜分的可能性。9.3节 展示了这种方法能够快速的选出一个领导人。 选举是一个理解性引导我们设计替代算法的一个例子。最开始时，我们计划使用一种排名系统：给每一个候选人分配一个唯一的排名，用于在竞争的候选人之中选择领导人。如果一个候选人发现了另一个比它排名高的候选人，那么它会回到追随者的状态，这样排名高的候选人会很容易地赢得选举。但是我们发现这种方法在可用性方面有一点问题（一个低排名的服务器在高排名的服务器宕机后，需要等待超时才能再次成为候选人，但是如果它这么做的太快，它能重置选举领带人的过程）。我们对这个算法做了多次调整，但是每次调整后都会出现一些新的问题。最终我们认为随机重试的方法是更明确并且更易于理解的。 5.3.日志复制一旦选出了领导人，它就开始接收客户端的请求。每一个客户端请求都包含一条需要被 复制状态机（replicated state machine） 执行的命令。领导人把这条命令作为新的日志条目加入到它的日志中去，然后并行的向其他服务器发起 AppendEntries RPC ，要求其它服务器复制这个条目。当这个条目被安全的复制之后（下面的部分会详细阐述），领导人会将这个条目应用到它的状态机中并且会向客户端返回执行结果。如果追随者崩溃了或者运行缓慢或者是网络丢包了，领导人会无限的重试 AppendEntries RPC （甚至在它向客户端响应之后）知道所有的追随者最终存储了所有的日志条目。 图-6：日志由有序编号的日志条目组成。每个日志条目包含它被创建时的任期号（每个方块中的数字），并且包含用于状态机执行的命令。如果一个条目能够被状态机安全执行，就被认为可以提交了。 日志就像 图-6 所示那样组织的。每个日志条目存储着一条被状态机执行的命令和当这条日志条目被领导人接收时的任期号。日志条目中的任期号用来检测在不同服务器上日志的不一致性，并且能确保 图-3 中的一些特性。每个日志条目也包含一个整数索引来表示它在日志中的位置。 领导人 决定什么时候将日志条目应用到状态机是安全的；这种条目被称为 可被提交（commited） 。 Raft 保证 可被提交（commited）的日志条目 是持久化的并且最终会被所有可用的状态机执行。一旦被领导人创建的条目已经复制到了大多数的服务器上，这个条目就称为可被提交的（例如，图-6中的7号条目）。领导人日志中之前的条目都是可被提交的（commited），包括由之前的领导人创建的条目。5.4节将会讨论当领导人更替之后这条规则的应用问题的细节，并且也讨论了这种提交方式是安全的。领导人跟踪记录它所知道的被提交条目的最大索引值，并且这个索引值会包含在之后的 AppendEntries RPC 中（包括心跳 heartbeat 中），为的是让其他服务器都知道这条条目已经提交。一旦一个追随者知道了一个日志条目已经被提交，它会将该条目应用至本地的状态机（按照日志顺序）。 我们设计了 Raft 日志机制来保证不同服务器上日志的一致性。这样做不仅简化了系统的行为使得它更可预测，并且也是保证安全性不可或缺的一部分。Raft 保证以下特性，并且也保证了 表-3 中的日志匹配原则 （Log Matching Property） : 如果在不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。 如果在不同日志中的两个条目有着相同的索引和任期号，则它们之间的所有条目都是完全一样的。 第一条特性源于 领导人 在一个任期里在给定的一个日志索引位置最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，领导人会把新日志条目紧接着之前的条目的索引位置和任期号都包含在里面。如果追随者没有在它的日志中找到相同索引和任期号的日志，它就会拒绝新的日志条目。这个一致性检查就像一个归纳步骤：一开始空的日志的状态一定是满足日志匹配原则的，一致性检查保证了当日志添加时的日志匹配原则。因此，只要 AppendEntries 返回成功的时候，领导人就知道追随者们的日志和它的是一致的了。 图-7：当最上边的领导人掌权之后，追随者日志可能有以下情况（a~f）。一个格子表示一个日志条目；格子中的数字是它的任期。一个追随者可能会丢失一些条目（a, b）；可能多出来一些未提交的条目（c, d）；或者两种情况都有（e, f）。例如，场景 f 在如下情况下就会发生：如果一台服务器在任期2时是领导人并且往它的日志中添加了一些条目，然后在将它们提交之前就宕机了，之后它很快重启了，成为了任期3的领导人，又往它的日志中添加了一些条目，然后在任期2和任期3中的条目提交之前它又宕机了并且几个任期内都一直处于宕机状态。 在一般情况下， 领导人 和 追随者们 的日志保持一致，因此 AppendEntries 一致性检查通常不会失败。然而， 领导人 的崩溃会导致日志不一致（旧的领导人可能没有完全复制完日志中的所有条目）。这些不一致会导致一系列领导人和追随者崩溃。 图-7 阐述了一些 追随者 可能和 新的领导人 日志不同的情况。一个 追随者 可能会丢失掉领导人上的一些条目，也有可能包含一些 领导人 没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。 在 Raft 算法中， 领导人 通过 强制追随者们复制它的日志 来处理日志的不一致。这就意味着，在追随者上的冲突日志会被领导者的日志覆盖。5.4节会说明当添加了一个额外的限制之后这是安全的。 为了使得追随者的日志同自己的一致， 领导人 需要找到追随者同它的日志一致的地方，然后删除追随者在该位置之后的条目，然后将自己在该位置之后的条目发送给追随者。这些操作都在 AppendEntries RPC 进行一致性检查时完成。领导人给每一个追随者维护了一个 nextIndex ，它表示领导人将要发送给该追随者的下一条日志条目的索引。当一个领导人开始掌权时，它会将 nextIndex 初始化为 它的最新的日志条目索引数+1（图-7 中的 11） 。如果一个追随者的日志和领导者的不一致，AppendEntries 一致性检查会在下一次 AppendEntries RPC 时返回失败。在失败之后，领导人会将 nextIndex 递减然后重试 AppendEntries RPC 。最终 nextIndex 会达到一个领导人和追随者日志一致的地方。这时，AppendEntries 会返回成功，追随者中冲突的日志条目都被移除了，并且添加所缺少的上了领导人的日志条目。一旦 AppendEntries 返回成功，追随者和领导人的日志就一致了，这样的状态会保持到该任期结束。 如果需要的话，算法还可以进行优化来减少 AppendEntries RPC 失败的次数。例如，当拒绝了一个 AppendEntries 请求，追随者可以记录下冲突日志条目的任期号和自己存储那个任期的最早的索引。通过这些信息，领导人能够直接递减nextIndex跨过那个任期内所有的冲突条目；这样的话，一个冲突的任期需要一次 AppendEntries RPC，而不是每一个冲突条目需要一次 AppendEntries RPC。在实践中，我们怀疑这种优化是否是必要的，因为 AppendEntries 一致性检查很少失败并且也不太可能出现大量的日志条目不一致的情况。 通过这种机制，一个领导人在掌权时不需要采取另外特殊的方式来恢复日志的一致性。它只需要使用一些常规的操作，通过响应 AppendEntries 一致性检查的失败能使得日志自动的趋于一致。一个领导人从来不会覆盖或者删除自己的日志（表-3 中的领导人只增加原则）。 这个日志复制机制展示了在第2章中阐述的所希望的一致性特性：Raft 能够接受，复制并且应用新的日志条目只要大部分的服务器是正常的。在通常情况下，一条新的日志条目可以在一轮 RPC 内完成在集群的大多数服务器上的复制；并且一个速度很慢的追随者并不会影响整体的性能。]]></content>
      <categories>
        <category>Raft</category>
      </categories>
      <tags>
        <tag>Raft</tag>
        <tag>文献翻译</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raft协议(1)——一致性原理分析]]></title>
    <url>%2Fblog%2F2018%2F04%2F14%2FRaft%E5%8D%8F%E8%AE%AE-1-%E2%80%94%E2%80%94%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述在一个由 Raft 协议组织的集群中有三类角色： Leader（领袖） Follower（群众） Candidate（候选人） 就像一个民主社会，领袖由民众投票选出。刚开始没有领袖，所有集群中的参与者都是群众，那么首先开启一轮大选，在大选期间所有群众都能参与竞选，这时所有群众的角色就变成了候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除领袖的候选人又变回群众角色服从领袖领导。这里提到一个概念「任期」，用术语 Term 表达。关于 Raft 协议的核心概念和术语就这么多而且和现实民主制度非常匹配，所以很容易理解。三类角色的变迁图如下，结合后面的选举过程来看很容易理解。 Raft 集群中节点状态转化 Leader 选举过程在极简的思维下，一个最小的 Raft 民主集群需要三个参与者（如下图：A、B、C），这样才可能投出多数票。初始状态 ABC 都是 Follower，然后发起选举这时有三种可能情形发生。下图中前二种都能选出 Leader，第三种则表明本轮投票无效（Split Votes），每方都投给了自己，结果没有任何一方获得多数票。之后每个参与方随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。这里的关键就是随机 timeout，最先从 timeout 中恢复发起投票的一方向还在 timeout 中的另外两方请求投票，这时它们就只能投给对方了，很快达成一致。 选出 Leader 后，Leader 通过定期向所有 Follower 发送心跳信息维持其统治。若 Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了再次发起选主过程。 Leader 节点对一致性的影响Raft 协议强依赖 Leader 节点的可用性来确保集群数据的一致性。数据的流向只能从 Leader 节点向 Follower 节点转移。当 Client 向集群 Leader 节点提交数据后，Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，确保至少集群中超过半数节点已接收到数据后再向 Client 确认数据已接收。一旦向 Client 发出数据接收 Ack 响应后，表明此时数据状态进入已提交（Committed），Leader 节点再向 Follower 节点发通知告知该数据状态已提交。 在这个过程中，主节点可能在任意阶段挂掉，看下 Raft 协议如何针对不同阶段保障数据一致性的。 数据到达 Leader 节点前这个阶段 Leader 挂掉不影响一致性，不多说。 数据到达 Leader 节点，但未复制到 Follower 节点这个阶段 Leader 挂掉，数据属于未提交状态，Client 不会收到 Ack 会认为超时失败可安全发起重试。Follower 节点上没有该数据，重新选主后 Client 重试重新提交可成功。原来的 Leader 节点恢复后作为 Follower 加入集群重新从当前任期的新 Leader 处同步数据，强制保持和 Leader 数据一致。 数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader响应这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态（Uncommitted）但保持一致，重新选出 Leader 后可完成数据提交，此时 Client 由于不知到底提交成功没有，可重试提交。针对这种情况 Raft 要求 RPC 请求实现幂等性，也就是要实现内部去重机制。 数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接受这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态（Uncommitted）且不一致，Raft 协议要求投票只能投给拥有最新数据的节点。所以拥有最新数据的节点会被选为 Leader 再强制同步数据到 Follower，数据不会丢失并最终一致。 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client这个阶段 Leader 挂掉，Cluster 内部数据其实已经是一致的，Client 重复重试基于幂等策略对一致性无影响。 网络分区导致的脑裂情况，出现双 Leader网络分区将原先的 Leader 节点和 Follower 节点分隔开，Follower 收不到 Leader 的心跳将发起选举产生新的 Leader。这时就产生了双 Leader，原先的 Leader 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 Leader 提交数据可以提交成功，网络恢复后旧的 Leader 发现集群中有更新任期（Term）的新 Leader 则自动降级为 Follower 并从新 Leader 处同步数据达成集群数据一致。 算法以正确性、高效性、简洁性作为主要设计目标。虽然这些都是很有价值的目标，但这些目标都不会达成直到开发者写出一个可用的实现。所以我们相信可理解性同样重要。]]></content>
      <categories>
        <category>Raft</category>
      </categories>
      <tags>
        <tag>Raft</tag>
        <tag>一致性算法</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ-(5)——ActiveMQ结合Spring开发]]></title>
    <url>%2Fblog%2F2018%2F04%2F14%2FActiveMQ-5-%E2%80%94%E2%80%94ActiveMQ%E7%BB%93%E5%90%88Spring%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[步骤依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;&lt;/dependency&gt; 在Spring中配置jmsTemplate12345678910111213141516171819202122&lt;!--JMS连接池工厂--&gt;&lt;bean id="jmsFactory" class="org.apache.activemq.pool.PooledConnectionFactory" destroy-method="stop"&gt; &lt;property name="connectionFactory"&gt; &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://localhost:61616"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="maxConnections" value="100"/&gt;&lt;/bean&gt;&lt;!--目的地--&gt;&lt;bean id="destination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg index="0" value="spring-queue"/&gt;&lt;/bean&gt;&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;property name="connectionFactory" ref="jmsFactory"/&gt; &lt;property name="defaultDestination" ref="destination"/&gt; &lt;property name="messageConverter"&gt; &lt;bean class="org.springframework.jms.support.converter.SimpleMessageConverter"/&gt; &lt;/property&gt;&lt;/bean&gt; 如果是topic 添加topic的配置 修改jmsTemplate配置中的defaultDestination 12345678910111213141516171819202122&lt;!--JMS连接池工厂--&gt;&lt;bean id="jmsFactory" class="org.apache.activemq.pool.PooledConnectionFactory" destroy-method="stop"&gt; &lt;property name="connectionFactory"&gt; &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://localhost:61616"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="maxConnections" value="100"/&gt;&lt;/bean&gt;&lt;!--目的地--&gt;&lt;bean id="destination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg index="0" value="spring-topic"/&gt;&lt;/bean&gt;&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;property name="connectionFactory" ref="jmsFactory"/&gt; &lt;property name="defaultDestination" ref="destination"/&gt; &lt;property name="messageConverter"&gt; &lt;bean class="org.springframework.jms.support.converter.SimpleMessageConverter"/&gt; &lt;/property&gt;&lt;/bean&gt; 如果在Spring中配置消费者的话，就不需要启动消费者相当于注册了一个默认消息监听器 当JMS Provider接受到消息之后就会触发listener的onMessage()方法 1234567&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="jmsFactory"/&gt; &lt;property name="destination" ref="destination"/&gt; &lt;property name="messageListener" ref="messageListener"/&gt;&lt;/bean&gt;&lt;bean id="messageListener"class="org.destiny.activemq.spring.MyMessageListener"/&gt; 12345678910111213package org.destiny.activemq.spring;public class MyMessageListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("receive: " + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最佳实践 Camel框架支持大量的企业集成模式，可以大大简化集成组件间的大量服务和复杂的消息流。而Spring更注重简单性。 Spring消息发送的核心架构是JmsTemplate，隔离了像打开、关闭Session和Producer等操作。因此应用开发人员仅仅需要关注实际的业务逻辑。但JmsTemplate损害了ActiveMQ的PooledConnectionFactory对Session和消息Producer的缓存机制带来的性能提升。 新的Spring中，可以设置org.springframework.jms.connection.CachingConnectionFactory的sessionCacheSize，或者直接使用ActiveMQ的PooledConnectionFactory。 不建议使用JmsTemplate的receive()，因为JmsTemplate上的所有调用都是同步的，这意味着调用的线程会阻塞，直到方法返回，性能影响较大。 尽量使用DefaultMessageListenerContainer，它允许异步接受消息并缓存session和消息Consuer。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(4)——Broker的启动方式]]></title>
    <url>%2Fblog%2F2018%2F04%2F12%2FActiveMQ-4-%E2%80%94%E2%80%94Broker%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Broker：相当于一个ActiveMQ服务器实例。 命令行启动参数示例 activemq start：默认使用acitvemq.xml来启动 activemq start xbean:file:../conf/activemq.xml：使用指定的配置文件来启动。 用ActiveMQ来构建Java应用用ActiveMQ Broker作为独立的消息服务器来构建JAVA应用。ActiveMQ也支持在VM中通信基于嵌入式的Broker，能够无缝集成其他Java应用。 嵌入式BrokerBrokerService启动Broker1234567public static void main(String[] args) throws Exception &#123; // 开启ActiveMQ Broker BrokerService brokerService = new BrokerService(); brokerService.setUseJmx(true); brokerService.addConnector("tcp://localhost:61616"); brokerService.start();&#125; BrokerFactory启动Broker1234567public static void main(String[] args) throws Exception &#123; // 开启ActiveMQ Broker String uri = "properties:broker.properties"; BrokerService brokerService = BrokerFactory.createBroker(new URI(uri)); brokerService.addConnector("tcp://localhost:61616"); brokerService.start();&#125; 配置文件broker.properties123useJmx=truepersistent=falsebrokerName=Cheese 利用Spring集成Broker123456789&lt;bean id="broker" class="org.apache.activemq.broker.BrokerService" init-method="start" destroy-method="stop"&gt; &lt;property name="brokerName" value="myBroker"/&gt; &lt;property name="persistent" value="false"/&gt; &lt;property name="transportConnectorURIs"&gt; &lt;list&gt; &lt;value&gt;tcp://localhost:61616&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 启动多个Broker如果需要启动多个Broker，那么需要为每个Broker设置一个名字12]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(3)——JMS可靠性机制]]></title>
    <url>%2Fblog%2F2018%2F04%2F12%2FActiveMQ-3-%E2%80%94%E2%80%94JMS%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[消息接受确认JMS消息只有在被确认之后，才认为已经被成功地消费了。消费的成功通常包含三个阶段：客户端接受消息、客户端处理消息和消息被确认。在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。该参数有三个可选方案： Session.AUTO_ACKNOWLEDGE当客户成功的从receive()方法返回的时候，或者从MessageListener.onMessage()方法成功返回的时候，会话自动确认客户端收到的消息。 Session.CLIENT_ACKNOWLEDGE客户端通过调用消息的acknowledge()方法确认消息。在这种模式中，确认是在会话层上进行，确认一个被消费的消息将自动确认所有已被会话消费的消息。 1Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE); Session.DUPS_ACKNOWLEDGE只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS Provider必须把消息头的JMSRedelivered字段设置为true 消息的持久性，JMS支持两种消息提交模式PERSISTENTJMS Provider永久保存消息，以保证消息不会因为JMS Provider的失败而丢失。 NON_PERSISTENT不要求JMS Provider持久保存消息 消息的临时目的地可以通过Session的createTemporaryQueue()和createTemporaryTopic()方法来创建临时目的地。他们的存在时间只限于创建他们的连接所保持的时间，只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。 本地事务在一个JMS客户端，可以使用本地事务来组合消息的发送和签收。Session接口提供了commit()和rollback()方法。 事务提交意味着生产的所有消息被发送，消费的所有消息被确认。 事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非他们已过期。 PTP模型该模型定义了客户端如何向队列发送消息，从队列接受消息。 PTP模型是基于队列的，生产者发消息到队列，消费者从队列接受消息，队列使得消息的异步传输成为可能。 特点 Session在关闭时，如果有消息已经被接受，但还没有确认，那么当消费者下次连接到相同的队列时，这些消息还会被再次接受。 如果用户在receive()方法中设定了消息选择条件，那么不符合条件的消息会留在队列中。 队列可以长久地保存消息直到消费者收到消息，消费者不需要因为担心消息丢失而时刻与队列保持激活的连接状态。 Pub/Sub模型该模型定义了如何向一个内容节点发布和订阅消息。 主题可以被认为是消息的传输中介，发布者发布消息到主题，订阅者从主题订阅消息，二者相互独立，不需要接触。 特点 消息订阅分为非持久订阅和持久订阅 非持久订阅时，只有当客户端处于激活状态才能收到某个主题的消息；离线时发布到主题的消息将会丢失。 持久订阅时，客户端向JMS Provider注册一个自己身份的ID，当客户端处于离线状态时，Provider会为这个ID保存所有发送到主题的消息。 如果用户在receive()方法中设定了消息选择条件，那么不符合条件的消息不会被接收。 非持久订阅状态下，不能恢复或重新派送一个未签收的消息。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(2)——JMS规范]]></title>
    <url>%2Fblog%2F2018%2F04%2F11%2FActiveMQ-2-%E2%80%94%E2%80%94JMS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[定义JMS(Java Message Service)，Java消息服务 JMS定义了Java访问消息中间件的接口，并没有给予实现。 实现JMS接口的消息中间件成为JMSProvider，如ActiveMQ。 JMS规范 JMS message：JMS的消息，由三部分组成：消息头、消息属性、消息体 JMS Producer：消息生产者，创建和发送消息 JMS Consumer：消息消费者，接受和处理消息，消息的消费可以采用以下两种方式之一： 同步消费：通过调用消费者的receive方法从目的地中显示提取消息，receive方法可以一直阻塞到消息到达 异步消费：客户可以为消费者注册一个Listener，以定义在消息到达时所采取的动作。 JMS domains：消息传递域，JMS定义了两周消息传递域： 点对点：每个消息只能有一个消费者，生产者和消费者没有时间上的相关性，无论消费者在生产者发送消息的时候是否处于运行状态，都可以提取消息； 发布订阅：每个消息可以被多个消费者消费，生产者和消费者有时间上的相关性，订阅一个主题的消费者只能消费它订阅之后发布的消息 ConnectionFactory：连接工厂，用来创建连接对象，已连接到JMS的Provider JMS Connection：封装了客户与JMS提供者之间的一个虚拟连接 JMS Session：是生产和消费消息的一个单线程上下文 会话用于创建消息生产者、消费者和消息等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接受被组合到了一个原子操作中。 Destination：消息发送到的目的地。 Acknowledge：签收。消费者收到消息后，需要告诉JMS Provider消息已被消费。 Transaction：事务 JMS Client：用来收发消息的Java应用 JMS Message结构组成 消息头 属性 消息体 消息头消息头包含识别信息和路由信息 JMSDestination：消息发送的目的地，主要是指Queue或Topic。 JMSDeliveryMode：传送模式，持久或非持久。 持久消息应该会且只会被发送一次，JMS提供者出现故障，消息也不会丢失，会在服务器恢复之后再次传递。 非持久的消息最多会被发送一次，这意味着服务器出现故障，该消息会永远丢失。 JMSExpiration：消息过期时间，为0表示永不过期。 JMSPriority：消息优先级，数字越大，级别越高，加急消息要先于普通消息。 JMSMessageId：唯一标识。 JMSCorrelationID：用来连接到另一个消息，典型应用是在回复消息中关联到原消息。 JMSReplyTo：提供本消息回复消息的目的地址，由开发者提供 JMSType：消息的类型识别符 JMSRedelivered：如果一个客户端收到了一个设置了JMSRedelivered属性的消息，则表示客户端可能收到过该消息，但没有签收。 消息体 TextMessage：文本消息 MapMessage：映射消息 BytesMessage：二进制消息 StreamMessage：流式消息 ObjectMessage：对象消息 属性应用程序设置和添加的属性1message.setStringProperty("username", username); JMS定义的属性12// 返回所有连接支持的JMSX属性的名字connection.getMetaData().getJMSXPropertyNames(); JMS供应商特定的属性JMS定义的属性 JMSXUserID：发送消息的用户标识 JMSXAppID：发送消息的应用标识 JMSXDeliveryCount：转发消息重试次数 JMSXGroupID：消息所在的消息组的标识 JMSXGroupSeq：组内消息的序号]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(1)——概览&入门]]></title>
    <url>%2Fblog%2F2018%2F04%2F09%2FActiveMQ-1-%E2%80%94%E2%80%94%E6%A6%82%E8%A7%88-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[概览ActiveMQ简介 什么是ActiveMQ ActiveMQ的作用 ActiveMQ的特点 消息中间件的功能、特点、应用场景等 ActiveMQ安装和基本使用通过源码安装、基本的配置实例、启动、测试运行、关闭等 JMS基本概念、消息结构、可靠性机制、PTP、Pub/Sub、API结构、JMS应用开发的基本步骤、持久和非持久的Topic 同ActiveMQ构建应用 多种启动Broker的方法 单独应用的开发 结合Spring开发 ActiveMQ的Transport多种运输协议的功能、配置和使用 ActiveMQ的消息存储队列和Topic、KahaDB、AMQ、JDBC、MMS等 ActiveMQ的Network 在一台服务器上启动多个Broker 静态网络连接的功能、配置 “丢失”消息的处理 容错或可负载均衡的连接 动态网络连接等 ActiveMQ集群 队列消费者集群 Broker的集群 MasterSlave等 Destination高级特性 通配符 组合队列 配置启动的Destination 删除不活动的Destination 虚拟Destination 镜像队列 Message Dispatch高级特性 消息游标 异步发送 分发策略 优化批量控制 Message高级特性 消息属性 Advisory Message 延迟和定时消息投递 Blob消息 消息转换 Consumer高级特性 消息异步分发 消息优先级 管理持久化消息 消息分组 消息重抵策略 杂项 监控和管理 集成ActiveMQ和Tomcat ActiveMQ优化ActiveMQ简介介绍ActiveMQ是Apache推出的一款开源的、完全支持JMS和J2EE规范的JMSProvider实现的消息中间件(Message Oriented Middleware, MOM)。 作用用来帮助实现高可用、高性能、可伸缩、易用和安全的企业级面向消息服务的系统。 ActiveMQ安装和基本使用下载并安装服务端 从http://activemq.apache.org/download.html下载最新的ActiveMQ 直接解压1$ tar -zxvf apache-activemq-5.9.0-bin.tar.gz activemq 启动运行 普通启动 1234$ pwd/usr/local/activemq/bin$ ./activemq start 启动并指定日志文件 1$ ./activemq start &gt; /tmp/activemqlog 检查是否已经启动ActiveMQ默认采用61616端口提供JMS服务，使用8061端口提供管理控制台服务，执行以下命令以便检验是否已经成功启动ActiveMQ服务： 查看61616端口是否已经打开： netstat -an | grep 61616 查看控制台输出或者日志文件 直接访问ActiveMQ的管理页面：http://localhost:8161/admin，默认的用户名和密码是admin/admin 关闭ActiveMQ1$ ./activemq stop 基本的消息发送配置MAVEN所需的依赖12345678910&lt;dependency&gt; &lt;gruopId&gt;org.apache.activemq&lt;/gruopId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;gruopId&gt;org.apache.xbean&lt;/gruopId&gt; &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt;&lt;/dependency&gt; 消息生产者123456789101112131415161718192021222324252627public static void main(String[] args) throws JMSException, InterruptedException &#123; // 创建连接工厂，连接工程负责与ActiveMQ服务端建立连接 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616"); // 由连接工厂创建连接 Connection connection = connectionFactory.createConnection(); // 启动连接 connection.start(); // 通过连接创建会话 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); // 通过会话创建目的地，名称表示对列名 Destination destination = session.createQueue("my-queue"); // 通过 session 创建生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; ++i) &#123; TextMessage message = session.createTextMessage("message -- " + i); Thread.sleep(100); // 通过消息生产者发出消息 producer.send(message); System.out.println("创建成功"); &#125; session.commit(); session.close(); connection.close();&#125; 运行结果： 消息消费者123456789101112131415161718192021222324public static void main(String[] args) throws JMSException, InterruptedException &#123; // 创建连接工厂，连接工厂负责与ActiveMQ服务端建立连接 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616"); // 由连接工厂创建连接 Connection connection = connectionFactory.createConnection(); // 启动连接 connection.start(); // 通过连接创建会话 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); // 通过会话创建目的地，名称表示对列名 Destination destination = session.createQueue("my-queue"); // 通过 session 创建生产者 MessageConsumer consumer = session.createConsumer(destination); for (int i = 0; i &lt; 100; ++i) &#123; TextMessage message = (TextMessage) consumer.receive(); session.commit(); System.out.println("收到消息: " + message.getText()); &#125; session.close(); connection.close();&#125; 运行结果： JMS模型]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盘点实际项目中常用的加密算法及使用场景]]></title>
    <url>%2Fblog%2F2018%2F04%2F08%2F%E7%9B%98%E7%82%B9%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[MD5定义MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 特点 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等。 应用场景一致性验证MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。MD5就可以为任何文件（不管其大小、格式、数量）产生一个同样独一无二的“数字指纹”，如果任何人对文件做了任何改动，其MD5值也就是对应的“数字指纹”都会发生变化。 数字签名MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。 安全访问认证MD5还广泛用于操作系统的登陆认证上，如Unix、各类BSD系统登录密码、数字签名等诸多方面。如在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。 缺点与不足2014年中国山东大学的王小云教授公布破译了MD5、HAVAL-128、 MD4和RIPEMD算法的报告。通过加速的杂凑与冲撞方法破译了MD5算法。 实践 RSA定义RSA为公钥加密体制 乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 甲方获取乙方的公钥，然后用它对信息加密。 乙方得到加密后的信息，用私钥解密。 特点便于理解，使用广泛RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。 缺点与不足：加密和解密花费时间长、速度慢，只适合对少量数据进行加密为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要。 实践ssh口令登录1234567sequenceDiagram客户端-&gt;&gt;服务端: 口令登录服务端-&gt;&gt;客户端: 发送1024为公钥指纹客户端-&gt;&gt;服务端: 指纹保存在$HOME/.ssh/known_hosts，接受远程主机秘钥服务端-&gt;&gt;客户端: 请求输入密码客户端-&gt;&gt;服务端: 输入密码服务端-&gt;&gt;客户端: 接受或拒绝链接 ssh公钥登录12345sequenceDiagram客户端-&gt;&gt;服务端: 登录请求服务端-&gt;&gt;客户端: 发送随机字符串客户端-&gt;&gt;服务端: 发送加密后的随机字符串服务端-&gt;&gt;客户端: 接受或拒绝链接 客户端事先把自己的公钥保存在服务端的指定目录: $HOME/.ssh/authorized_keys 客户端生成秘钥: ssh-keygen，运行结束后，在$HOME/.ssh/目录下，会新生成两个文件: id_rsa.pub和id_rsa。前者是公钥，后者是私钥。 将公钥发送给远程主机: ssh-copy-id user@host]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>算法</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）Nginx实现动静分离]]></title>
    <url>%2Fblog%2F2018%2F04%2F03%2F%EF%BC%88%E4%BA%8C%EF%BC%89Nginx%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[概念在反向代理时，如果是静态资源，就直接从Nginx发布的路径中去读取，而不需要从后台服务器获取。 但这种情况下需要保证后端跟前端的程序保持一致，可以使用Rsync做服务端自动同步或者使用NFS、MFS分布式共享存储。 概念图 原理Nginx可以拦截请求 因此可以利用这一特性，将拦截到的静态请求进行重定向。 12345678910111213141516171819202122232425server &#123; listen 80; server_name destiny; access_log logs/host.access.log main; index index.html index.htm index.jsp; root /usr/local/tomcat-9.0.0-RC5-1/webapps/ROOT/; # 不区分大小写的正则匹配 location ~* .*\.(jpg|jepg|fig|png|wsf|ico)$ &#123; if(-f $request_filename) &#123; # expires 15d; break; &#125; &#125; # 不区分大小写的正则匹配 locatin ~* .*\.(html|htm|js|css)$ &#123; # expires 1d; &#125; location / &#123; proxy_pass http://10.211.55.5 &#125;&#125; 在前两个location中，没有配置后端服务器的路径Nginx就会默认去寻找root的资源 Nginx会以root为根路径，将请求的路径拼在其后去查找，如果能访问到，Nginx就可以直接将该文件返回。 如果能够查询到响应的文件，就会直接返回。 指令index(默认主页设置模块)如果URL中没有指定文件，则设置一个默认主页。 可以指定多个文件，如果第一个文件没有找到，将会查找后面指定的文件 index index.html index.htm index.jsp root请求到达后的文件根目录 123location /i/ &#123; root /spool/w3;&#125; 如果请求/i/top.gif文件，Nginx将转到/spool/w3/i/top.gif文件 在请求中root会添加这个location到它的值后面，即”/i/top.gif”并不会请求”/spool/w3/top.gif”文件，如果要实现上述类似于apache alias的功能，可以使用alias指令。 简单来说，root是拼接，alias是替换。 实现当访问静态资源的请求进入(假设为http://10.211.55.4:80/static/person.jpg)时，会被配置文件中的第一个location拦截 location会将root中配置的路径和访问路径拼接在一起，新的路径为/usr/local/tomcat-9.0.0-RC5-1/webapps/ROOT/static/person.jpg，在Nginx的路径中进行查找。 初始情况，不加Nginx的情况下启动Tomcat 访问10.211.55.4:8080即可访问Tomcat主页。 查看logs/localhost_access_log.2018-04-03.txt可以看到访问日志 此时可以看到，请求了多个静态文件。 加入Nginx将包含上图中文件的路径/usr/local/apache-tomcat-7.0.73/webapps/ROOT/配置进Nginx配置文件中的root属性。 并配置location用于拦截jpg/jepg/fig/png/wsf/ico后缀的文件。 然后sbin/nginx -s reload重启Nginx 效果展示分别重启Tomcat和Nginx后，再访问10.211.55.4(Nginx自动监听80端口并转发至8080) 删除浏览器缓存 此时再查看日志，已经请求中已经不再对静态资源进行请求]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从头搭建github博客]]></title>
    <url>%2Fblog%2F2018%2F04%2F01%2F%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[安装Node.js并配置Node.js环境成功界面如下： 安装git并配置git环境 注册Github并新建项目首页 新建仓库页参考其他博客的时候，很多博客中都提到 项目名必须是 github账户名.github.io 但经本人测试其实项目名称可以任意选取，如本人的仓库名就是blog，而非destinywang.github.io 设置进入项目的setting选项卡中 下拉到Github Pages，此时该项目已经被部署，可以通过提供的外网链接去访问。 安装HexoHexo中文网站 Hexo是个快捷，简介且高效的博客框架 让上百个页面在几秒内完成渲染 Hexo支持Github Flavored Markdown的所有功能 在合适的位置创建文件夹 以上操作需要在空文件夹中进行 123$ npm install hexo -g # 安装Hexo$ hexo -v # 检查Hexo是否安装成功$ hexo init # 初始化文件夹 Hexo init npm install此命令用于安装所需要的组件 hexo g首次体验Hexo hexo s此命令会在本地开启Hexo的服务器 可以在发布到github之前先在本地进行调试 然后再浏览器中输入localhost:4000/blog/如果出现如下界面就成功了 将Hexo和Github page联系起来设置本地git如果是第一次使用git的话需要设置name和email 1234$ ssh-keygen -t rsa -C &quot;your email&quot; # 生成秘钥，路径在~/.ssh下，windows用户的路径为C:\Users\Administrator\.ssh$ eval &quot;$(ssh-agent -s)&quot; # 添加秘钥到ssh-agent$ ssh-add ~/.ssh/id_rsa # 添加生成的SSH key到ssh-agent 登录github，进行设置 进入用户的setting页面 在SSH and GPG keys选项卡中添加一个ssh key，并将id_rsa.pub(公钥)的内容复制上去 配置Deployment为了保证Hexo能够正确的通过Git进行add、commit、pull、push等操作需要将本地及远程的git仓库信息进行配置 当前站点文件夹的状态： 修改_config.yml文件，将deployment部分相关的内容进行替换 type: 部署类型 repository: 远程仓库路径，即github中的仓库路径 branch: 分支名 新建一篇博客在终端中执行命令hexo new post 博客名 会在source/_posts路径下生成对应的博客文件test.md 安装hexo-deployer-git扩展文件1$ npm install hexo-deployer-git --save 编辑文章1$ vim source/_posts/test.md 打开test.md文件，按照正常的Markdown文件编辑即可 部署123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$ hexo d -gINFO Start processingINFO Files loaded in 640 msINFO Generated: tags/index.htmlINFO Generated: about/index.htmlINFO Generated: 2018/04/01/jvm/index.htmlINFO Generated: 2018/04/01/test/index.htmlINFO Generated: 2018/04/01/hello-world-1/index.htmlINFO Generated: archives/index.htmlINFO Generated: tags/jvm/index.htmlINFO Generated: archives/2018/index.htmlINFO Generated: archives/2018/04/index.htmlINFO Generated: tags/java基础/index.htmlINFO Generated: index.htmlINFO Generated: 2018/04/01/hello-world/index.htmlINFO Generated: 2018/04/01/一-Nginx基本知识/index.htmlINFO Generated: tags/Nginx/index.htmlINFO Generated: images/cc-by-nc-nd.svgINFO Generated: images/avatar.gifINFO Generated: images/apple-touch-icon-next.pngINFO Generated: images/cc-by-nc-sa.svgINFO Generated: images/algolia_logo.svgINFO Generated: images/cc-by-nc.svgINFO Generated: images/cc-by-nd.svgINFO Generated: images/cc-by-sa.svgINFO Generated: images/cc-by.svgINFO Generated: images/cc-zero.svgINFO Generated: images/favicon-16x16-next.pngINFO Generated: images/favicon-32x32-next.pngINFO Generated: images/loading.gifINFO Generated: images/logo.svgINFO Generated: images/placeholder.gifINFO Generated: images/quote-r.svgINFO Generated: images/searchicon.pngINFO Generated: lib/font-awesome/css/font-awesome.css.mapINFO Generated: images/quote-l.svgINFO Generated: lib/font-awesome/HELP-US-OUT.txtINFO Generated: images/blog-logo.jpegINFO Generated: lib/font-awesome/fonts/fontawesome-webfont.woff2INFO Generated: css/main.cssINFO Generated: lib/font-awesome/fonts/fontawesome-webfont.woffINFO Generated: js/src/affix.jsINFO Generated: js/src/exturl.jsINFO Generated: js/src/algolia-search.jsINFO Generated: js/src/bootstrap.jsINFO Generated: js/src/love.jsINFO Generated: js/src/js.cookie.jsINFO Generated: js/src/post-details.jsINFO Generated: js/src/motion.jsINFO Generated: js/src/scrollspy.jsINFO Generated: js/src/scroll-cookie.jsINFO Generated: lib/font-awesome/bower.jsonINFO Generated: js/src/utils.jsINFO Generated: lib/ua-parser-js/dist/ua-parser.min.jsINFO Generated: lib/velocity/velocity.ui.min.jsINFO Generated: lib/velocity/velocity.min.jsINFO Generated: js/src/schemes/pisces.jsINFO Generated: lib/ua-parser-js/dist/ua-parser.pack.jsINFO Generated: lib/velocity/velocity.ui.jsINFO Generated: lib/font-awesome/css/font-awesome.cssINFO Generated: lib/jquery/index.jsINFO Generated: lib/font-awesome/css/font-awesome.min.cssINFO Generated: lib/font-awesome/fonts/fontawesome-webfont.eotINFO Generated: lib/velocity/velocity.jsINFO 61 files generated in 1.13 sINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master 966acc9] Site updated: 2018-04-01 21:18:16 1 file changed, 1 insertion(+), 1 deletion(-)To github.com:DestinyWang/blog.git + fa066f8...966acc9 HEAD -&gt; master (forced update)Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;git@github.com:DestinyWang/blog.git&apos;.INFO Deploy done: git 至此，博客已经部署成功，可以去http://用户名.github.io查看。 安装Next1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载到站点文件夹路径下的themes/next 启用Next主体在站点目录中，打开配置文件_config.yml，修改theme: next123$ pwd~/blog$ vim _config.yml 主题设定在next主题目录下的_config.yml，修改scheme: Pisces 123$ pwd~/blog$ vim themes/next/_config.yml 语言设定Hexo提供了多种语言支持，包括简体中文zh-Hans在站点根目录下修改配置文件_config.yml中的language为zh-Hans 123$ pwd~/blog$ vim _config.yml 修改菜单栏在主题目录下修改配置文件_config.yml中的menu 123$ pwd~/blog$ vim themes/next/_config.yml 设置菜单项图标对应字段是menu_icons同样在主题目录下的_config.yml中修改 格式为item name: icon name，其中item name 与所配置的菜单名字对应，icon name是Font Awesome图标的名字。而 enable可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123$ pwd~/blog$ vim themes/next/_config.yml 设置侧栏位置修改主题目录下sidebar的position值 123$ pwd~/blog$ vim themes/next/_config.yml 设置头像在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/目录下） 设置文章代码主题在主题目录下修改配置文件_config.yml，字段highlight_theme，默认值为nomal。可以设置为night 123$ pwd~/blog$ vim themes/next/_config.yml 添加分类在站点路径下新建页面categories 123456$ pwd~/blog$ hexo new page categories# 在 source/categories 目录中修改index.mdvim source/categories/index.md 12# 在主题的 _config.yml 中取消注释:$ vim _config.yml 在要分类的文章中加入 category 属性: 添加标签页面标签是对博客分类的方式比如一个系列的博客都是将神经网络，那么就可以给每篇博客加上神经网络的tag 1234567$ pwd~/blog$ hexo new page tagsINFO Created: ~/blog/source/tags/index.md# 在新建的index.md中添加type: &quot;tags&quot;vim source/tags/index.md 后面只需要在博客的开头中添加tags: [A, B, C]即可 成功后，标签部分的导航栏为 Aboute Me1234567$ pwd~/blog$ hexo new page aboutINFO Created: ~/blog/source/about/index.md# 在新建的index.md中添加如下内容vim source/about/index.md 成功后效果如下所示： 添加github导航条从这里选择主题 然后将代码复制到themes/next/layout/_layout.swig 123$ pwd~/blog$ vim themes/next/layout/_layout.swig 成功后的效果如下： 修改内容区域宽度默认情况Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 非Pisces Scheme主题修改1$ vim source/css_variables/custom.styl 修改内容： 12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px Pisces Scheme主题修改1$ vim themes\next\source\css\_schemes\Picses\_layout.styl 修改内容： 123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 设置首页不显示全文(只显示预览)打开主题路径下的_config.yml1$ vim themes/next/_config.yml 修改auto_excerpt12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将enable属性改为true 修改code代码块自定义样式1$ vim themes/next/source/css/_custom/custom.styl 取消文章目录对标题的自动编号 nexT对 markdown 语法的标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 会默认进行标号分配，这样有可能会打乱文章原有标题 取消方式： 修改主题配置文件 1$ vim theme/next/_config 将 number 设为 false 结束至此，博客基本设置OK但还有很多地方可以继续挖掘 后续会持续更新]]></content>
      <tags>
        <tag>github博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）Nginx基本知识]]></title>
    <url>%2Fblog%2F2018%2F04%2F01%2F%EF%BC%88%E4%B8%80%EF%BC%89Nginx%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[简介Nginx是一款轻量级的Web服务器，也是一款轻量级的反向代理服务器 用途 直接支持Rails和PHP程序 作为HTTP反向代理服务器 作为负载均衡服务器 作为邮件代理服务器 帮助实现动静分离 特点高稳定、高性能、资源占用少、功能丰富、模块化结构、支持热部署 安装Nginx 依赖gcc openssl-devel pcre-devel zlib zlib-devel 1yum install gcc openssl-devel pcre-devel zlib zlib-devel 安装 $ ./configure --prefix=/usr/local/nginx --withhttp_stub_status_module $ make $ make install 常见的Nginx安装配置选项 Nginx基本运行// 测试配置文件 $ sbin/nginx -t nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful // 启动 $ sbin/nginx // 停止 $ sbin/nginx -s stop $ sbin/nginx -s quit // 重启 $ sbin/nginx -s reload // 查看进程 ps -ef | grep nginx Nginx的基本配置默认启动Nginx的时候，使用的配置文件是conf/nginx.conf文件 也可以在启动Nginx的时候，通过-c来指定要去读的配置文件 常见的配置文件 文件名 用途 nginx.conf 应用程序的基本配置文件 mime.types MIME类型关联的扩展文件 fastcgi.conf 与fastcgi相关的配置，与PHP相关 proxy.conf 与proxy相关的配置（反向代理） sites.conf 配置Nginx提供的网站，包括虚拟主机 nginx.cong1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950user root;worker_processes 1;error_log logs/error.log crit;pid logs/nginx.pid; # nginx 进程号文件路径events &#123; # 事件模块 use epoll; # 文件的模型 worker_connections 24; # 每个worker的connections&#125;http &#123; # web反向代理 include mime.type; # 引入mime.type include proxy.conf; # 引入proxy.conf defualt_type application/octet-stream; # mine.type 的缺省类型 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot;&apos; # 日志格式，远程地址 - 远程用户 时间 等 &apos;$status $body_bytes_sent &quot;$http_referer&quot;&apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos; access_log logs/access.log main; # 使用为main的格式 upstream test.com &#123; # 负载均衡模块 server 127.0.0.1:8080 weight = 5; &#125; server &#123; lisent 80; server_name detiny; access_log logs/host.access.log main; index index.html index.htm index.jsp; root /Users/destiny/Download/apache-tomcat-9.0.1/webapps/ROOT/; location ~* .*\.(jpg|jepg|gif|png|wsf|ico)$ &#123; # 如果是图片，就去root路径查询 if(-f $request_filename) &#123; break; &#125; &#125; location / proxy_pass http://destiny.com; &#125; &#125;&#125; Nginx的进程结构启动Nginx的时候，会启动一个Master进程，这个进程不处理客户端的任何请求，主要用来产生worker进程 而每个worker进程用来处理一个Request Niginx 模块分为：核心模块、时间模块、标准HTTP模块、可选HTTP模块、邮件模块、第三方模块和补丁等。 基本模块Nginx默认的功能模块，它们提供的指令，允许使用定义Nginx基本功能的变量，在编译的时候不能被禁用，包括: 核心模块：基本功能和指令，如进程管理和安全 事件模块：在Nginx内配置网络使用的能力 配置模块：提供包含机制 常用模块Nginx常用的核心模块指令 error_log include pid user worker_cpu_affinity worker_processes error_log语法： error_log file [ debug|info|notice|warn|error|crit ] Nginx支持将不同的虚拟主机的日志记录在不同的路径 12345678910111213http &#123; error_log logs/http_error.log error; server &#123; server_name one; access_log logs/one_access.log; error_log logs/one_error.log error; &#125; server &#123; server_name two; access_log logs/two_access.log; error_log logs/two_error.log error; &#125;&#125; include从外部引入文件，支持文件通配符 pid指定pid文件，可以使用kill命令 user为了提高安全性，指定允许操作Nginx的用户 语法：user user [group] worker_cpu_affinity指定工作进程指定到某个CPU上 // 指定每个进程绑定一个CPU worker_processes 4; worker_cpu_affinity 0001 0010 0100 1000; // 指定第一个进程到CPU0/CPU2，第二个进程到CPU1/CPU3 worker_processes 2; worker_cpu_affinity 0101 1010; worker_processes一个工作进程为一个单线程的进程 如果Nginx工作在一些CPU密集型的环境中，并且你的机器拥有2块以上的CPU，则可以将worker_processes的数目设置为CPU核数。 如果你的机器运行在需要处理大量静态文件的环境，并且文件的大小总和超出了可用的内存，那么可以增加worker_processes的以便充分利用磁盘带宽。 日志模块控制Nginx如何记录请求日志 12345log_format gzip $remote_addr - $remote_user [$time_local] &quot;$request&quot;&apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot;&apos; &apos;&quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&apos;; access_log /spool/logs/nginx-access.log gzip buffer=32k; access_log语法：access_log path [format [buffer=size | off]] 默认值：access_log log/access.log combined 使用字段：http、server、location 注意： Nginx指定的用户必须有创建日志的权限 log_format语法：log_format name format [format ...] 默认值：log_format combined &quot;...&quot; 使用字段：http、server 变量名 含义 $body_bytes_sent 减去应答头后传送给客户端的字节数 $bytes_sent 传送给客户端的字节数 $connection 连接数 $msec 正在写入日志条目的当前时间 $pipe 如果请求为管道的 request_length 请求主体的长度 $request_time 从一个请求发出到Nginx工作的时间 $status 应答的状态 $time_local 写入普通日志格式的当地时间 事件模块 use connection use语法：use [ kqueue | rtsig | epoll | /dev/poll | select | poll | eventport] connections语法：worker_connections 最大连接数 = worker_processes * worker_connections // 反向代理环境下 最大连接数 = worker_processes * worker_connections / 4 原因：浏览器默认打开两个连接到服务器，Nginx使用来自相同地址池的fds与前后端相连接 HTTP模块基本配置Nginx的HTTP配置主要包括三个区块，结构如下 alias语法：alias file-path | directory-path; 使用字段：location alias是替换路径，而root是追加路径，将location后的路径追到root之后 12345location /i/ &#123; alias /spool/w3/images/&#125;请求 /i/top.gif 将返回这个文件 &quot;/spool/w3/images/top.gif&quot;。 error_page语法：error_page code [ code ... ] [ = | = answer-code ] uri | @named_location 使用字段：http、server、location、location中的if字段 这个参数可以为错误代码指定相应的错误页面 1234error_page 4040 /404.html;error_page 502 503 504 /50x.html;error_page 403 http://example.com/forbidden.html;error_page 404 = @fetch; 同样，你也可以将原有响应代码修改为另一个响应代码 12error_page 404 = 200 /empty.gif;error_page 404 = 403 /forbindden.gif; internal语法：internal 使用字段：location internal指定某个location只能被内部的请求调用，外部的调用会返回404. location区段通过指定模式来与客户端请求的URI相匹配 location [=|~|~*|^~|@] pattern { # ... } 没有修饰符，表示必须以指定的模式开始123456server &#123; server_name destiny.com; location /abc &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 http://destiny.com/abc/ http://destiny.com/abcde =，表示必须与指定的模式精准匹配123456server &#123; server_name destiny.com; location = /abc &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 (参数不参与匹配) 不能匹配 http://destiny.com/abc/ http://destiny.com/abcde ~，表示指定的正则表达式要区分大小写 ~表示按照正则表达式的语法与pattern进行匹配 123456server &#123; server_name destiny.com; location ~ ^/abc$ &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 (参数不参与匹配) 不能匹配 http://destiny.com/ABC/ http://destiny.com/abc/ http://destiny.com/abcde ~*，表示正则表达式不区分大小写123456server &#123; server_name destiny.com; location ~* ^/abc$ &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 (参数不参与匹配) http://destiny.com/ABC/ 不能匹配 http://destiny.com/abc/ http://destiny.com/abcde ^~，表示正则表达式不区分大小写 类似于无修饰符的行为，也是以指定模式开始，但如果模式匹配，那么久停止搜索其他模式了。 @，定义命名location区段，这些区段客户端不能访问，只可以由内部产生的请求来访问多个location的优先级问题 带有=的精准匹配 没有修饰符的精准匹配 正则表达式按照定义顺序 ^~的开头匹配 ~或~* 修饰符 没有修饰符的，如果指定字符串与URI开头匹配 Http反向代理模块 Nginx通常被用作后端服务器的反向代理，这样就可以很方便的实现动静分离，以及负载均衡，从而大大提高服务器的处理能力。 Http Proxy模块，功能很多，最常用的是proxy_pass 如果要使用proxy_cache的话，需要集成第三方的ngx_cache_purge模块，用来清除指定的URL缓存。 反向代理 普通的正向代理，为客户端提供代理服务 123456graph TDA[客户端]--&gt;|发出请求|B&#123;代理&#125;B --&gt; |代理访问并返回响应|AB --&gt; |代理访问|C[服务器A]B --&gt; |代理访问|D[服务器B]B --&gt; |代理访问|E[服务器C] 反向代理，为服务端提供代理服务 123456graph TDA[客户端A]--&gt;|先访问反向代理服务器|D&#123;代理服务器&#125;B[客户端B]--&gt;|先访问反向代理服务器|D&#123;代理服务器&#125;C[客户端C]--&gt;|先访问反向代理服务器|D&#123;代理服务器&#125;D --&gt; |代理客户端访问|E[服务器]E --&gt; |返回请求|D Http代理模块这个模块可以转发请求到其他的服务器 location / { proxy_pass http://localhost:8080; # 转发指令，把当前的指令转发到指定路径 proxy_set_header X-Real-IP $remote_addr; # 设置http请求头 } proxy_buffer_size设置从被代理服务器(真实服务器)读取的第一部分应答的缓冲区大小 语法：proxy_buffer_size the_size通常情况下这部分应答中包含一个小的应答头 proxy_buffering为后端服务器启用响应缓冲 如果启用缓冲，Nginx假设被代理服务器能够非常快的传递响应，并将其放入缓冲区 如果禁用缓冲，从后端传来的应答将立即被传送到客户端 语法：proxy_buffering on|off proxy_pass设置被代理服务器的地址和被映射的URL 地址可以使用主机名或IP+端口号的形式]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F04%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
