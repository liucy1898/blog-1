<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Raft协议(1)——一致性原理分析]]></title>
    <url>%2Fblog%2F2018%2F04%2F14%2FRaft%E5%8D%8F%E8%AE%AE-1-%E2%80%94%E2%80%94%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述在一个由 Raft 协议组织的集群中有三类角色： Leader（领袖） Follower（群众） Candidate（候选人） 就像一个民主社会，领袖由民众投票选出。刚开始没有领袖，所有集群中的参与者都是群众，那么首先开启一轮大选，在大选期间所有群众都能参与竞选，这时所有群众的角色就变成了候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除领袖的候选人又变回群众角色服从领袖领导。这里提到一个概念「任期」，用术语 Term 表达。关于 Raft 协议的核心概念和术语就这么多而且和现实民主制度非常匹配，所以很容易理解。三类角色的变迁图如下，结合后面的选举过程来看很容易理解。 Raft 集群中节点状态转化 Leader 选举过程在极简的思维下，一个最小的 Raft 民主集群需要三个参与者（如下图：A、B、C），这样才可能投出多数票。初始状态 ABC 都是 Follower，然后发起选举这时有三种可能情形发生。下图中前二种都能选出 Leader，第三种则表明本轮投票无效（Split Votes），每方都投给了自己，结果没有任何一方获得多数票。之后每个参与方随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。这里的关键就是随机 timeout，最先从 timeout 中恢复发起投票的一方向还在 timeout 中的另外两方请求投票，这时它们就只能投给对方了，很快达成一致。 选出 Leader 后，Leader 通过定期向所有 Follower 发送心跳信息维持其统治。若 Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了再次发起选主过程。 Leader 节点对一致性的影响Raft 协议强依赖 Leader 节点的可用性来确保集群数据的一致性。数据的流向只能从 Leader 节点向 Follower 节点转移。当 Client 向集群 Leader 节点提交数据后，Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，确保至少集群中超过半数节点已接收到数据后再向 Client 确认数据已接收。一旦向 Client 发出数据接收 Ack 响应后，表明此时数据状态进入已提交（Committed），Leader 节点再向 Follower 节点发通知告知该数据状态已提交。 在这个过程中，主节点可能在任意阶段挂掉，看下 Raft 协议如何针对不同阶段保障数据一致性的。 数据到达 Leader 节点前这个阶段 Leader 挂掉不影响一致性，不多说。 数据到达 Leader 节点，但未复制到 Follower 节点这个阶段 Leader 挂掉，数据属于未提交状态，Client 不会收到 Ack 会认为超时失败可安全发起重试。Follower 节点上没有该数据，重新选主后 Client 重试重新提交可成功。原来的 Leader 节点恢复后作为 Follower 加入集群重新从当前任期的新 Leader 处同步数据，强制保持和 Leader 数据一致。 数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader响应这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态（Uncommitted）但保持一致，重新选出 Leader 后可完成数据提交，此时 Client 由于不知到底提交成功没有，可重试提交。针对这种情况 Raft 要求 RPC 请求实现幂等性，也就是要实现内部去重机制。 数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接受这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态（Uncommitted）且不一致，Raft 协议要求投票只能投给拥有最新数据的节点。所以拥有最新数据的节点会被选为 Leader 再强制同步数据到 Follower，数据不会丢失并最终一致。 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client这个阶段 Leader 挂掉，Cluster 内部数据其实已经是一致的，Client 重复重试基于幂等策略对一致性无影响。 网络分区导致的脑裂情况，出现双 Leader网络分区将原先的 Leader 节点和 Follower 节点分隔开，Follower 收不到 Leader 的心跳将发起选举产生新的 Leader。这时就产生了双 Leader，原先的 Leader 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 Leader 提交数据可以提交成功，网络恢复后旧的 Leader 发现集群中有更新任期（Term）的新 Leader 则自动降级为 Follower 并从新 Leader 处同步数据达成集群数据一致。 算法以正确性、高效性、简洁性作为主要设计目标。虽然这些都是很有价值的目标，但这些目标都不会达成直到开发者写出一个可用的实现。所以我们相信可理解性同样重要。]]></content>
      <categories>
        <category>Raft</category>
      </categories>
      <tags>
        <tag>Raft</tag>
        <tag>一致性算法</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ-(5)——ActiveMQ结合Spring开发]]></title>
    <url>%2Fblog%2F2018%2F04%2F14%2FActiveMQ-5-%E2%80%94%E2%80%94ActiveMQ%E7%BB%93%E5%90%88Spring%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[步骤依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;&lt;/dependency&gt; 在Spring中配置jmsTemplate12345678910111213141516171819202122&lt;!--JMS连接池工厂--&gt;&lt;bean id="jmsFactory" class="org.apache.activemq.pool.PooledConnectionFactory" destroy-method="stop"&gt; &lt;property name="connectionFactory"&gt; &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://localhost:61616"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="maxConnections" value="100"/&gt;&lt;/bean&gt;&lt;!--目的地--&gt;&lt;bean id="destination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg index="0" value="spring-queue"/&gt;&lt;/bean&gt;&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;property name="connectionFactory" ref="jmsFactory"/&gt; &lt;property name="defaultDestination" ref="destination"/&gt; &lt;property name="messageConverter"&gt; &lt;bean class="org.springframework.jms.support.converter.SimpleMessageConverter"/&gt; &lt;/property&gt;&lt;/bean&gt; 如果是topic 添加topic的配置 修改jmsTemplate配置中的defaultDestination 12345678910111213141516171819202122&lt;!--JMS连接池工厂--&gt;&lt;bean id="jmsFactory" class="org.apache.activemq.pool.PooledConnectionFactory" destroy-method="stop"&gt; &lt;property name="connectionFactory"&gt; &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://localhost:61616"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="maxConnections" value="100"/&gt;&lt;/bean&gt;&lt;!--目的地--&gt;&lt;bean id="destination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg index="0" value="spring-topic"/&gt;&lt;/bean&gt;&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;property name="connectionFactory" ref="jmsFactory"/&gt; &lt;property name="defaultDestination" ref="destination"/&gt; &lt;property name="messageConverter"&gt; &lt;bean class="org.springframework.jms.support.converter.SimpleMessageConverter"/&gt; &lt;/property&gt;&lt;/bean&gt; 如果在Spring中配置消费者的话，就不需要启动消费者相当于注册了一个默认消息监听器 当JMS Provider接受到消息之后就会触发listener的onMessage()方法 1234567&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="jmsFactory"/&gt; &lt;property name="destination" ref="destination"/&gt; &lt;property name="messageListener" ref="messageListener"/&gt;&lt;/bean&gt;&lt;bean id="messageListener"class="org.destiny.activemq.spring.MyMessageListener"/&gt; 12345678910111213package org.destiny.activemq.spring;public class MyMessageListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("receive: " + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最佳实践 Camel框架支持大量的企业集成模式，可以大大简化集成组件间的大量服务和复杂的消息流。而Spring更注重简单性。 Spring消息发送的核心架构是JmsTemplate，隔离了像打开、关闭Session和Producer等操作。因此应用开发人员仅仅需要关注实际的业务逻辑。但JmsTemplate损害了ActiveMQ的PooledConnectionFactory对Session和消息Producer的缓存机制带来的性能提升。 新的Spring中，可以设置org.springframework.jms.connection.CachingConnectionFactory的sessionCacheSize，或者直接使用ActiveMQ的PooledConnectionFactory。 不建议使用JmsTemplate的receive()，因为JmsTemplate上的所有调用都是同步的，这意味着调用的线程会阻塞，直到方法返回，性能影响较大。 尽量使用DefaultMessageListenerContainer，它允许异步接受消息并缓存session和消息Consuer。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(4)——Broker的启动方式]]></title>
    <url>%2Fblog%2F2018%2F04%2F12%2FActiveMQ-4-%E2%80%94%E2%80%94Broker%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Broker：相当于一个ActiveMQ服务器实例。 命令行启动参数示例 activemq start：默认使用acitvemq.xml来启动 activemq start xbean:file:../conf/activemq.xml：使用指定的配置文件来启动。 用ActiveMQ来构建Java应用用ActiveMQ Broker作为独立的消息服务器来构建JAVA应用。ActiveMQ也支持在VM中通信基于嵌入式的Broker，能够无缝集成其他Java应用。 嵌入式BrokerBrokerService启动Broker1234567public static void main(String[] args) throws Exception &#123; // 开启ActiveMQ Broker BrokerService brokerService = new BrokerService(); brokerService.setUseJmx(true); brokerService.addConnector("tcp://localhost:61616"); brokerService.start();&#125; BrokerFactory启动Broker1234567public static void main(String[] args) throws Exception &#123; // 开启ActiveMQ Broker String uri = "properties:broker.properties"; BrokerService brokerService = BrokerFactory.createBroker(new URI(uri)); brokerService.addConnector("tcp://localhost:61616"); brokerService.start();&#125; 配置文件broker.properties123useJmx=truepersistent=falsebrokerName=Cheese 利用Spring集成Broker123456789&lt;bean id="broker" class="org.apache.activemq.broker.BrokerService" init-method="start" destroy-method="stop"&gt; &lt;property name="brokerName" value="myBroker"/&gt; &lt;property name="persistent" value="false"/&gt; &lt;property name="transportConnectorURIs"&gt; &lt;list&gt; &lt;value&gt;tcp://localhost:61616&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 启动多个Broker如果需要启动多个Broker，那么需要为每个Broker设置一个名字12]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(3)——JMS可靠性机制]]></title>
    <url>%2Fblog%2F2018%2F04%2F12%2FActiveMQ-3-%E2%80%94%E2%80%94JMS%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[消息接受确认JMS消息只有在被确认之后，才认为已经被成功地消费了。消费的成功通常包含三个阶段：客户端接受消息、客户端处理消息和消息被确认。在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。该参数有三个可选方案： Session.AUTO_ACKNOWLEDGE当客户成功的从receive()方法返回的时候，或者从MessageListener.onMessage()方法成功返回的时候，会话自动确认客户端收到的消息。 Session.CLIENT_ACKNOWLEDGE客户端通过调用消息的acknowledge()方法确认消息。在这种模式中，确认是在会话层上进行，确认一个被消费的消息将自动确认所有已被会话消费的消息。 1Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE); Session.DUPS_ACKNOWLEDGE只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS Provider必须把消息头的JMSRedelivered字段设置为true 消息的持久性，JMS支持两种消息提交模式PERSISTENTJMS Provider永久保存消息，以保证消息不会因为JMS Provider的失败而丢失。 NON_PERSISTENT不要求JMS Provider持久保存消息 消息的临时目的地可以通过Session的createTemporaryQueue()和createTemporaryTopic()方法来创建临时目的地。他们的存在时间只限于创建他们的连接所保持的时间，只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。 本地事务在一个JMS客户端，可以使用本地事务来组合消息的发送和签收。Session接口提供了commit()和rollback()方法。 事务提交意味着生产的所有消息被发送，消费的所有消息被确认。 事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非他们已过期。 PTP模型该模型定义了客户端如何向队列发送消息，从队列接受消息。 PTP模型是基于队列的，生产者发消息到队列，消费者从队列接受消息，队列使得消息的异步传输成为可能。 特点 Session在关闭时，如果有消息已经被接受，但还没有确认，那么当消费者下次连接到相同的队列时，这些消息还会被再次接受。 如果用户在receive()方法中设定了消息选择条件，那么不符合条件的消息会留在队列中。 队列可以长久地保存消息直到消费者收到消息，消费者不需要因为担心消息丢失而时刻与队列保持激活的连接状态。 Pub/Sub模型该模型定义了如何向一个内容节点发布和订阅消息。 主题可以被认为是消息的传输中介，发布者发布消息到主题，订阅者从主题订阅消息，二者相互独立，不需要接触。 特点 消息订阅分为非持久订阅和持久订阅 非持久订阅时，只有当客户端处于激活状态才能收到某个主题的消息；离线时发布到主题的消息将会丢失。 持久订阅时，客户端向JMS Provider注册一个自己身份的ID，当客户端处于离线状态时，Provider会为这个ID保存所有发送到主题的消息。 如果用户在receive()方法中设定了消息选择条件，那么不符合条件的消息不会被接收。 非持久订阅状态下，不能恢复或重新派送一个未签收的消息。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(2)——JMS规范]]></title>
    <url>%2Fblog%2F2018%2F04%2F11%2FActiveMQ-2-%E2%80%94%E2%80%94JMS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[定义JMS(Java Message Service)，Java消息服务 JMS定义了Java访问消息中间件的接口，并没有给予实现。 实现JMS接口的消息中间件成为JMSProvider，如ActiveMQ。 JMS规范 JMS message：JMS的消息，由三部分组成：消息头、消息属性、消息体 JMS Producer：消息生产者，创建和发送消息 JMS Consumer：消息消费者，接受和处理消息，消息的消费可以采用以下两种方式之一： 同步消费：通过调用消费者的receive方法从目的地中显示提取消息，receive方法可以一直阻塞到消息到达 异步消费：客户可以为消费者注册一个Listener，以定义在消息到达时所采取的动作。 JMS domains：消息传递域，JMS定义了两周消息传递域： 点对点：每个消息只能有一个消费者，生产者和消费者没有时间上的相关性，无论消费者在生产者发送消息的时候是否处于运行状态，都可以提取消息； 发布订阅：每个消息可以被多个消费者消费，生产者和消费者有时间上的相关性，订阅一个主题的消费者只能消费它订阅之后发布的消息 ConnectionFactory：连接工厂，用来创建连接对象，已连接到JMS的Provider JMS Connection：封装了客户与JMS提供者之间的一个虚拟连接 JMS Session：是生产和消费消息的一个单线程上下文 会话用于创建消息生产者、消费者和消息等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接受被组合到了一个原子操作中。 Destination：消息发送到的目的地。 Acknowledge：签收。消费者收到消息后，需要告诉JMS Provider消息已被消费。 Transaction：事务 JMS Client：用来收发消息的Java应用 JMS Message结构组成 消息头 属性 消息体 消息头消息头包含识别信息和路由信息 JMSDestination：消息发送的目的地，主要是指Queue或Topic。 JMSDeliveryMode：传送模式，持久或非持久。 持久消息应该会且只会被发送一次，JMS提供者出现故障，消息也不会丢失，会在服务器恢复之后再次传递。 非持久的消息最多会被发送一次，这意味着服务器出现故障，该消息会永远丢失。 JMSExpiration：消息过期时间，为0表示永不过期。 JMSPriority：消息优先级，数字越大，级别越高，加急消息要先于普通消息。 JMSMessageId：唯一标识。 JMSCorrelationID：用来连接到另一个消息，典型应用是在回复消息中关联到原消息。 JMSReplyTo：提供本消息回复消息的目的地址，由开发者提供 JMSType：消息的类型识别符 JMSRedelivered：如果一个客户端收到了一个设置了JMSRedelivered属性的消息，则表示客户端可能收到过该消息，但没有签收。 消息体 TextMessage：文本消息 MapMessage：映射消息 BytesMessage：二进制消息 StreamMessage：流式消息 ObjectMessage：对象消息 属性应用程序设置和添加的属性1message.setStringProperty("username", username); JMS定义的属性12// 返回所有连接支持的JMSX属性的名字connection.getMetaData().getJMSXPropertyNames(); JMS供应商特定的属性JMS定义的属性 JMSXUserID：发送消息的用户标识 JMSXAppID：发送消息的应用标识 JMSXDeliveryCount：转发消息重试次数 JMSXGroupID：消息所在的消息组的标识 JMSXGroupSeq：组内消息的序号]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ(1)——概览&入门]]></title>
    <url>%2Fblog%2F2018%2F04%2F09%2FActiveMQ-1-%E2%80%94%E2%80%94%E6%A6%82%E8%A7%88-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[概览ActiveMQ简介 什么是ActiveMQ ActiveMQ的作用 ActiveMQ的特点 消息中间件的功能、特点、应用场景等 ActiveMQ安装和基本使用通过源码安装、基本的配置实例、启动、测试运行、关闭等 JMS基本概念、消息结构、可靠性机制、PTP、Pub/Sub、API结构、JMS应用开发的基本步骤、持久和非持久的Topic 同ActiveMQ构建应用 多种启动Broker的方法 单独应用的开发 结合Spring开发 ActiveMQ的Transport多种运输协议的功能、配置和使用 ActiveMQ的消息存储队列和Topic、KahaDB、AMQ、JDBC、MMS等 ActiveMQ的Network 在一台服务器上启动多个Broker 静态网络连接的功能、配置 “丢失”消息的处理 容错或可负载均衡的连接 动态网络连接等 ActiveMQ集群 队列消费者集群 Broker的集群 MasterSlave等 Destination高级特性 通配符 组合队列 配置启动的Destination 删除不活动的Destination 虚拟Destination 镜像队列 Message Dispatch高级特性 消息游标 异步发送 分发策略 优化批量控制 Message高级特性 消息属性 Advisory Message 延迟和定时消息投递 Blob消息 消息转换 Consumer高级特性 消息异步分发 消息优先级 管理持久化消息 消息分组 消息重抵策略 杂项 监控和管理 集成ActiveMQ和Tomcat ActiveMQ优化ActiveMQ简介介绍ActiveMQ是Apache推出的一款开源的、完全支持JMS和J2EE规范的JMSProvider实现的消息中间件(Message Oriented Middleware, MOM)。 作用用来帮助实现高可用、高性能、可伸缩、易用和安全的企业级面向消息服务的系统。 ActiveMQ安装和基本使用下载并安装服务端 从http://activemq.apache.org/download.html下载最新的ActiveMQ 直接解压1$ tar -zxvf apache-activemq-5.9.0-bin.tar.gz activemq 启动运行 普通启动 1234$ pwd/usr/local/activemq/bin$ ./activemq start 启动并指定日志文件 1$ ./activemq start &gt; /tmp/activemqlog 检查是否已经启动ActiveMQ默认采用61616端口提供JMS服务，使用8061端口提供管理控制台服务，执行以下命令以便检验是否已经成功启动ActiveMQ服务： 查看61616端口是否已经打开： netstat -an | grep 61616 查看控制台输出或者日志文件 直接访问ActiveMQ的管理页面：http://localhost:8161/admin，默认的用户名和密码是admin/admin 关闭ActiveMQ1$ ./activemq stop 基本的消息发送配置MAVEN所需的依赖12345678910&lt;dependency&gt; &lt;gruopId&gt;org.apache.activemq&lt;/gruopId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;gruopId&gt;org.apache.xbean&lt;/gruopId&gt; &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt;&lt;/dependency&gt; 消息生产者123456789101112131415161718192021222324252627public static void main(String[] args) throws JMSException, InterruptedException &#123; // 创建连接工厂，连接工程负责与ActiveMQ服务端建立连接 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616"); // 由连接工厂创建连接 Connection connection = connectionFactory.createConnection(); // 启动连接 connection.start(); // 通过连接创建会话 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); // 通过会话创建目的地，名称表示对列名 Destination destination = session.createQueue("my-queue"); // 通过 session 创建生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; ++i) &#123; TextMessage message = session.createTextMessage("message -- " + i); Thread.sleep(100); // 通过消息生产者发出消息 producer.send(message); System.out.println("创建成功"); &#125; session.commit(); session.close(); connection.close();&#125; 运行结果： 消息消费者123456789101112131415161718192021222324public static void main(String[] args) throws JMSException, InterruptedException &#123; // 创建连接工厂，连接工厂负责与ActiveMQ服务端建立连接 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616"); // 由连接工厂创建连接 Connection connection = connectionFactory.createConnection(); // 启动连接 connection.start(); // 通过连接创建会话 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); // 通过会话创建目的地，名称表示对列名 Destination destination = session.createQueue("my-queue"); // 通过 session 创建生产者 MessageConsumer consumer = session.createConsumer(destination); for (int i = 0; i &lt; 100; ++i) &#123; TextMessage message = (TextMessage) consumer.receive(); session.commit(); System.out.println("收到消息: " + message.getText()); &#125; session.close(); connection.close();&#125; 运行结果： JMS模型]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盘点实际项目中常用的加密算法及使用场景]]></title>
    <url>%2Fblog%2F2018%2F04%2F08%2F%E7%9B%98%E7%82%B9%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[MD5定义MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 特点 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等。 应用场景一致性验证MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。MD5就可以为任何文件（不管其大小、格式、数量）产生一个同样独一无二的“数字指纹”，如果任何人对文件做了任何改动，其MD5值也就是对应的“数字指纹”都会发生变化。 数字签名MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。 安全访问认证MD5还广泛用于操作系统的登陆认证上，如Unix、各类BSD系统登录密码、数字签名等诸多方面。如在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。 缺点与不足2014年中国山东大学的王小云教授公布破译了MD5、HAVAL-128、 MD4和RIPEMD算法的报告。通过加速的杂凑与冲撞方法破译了MD5算法。 实践 RSA定义RSA为公钥加密体制 乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 甲方获取乙方的公钥，然后用它对信息加密。 乙方得到加密后的信息，用私钥解密。 特点便于理解，使用广泛RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。 缺点与不足：加密和解密花费时间长、速度慢，只适合对少量数据进行加密为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要。 实践ssh口令登录1234567sequenceDiagram客户端-&gt;&gt;服务端: 口令登录服务端-&gt;&gt;客户端: 发送1024为公钥指纹客户端-&gt;&gt;服务端: 指纹保存在$HOME/.ssh/known_hosts，接受远程主机秘钥服务端-&gt;&gt;客户端: 请求输入密码客户端-&gt;&gt;服务端: 输入密码服务端-&gt;&gt;客户端: 接受或拒绝链接 ssh公钥登录12345sequenceDiagram客户端-&gt;&gt;服务端: 登录请求服务端-&gt;&gt;客户端: 发送随机字符串客户端-&gt;&gt;服务端: 发送加密后的随机字符串服务端-&gt;&gt;客户端: 接受或拒绝链接 客户端事先把自己的公钥保存在服务端的指定目录: $HOME/.ssh/authorized_keys 客户端生成秘钥: ssh-keygen，运行结束后，在$HOME/.ssh/目录下，会新生成两个文件: id_rsa.pub和id_rsa。前者是公钥，后者是私钥。 将公钥发送给远程主机: ssh-copy-id user@host]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>算法</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）Nginx实现动静分离]]></title>
    <url>%2Fblog%2F2018%2F04%2F03%2F%EF%BC%88%E4%BA%8C%EF%BC%89Nginx%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[概念在反向代理时，如果是静态资源，就直接从Nginx发布的路径中去读取，而不需要从后台服务器获取。 但这种情况下需要保证后端跟前端的程序保持一致，可以使用Rsync做服务端自动同步或者使用NFS、MFS分布式共享存储。 概念图 原理Nginx可以拦截请求 因此可以利用这一特性，将拦截到的静态请求进行重定向。 12345678910111213141516171819202122232425server &#123; listen 80; server_name destiny; access_log logs/host.access.log main; index index.html index.htm index.jsp; root /usr/local/tomcat-9.0.0-RC5-1/webapps/ROOT/; # 不区分大小写的正则匹配 location ~* .*\.(jpg|jepg|fig|png|wsf|ico)$ &#123; if(-f $request_filename) &#123; # expires 15d; break; &#125; &#125; # 不区分大小写的正则匹配 locatin ~* .*\.(html|htm|js|css)$ &#123; # expires 1d; &#125; location / &#123; proxy_pass http://10.211.55.5 &#125;&#125; 在前两个location中，没有配置后端服务器的路径Nginx就会默认去寻找root的资源 Nginx会以root为根路径，将请求的路径拼在其后去查找，如果能访问到，Nginx就可以直接将该文件返回。 如果能够查询到响应的文件，就会直接返回。 指令index(默认主页设置模块)如果URL中没有指定文件，则设置一个默认主页。 可以指定多个文件，如果第一个文件没有找到，将会查找后面指定的文件 index index.html index.htm index.jsp root请求到达后的文件根目录 123location /i/ &#123; root /spool/w3;&#125; 如果请求/i/top.gif文件，Nginx将转到/spool/w3/i/top.gif文件 在请求中root会添加这个location到它的值后面，即”/i/top.gif”并不会请求”/spool/w3/top.gif”文件，如果要实现上述类似于apache alias的功能，可以使用alias指令。 简单来说，root是拼接，alias是替换。 实现当访问静态资源的请求进入(假设为http://10.211.55.4:80/static/person.jpg)时，会被配置文件中的第一个location拦截 location会将root中配置的路径和访问路径拼接在一起，新的路径为/usr/local/tomcat-9.0.0-RC5-1/webapps/ROOT/static/person.jpg，在Nginx的路径中进行查找。 初始情况，不加Nginx的情况下启动Tomcat 访问10.211.55.4:8080即可访问Tomcat主页。 查看logs/localhost_access_log.2018-04-03.txt可以看到访问日志 此时可以看到，请求了多个静态文件。 加入Nginx将包含上图中文件的路径/usr/local/apache-tomcat-7.0.73/webapps/ROOT/配置进Nginx配置文件中的root属性。 并配置location用于拦截jpg/jepg/fig/png/wsf/ico后缀的文件。 然后sbin/nginx -s reload重启Nginx 效果展示分别重启Tomcat和Nginx后，再访问10.211.55.4(Nginx自动监听80端口并转发至8080) 删除浏览器缓存 此时再查看日志，已经请求中已经不再对静态资源进行请求]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从头搭建github博客]]></title>
    <url>%2Fblog%2F2018%2F04%2F01%2F%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[安装Node.js并配置Node.js环境成功界面如下： 安装git并配置git环境 注册Github并新建项目首页 新建仓库页参考其他博客的时候，很多博客中都提到 项目名必须是 github账户名.github.io 但经本人测试其实项目名称可以任意选取，如本人的仓库名就是blog，而非destinywang.github.io 设置进入项目的setting选项卡中 下拉到Github Pages，此时该项目已经被部署，可以通过提供的外网链接去访问。 安装HexoHexo中文网站 Hexo是个快捷，简介且高效的博客框架 让上百个页面在几秒内完成渲染 Hexo支持Github Flavored Markdown的所有功能 在合适的位置创建文件夹 以上操作需要在空文件夹中进行 123$ npm install hexo -g # 安装Hexo$ hexo -v # 检查Hexo是否安装成功$ hexo init # 初始化文件夹 Hexo init npm install此命令用于安装所需要的组件 hexo g首次体验Hexo hexo s此命令会在本地开启Hexo的服务器 可以在发布到github之前先在本地进行调试 然后再浏览器中输入localhost:4000/blog/如果出现如下界面就成功了 将Hexo和Github page联系起来设置本地git如果是第一次使用git的话需要设置name和email 1234$ ssh-keygen -t rsa -C &quot;your email&quot; # 生成秘钥，路径在~/.ssh下，windows用户的路径为C:\Users\Administrator\.ssh$ eval &quot;$(ssh-agent -s)&quot; # 添加秘钥到ssh-agent$ ssh-add ~/.ssh/id_rsa # 添加生成的SSH key到ssh-agent 登录github，进行设置 进入用户的setting页面 在SSH and GPG keys选项卡中添加一个ssh key，并将id_rsa.pub(公钥)的内容复制上去 配置Deployment为了保证Hexo能够正确的通过Git进行add、commit、pull、push等操作需要将本地及远程的git仓库信息进行配置 当前站点文件夹的状态： 修改_config.yml文件，将deployment部分相关的内容进行替换 type: 部署类型 repository: 远程仓库路径，即github中的仓库路径 branch: 分支名 新建一篇博客在终端中执行命令hexo new post 博客名 会在source/_posts路径下生成对应的博客文件test.md 安装hexo-deployer-git扩展文件1$ npm install hexo-deployer-git --save 编辑文章1$ vim source/_posts/test.md 打开test.md文件，按照正常的Markdown文件编辑即可 部署123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$ hexo d -gINFO Start processingINFO Files loaded in 640 msINFO Generated: tags/index.htmlINFO Generated: about/index.htmlINFO Generated: 2018/04/01/jvm/index.htmlINFO Generated: 2018/04/01/test/index.htmlINFO Generated: 2018/04/01/hello-world-1/index.htmlINFO Generated: archives/index.htmlINFO Generated: tags/jvm/index.htmlINFO Generated: archives/2018/index.htmlINFO Generated: archives/2018/04/index.htmlINFO Generated: tags/java基础/index.htmlINFO Generated: index.htmlINFO Generated: 2018/04/01/hello-world/index.htmlINFO Generated: 2018/04/01/一-Nginx基本知识/index.htmlINFO Generated: tags/Nginx/index.htmlINFO Generated: images/cc-by-nc-nd.svgINFO Generated: images/avatar.gifINFO Generated: images/apple-touch-icon-next.pngINFO Generated: images/cc-by-nc-sa.svgINFO Generated: images/algolia_logo.svgINFO Generated: images/cc-by-nc.svgINFO Generated: images/cc-by-nd.svgINFO Generated: images/cc-by-sa.svgINFO Generated: images/cc-by.svgINFO Generated: images/cc-zero.svgINFO Generated: images/favicon-16x16-next.pngINFO Generated: images/favicon-32x32-next.pngINFO Generated: images/loading.gifINFO Generated: images/logo.svgINFO Generated: images/placeholder.gifINFO Generated: images/quote-r.svgINFO Generated: images/searchicon.pngINFO Generated: lib/font-awesome/css/font-awesome.css.mapINFO Generated: images/quote-l.svgINFO Generated: lib/font-awesome/HELP-US-OUT.txtINFO Generated: images/blog-logo.jpegINFO Generated: lib/font-awesome/fonts/fontawesome-webfont.woff2INFO Generated: css/main.cssINFO Generated: lib/font-awesome/fonts/fontawesome-webfont.woffINFO Generated: js/src/affix.jsINFO Generated: js/src/exturl.jsINFO Generated: js/src/algolia-search.jsINFO Generated: js/src/bootstrap.jsINFO Generated: js/src/love.jsINFO Generated: js/src/js.cookie.jsINFO Generated: js/src/post-details.jsINFO Generated: js/src/motion.jsINFO Generated: js/src/scrollspy.jsINFO Generated: js/src/scroll-cookie.jsINFO Generated: lib/font-awesome/bower.jsonINFO Generated: js/src/utils.jsINFO Generated: lib/ua-parser-js/dist/ua-parser.min.jsINFO Generated: lib/velocity/velocity.ui.min.jsINFO Generated: lib/velocity/velocity.min.jsINFO Generated: js/src/schemes/pisces.jsINFO Generated: lib/ua-parser-js/dist/ua-parser.pack.jsINFO Generated: lib/velocity/velocity.ui.jsINFO Generated: lib/font-awesome/css/font-awesome.cssINFO Generated: lib/jquery/index.jsINFO Generated: lib/font-awesome/css/font-awesome.min.cssINFO Generated: lib/font-awesome/fonts/fontawesome-webfont.eotINFO Generated: lib/velocity/velocity.jsINFO 61 files generated in 1.13 sINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master 966acc9] Site updated: 2018-04-01 21:18:16 1 file changed, 1 insertion(+), 1 deletion(-)To github.com:DestinyWang/blog.git + fa066f8...966acc9 HEAD -&gt; master (forced update)Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;git@github.com:DestinyWang/blog.git&apos;.INFO Deploy done: git 至此，博客已经部署成功，可以去http://用户名.github.io查看。 安装Next1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载到站点文件夹路径下的themes/next 启用Next主体在站点目录中，打开配置文件_config.yml，修改theme: next123$ pwd~/blog$ vim _config.yml 主题设定在next主题目录下的_config.yml，修改scheme: Pisces 123$ pwd~/blog$ vim themes/next/_config.yml 语言设定Hexo提供了多种语言支持，包括简体中文zh-Hans在站点根目录下修改配置文件_config.yml中的language为zh-Hans 123$ pwd~/blog$ vim _config.yml 修改菜单栏在主题目录下修改配置文件_config.yml中的menu 123$ pwd~/blog$ vim themes/next/_config.yml 设置菜单项图标对应字段是menu_icons同样在主题目录下的_config.yml中修改 格式为item name: icon name，其中item name 与所配置的菜单名字对应，icon name是Font Awesome图标的名字。而 enable可用于控制是否显示图标，你可以设置成 false 来去掉图标。 123$ pwd~/blog$ vim themes/next/_config.yml 设置侧栏位置修改主题目录下sidebar的position值 123$ pwd~/blog$ vim themes/next/_config.yml 设置头像在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/目录下） 设置文章代码主题在主题目录下修改配置文件_config.yml，字段highlight_theme，默认值为nomal。可以设置为night 123$ pwd~/blog$ vim themes/next/_config.yml 添加分类在站点路径下新建页面categories 123456$ pwd~/blog$ hexo new page categories# 在 source/categories 目录中修改index.mdvim source/categories/index.md 12# 在主题的 _config.yml 中取消注释:$ vim _config.yml 在要分类的文章中加入 category 属性: 添加标签页面标签是对博客分类的方式比如一个系列的博客都是将神经网络，那么就可以给每篇博客加上神经网络的tag 1234567$ pwd~/blog$ hexo new page tagsINFO Created: ~/blog/source/tags/index.md# 在新建的index.md中添加type: &quot;tags&quot;vim source/tags/index.md 后面只需要在博客的开头中添加tags: [A, B, C]即可 成功后，标签部分的导航栏为 Aboute Me1234567$ pwd~/blog$ hexo new page aboutINFO Created: ~/blog/source/about/index.md# 在新建的index.md中添加如下内容vim source/about/index.md 成功后效果如下所示： 添加github导航条从这里选择主题 然后将代码复制到themes/next/layout/_layout.swig 123$ pwd~/blog$ vim themes/next/layout/_layout.swig 成功后的效果如下： 修改内容区域宽度默认情况Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 非Pisces Scheme主题修改1$ vim source/css_variables/custom.styl 修改内容： 12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px Pisces Scheme主题修改1$ vim themes\next\source\css\_schemes\Picses\_layout.styl 修改内容： 123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 设置首页不显示全文(只显示预览)打开主题路径下的_config.yml1$ vim themes/next/_config.yml 修改auto_excerpt12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将enable属性改为true 修改code代码块自定义样式1$ vim themes/next/source/css/_custom/custom.styl 结束至此，博客基本设置OK但还有很多地方可以继续挖掘 后续会持续更新]]></content>
      <tags>
        <tag>github博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）Nginx基本知识]]></title>
    <url>%2Fblog%2F2018%2F04%2F01%2F%EF%BC%88%E4%B8%80%EF%BC%89Nginx%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[简介Nginx是一款轻量级的Web服务器，也是一款轻量级的反向代理服务器 用途 直接支持Rails和PHP程序 作为HTTP反向代理服务器 作为负载均衡服务器 作为邮件代理服务器 帮助实现动静分离 特点高稳定、高性能、资源占用少、功能丰富、模块化结构、支持热部署 安装Nginx 依赖gcc openssl-devel pcre-devel zlib zlib-devel 1yum install gcc openssl-devel pcre-devel zlib zlib-devel 安装 $ ./configure --prefix=/usr/local/nginx --withhttp_stub_status_module $ make $ make install 常见的Nginx安装配置选项 Nginx基本运行// 测试配置文件 $ sbin/nginx -t nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful // 启动 $ sbin/nginx // 停止 $ sbin/nginx -s stop $ sbin/nginx -s quit // 重启 $ sbin/nginx -s reload // 查看进程 ps -ef | grep nginx Nginx的基本配置默认启动Nginx的时候，使用的配置文件是conf/nginx.conf文件 也可以在启动Nginx的时候，通过-c来指定要去读的配置文件 常见的配置文件 文件名 用途 nginx.conf 应用程序的基本配置文件 mime.types MIME类型关联的扩展文件 fastcgi.conf 与fastcgi相关的配置，与PHP相关 proxy.conf 与proxy相关的配置（反向代理） sites.conf 配置Nginx提供的网站，包括虚拟主机 nginx.cong1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950user root;worker_processes 1;error_log logs/error.log crit;pid logs/nginx.pid; # nginx 进程号文件路径events &#123; # 事件模块 use epoll; # 文件的模型 worker_connections 24; # 每个worker的connections&#125;http &#123; # web反向代理 include mime.type; # 引入mime.type include proxy.conf; # 引入proxy.conf defualt_type application/octet-stream; # mine.type 的缺省类型 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot;&apos; # 日志格式，远程地址 - 远程用户 时间 等 &apos;$status $body_bytes_sent &quot;$http_referer&quot;&apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos; access_log logs/access.log main; # 使用为main的格式 upstream test.com &#123; # 负载均衡模块 server 127.0.0.1:8080 weight = 5; &#125; server &#123; lisent 80; server_name detiny; access_log logs/host.access.log main; index index.html index.htm index.jsp; root /Users/destiny/Download/apache-tomcat-9.0.1/webapps/ROOT/; location ~* .*\.(jpg|jepg|gif|png|wsf|ico)$ &#123; # 如果是图片，就去root路径查询 if(-f $request_filename) &#123; break; &#125; &#125; location / proxy_pass http://destiny.com; &#125; &#125;&#125; Nginx的进程结构启动Nginx的时候，会启动一个Master进程，这个进程不处理客户端的任何请求，主要用来产生worker进程 而每个worker进程用来处理一个Request Niginx 模块分为：核心模块、时间模块、标准HTTP模块、可选HTTP模块、邮件模块、第三方模块和补丁等。 基本模块Nginx默认的功能模块，它们提供的指令，允许使用定义Nginx基本功能的变量，在编译的时候不能被禁用，包括: 核心模块：基本功能和指令，如进程管理和安全 事件模块：在Nginx内配置网络使用的能力 配置模块：提供包含机制 常用模块Nginx常用的核心模块指令 error_log include pid user worker_cpu_affinity worker_processes error_log语法： error_log file [ debug|info|notice|warn|error|crit ] Nginx支持将不同的虚拟主机的日志记录在不同的路径 12345678910111213http &#123; error_log logs/http_error.log error; server &#123; server_name one; access_log logs/one_access.log; error_log logs/one_error.log error; &#125; server &#123; server_name two; access_log logs/two_access.log; error_log logs/two_error.log error; &#125;&#125; include从外部引入文件，支持文件通配符 pid指定pid文件，可以使用kill命令 user为了提高安全性，指定允许操作Nginx的用户 语法：user user [group] worker_cpu_affinity指定工作进程指定到某个CPU上 // 指定每个进程绑定一个CPU worker_processes 4; worker_cpu_affinity 0001 0010 0100 1000; // 指定第一个进程到CPU0/CPU2，第二个进程到CPU1/CPU3 worker_processes 2; worker_cpu_affinity 0101 1010; worker_processes一个工作进程为一个单线程的进程 如果Nginx工作在一些CPU密集型的环境中，并且你的机器拥有2块以上的CPU，则可以将worker_processes的数目设置为CPU核数。 如果你的机器运行在需要处理大量静态文件的环境，并且文件的大小总和超出了可用的内存，那么可以增加worker_processes的以便充分利用磁盘带宽。 日志模块控制Nginx如何记录请求日志 12345log_format gzip $remote_addr - $remote_user [$time_local] &quot;$request&quot;&apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot;&apos; &apos;&quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&apos;; access_log /spool/logs/nginx-access.log gzip buffer=32k; access_log语法：access_log path [format [buffer=size | off]] 默认值：access_log log/access.log combined 使用字段：http、server、location 注意： Nginx指定的用户必须有创建日志的权限 log_format语法：log_format name format [format ...] 默认值：log_format combined &quot;...&quot; 使用字段：http、server 变量名 含义 $body_bytes_sent 减去应答头后传送给客户端的字节数 $bytes_sent 传送给客户端的字节数 $connection 连接数 $msec 正在写入日志条目的当前时间 $pipe 如果请求为管道的 request_length 请求主体的长度 $request_time 从一个请求发出到Nginx工作的时间 $status 应答的状态 $time_local 写入普通日志格式的当地时间 事件模块 use connection use语法：use [ kqueue | rtsig | epoll | /dev/poll | select | poll | eventport] connections语法：worker_connections 最大连接数 = worker_processes * worker_connections // 反向代理环境下 最大连接数 = worker_processes * worker_connections / 4 原因：浏览器默认打开两个连接到服务器，Nginx使用来自相同地址池的fds与前后端相连接 HTTP模块基本配置Nginx的HTTP配置主要包括三个区块，结构如下 alias语法：alias file-path | directory-path; 使用字段：location alias是替换路径，而root是追加路径，将location后的路径追到root之后 12345location /i/ &#123; alias /spool/w3/images/&#125;请求 /i/top.gif 将返回这个文件 &quot;/spool/w3/images/top.gif&quot;。 error_page语法：error_page code [ code ... ] [ = | = answer-code ] uri | @named_location 使用字段：http、server、location、location中的if字段 这个参数可以为错误代码指定相应的错误页面 1234error_page 4040 /404.html;error_page 502 503 504 /50x.html;error_page 403 http://example.com/forbidden.html;error_page 404 = @fetch; 同样，你也可以将原有响应代码修改为另一个响应代码 12error_page 404 = 200 /empty.gif;error_page 404 = 403 /forbindden.gif; internal语法：internal 使用字段：location internal指定某个location只能被内部的请求调用，外部的调用会返回404. location区段通过指定模式来与客户端请求的URI相匹配 location [=|~|~*|^~|@] pattern { # ... } 没有修饰符，表示必须以指定的模式开始123456server &#123; server_name destiny.com; location /abc &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 http://destiny.com/abc/ http://destiny.com/abcde =，表示必须与指定的模式精准匹配123456server &#123; server_name destiny.com; location = /abc &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 (参数不参与匹配) 不能匹配 http://destiny.com/abc/ http://destiny.com/abcde ~，表示指定的正则表达式要区分大小写 ~表示按照正则表达式的语法与pattern进行匹配 123456server &#123; server_name destiny.com; location ~ ^/abc$ &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 (参数不参与匹配) 不能匹配 http://destiny.com/ABC/ http://destiny.com/abc/ http://destiny.com/abcde ~*，表示正则表达式不区分大小写123456server &#123; server_name destiny.com; location ~* ^/abc$ &#123; # ... &#125;&#125; 可以匹配： http://destiny.com/abc http://destiny.com/abc?age=24 (参数不参与匹配) http://destiny.com/ABC/ 不能匹配 http://destiny.com/abc/ http://destiny.com/abcde ^~，表示正则表达式不区分大小写 类似于无修饰符的行为，也是以指定模式开始，但如果模式匹配，那么久停止搜索其他模式了。 @，定义命名location区段，这些区段客户端不能访问，只可以由内部产生的请求来访问多个location的优先级问题 带有=的精准匹配 没有修饰符的精准匹配 正则表达式按照定义顺序 ^~的开头匹配 ~或~* 修饰符 没有修饰符的，如果指定字符串与URI开头匹配 Http反向代理模块 Nginx通常被用作后端服务器的反向代理，这样就可以很方便的实现动静分离，以及负载均衡，从而大大提高服务器的处理能力。 Http Proxy模块，功能很多，最常用的是proxy_pass 如果要使用proxy_cache的话，需要集成第三方的ngx_cache_purge模块，用来清除指定的URL缓存。 反向代理 普通的正向代理，为客户端提供代理服务 123456graph TDA[客户端]--&gt;|发出请求|B&#123;代理&#125;B --&gt; |代理访问并返回响应|AB --&gt; |代理访问|C[服务器A]B --&gt; |代理访问|D[服务器B]B --&gt; |代理访问|E[服务器C] 反向代理，为服务端提供代理服务 123456graph TDA[客户端A]--&gt;|先访问反向代理服务器|D&#123;代理服务器&#125;B[客户端B]--&gt;|先访问反向代理服务器|D&#123;代理服务器&#125;C[客户端C]--&gt;|先访问反向代理服务器|D&#123;代理服务器&#125;D --&gt; |代理客户端访问|E[服务器]E --&gt; |返回请求|D Http代理模块这个模块可以转发请求到其他的服务器 location / { proxy_pass http://localhost:8080; # 转发指令，把当前的指令转发到指定路径 proxy_set_header X-Real-IP $remote_addr; # 设置http请求头 } proxy_buffer_size设置从被代理服务器(真实服务器)读取的第一部分应答的缓冲区大小 语法：proxy_buffer_size the_size通常情况下这部分应答中包含一个小的应答头 proxy_buffering为后端服务器启用响应缓冲 如果启用缓冲，Nginx假设被代理服务器能够非常快的传递响应，并将其放入缓冲区 如果禁用缓冲，从后端传来的应答将立即被传送到客户端 语法：proxy_buffering on|off proxy_pass设置被代理服务器的地址和被映射的URL 地址可以使用主机名或IP+端口号的形式]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F04%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
