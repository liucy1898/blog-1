<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://destinywang.github.io/blog/"/>
  <updated>2018-12-01T03:12:32.431Z</updated>
  <id>https://destinywang.github.io/blog/</id>
  
  <author>
    <name>destiny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activiti工作流引擎</title>
    <link href="https://destinywang.github.io/blog/2018/11/26/Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E/"/>
    <id>https://destinywang.github.io/blog/2018/11/26/Activiti工作流引擎/</id>
    <published>2018-11-26T14:25:27.000Z</published>
    <updated>2018-12-01T03:12:32.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间入职字节跳动, 目前负责 Lark 工作流审批功能的开发, 选用工作流引擎 <code>Activiti</code> 进行开发, 因此在此记录下对 <code>Activiti</code> 的学习过程.</p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>工作流引擎是用来驱动业务, 按照流程图次逐步流转的核心框架, 在复杂多变的场景下采用工作流引擎可以大大降低业务部署成本. 通过标准的业务流程模型作为业务与开发工作的桥梁, 有效减少业务团队与技术交流的障碍.</p></blockquote><p>工作流引擎最早用于企业 OA, CRM, 流程审批等系统的流程审批.<br>现在的工作流引擎已经大量运用到互联网电商, 金融出行, 中台支撑等.</p><p>工作流引擎在互联网公司快速盛行, 掌握工作流引擎技术可以提升技术架构和业务建模能力. </p><p>目录:</p><ul><li>工作流入门</li><li>Activiti 6.0 源码浅析</li><li>Activiti 6.0 引擎配置</li><li>Activiti 6.0 核心 API</li><li>数据设计与模型映射</li><li>BPMN 2.0 规范</li><li>集成 SpringBoot 2.0</li><li>搭建工作流平台</li></ul><h1 id="1-工作流入门"><a href="#1-工作流入门" class="headerlink" title="1. 工作流入门"></a>1. 工作流入门</h1><h2 id="1-1-工作流介绍"><a href="#1-1-工作流介绍" class="headerlink" title="1.1 工作流介绍"></a>1.1 工作流介绍</h2><h3 id="1-1-1-出差流程"><a href="#1-1-1-出差流程" class="headerlink" title="1.1.1 出差流程"></a>1.1.1 出差流程</h3><p>审批业务场景:</p><p><img src=".Activiti工作流引擎_images/08008382.png" alt=""> </p><p>审批流程模型化:</p><p><img src=".Activiti工作流引擎_images/835a7f82.png" alt=""></p><p>从一个开始节点, 经过多个任务节点和分支节点, 最终流向结束节点.</p><h3 id="1-1-2-电商购物流程"><a href="#1-1-2-电商购物流程" class="headerlink" title="1.1.2 电商购物流程"></a>1.1.2 电商购物流程</h3><p><img src=".Activiti工作流引擎_images/0b951608.png" alt=""></p><p>抽象成泳道图:</p><p><img src=".Activiti工作流引擎_images/3a10b0ab.png" alt=""></p><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">抽象名称</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">电商购物流程</td><td style="text-align:center">泳池(Pool)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">用户/电商平台/仓储物流</td><td style="text-align:center">泳道(Line)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">校验库存</td><td style="text-align:center">服务任务(Service Task)</td><td style="text-align:center">不需要人工参与, 需要系统自动化完成的操作节点</td></tr></tbody></table><h3 id="1-1-3-工作流是什么"><a href="#1-1-3-工作流是什么" class="headerlink" title="1.1.3 工作流是什么"></a>1.1.3 工作流是什么</h3><blockquote><h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流:"></a>工作流:</h4><p>是对工作流程以及各个步骤之间的业务规则的抽象, 概括描述.</p></blockquote><blockquote><h4 id="工作流建模"><a href="#工作流建模" class="headerlink" title="工作流建模:"></a>工作流建模:</h4><p>将工作流程中的工作如何前后组织在一起的逻辑和规则, 在计算机中以恰当的模型表达并对其实施计算.</p></blockquote><blockquote><h4 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题:"></a>要解决的问题:</h4><p>为实现某个业务目标, 利用计算机在多个参与者之间按某种预定规则自动传递文档, 信息或任务.</p></blockquote><table><thead><tr><th>关键词</th><th>概念</th></tr></thead><tbody><tr><td>工作流管理系统</td><td>处理工作流的电脑软件系统, 主要功能是通过计算机技术的支持去定义, 执行和管理工作流, 协调工作流执行过程中工作之间以及群体之间的信息交互</td></tr><tr><td>计算机支持的协同工作</td><td>研究一个群体如何在计算机的帮助下实现协同工作的, 工作流属于计算机支持的协同工作的一部分</td></tr><tr><td>工作流管理联盟</td><td>工作流技术标准化的工业组织, 发布了用于工作流管理系统之间互操作的工作流参考模型, 并相继制定了一些列工业标准</td></tr></tbody></table><h3 id="1-1-4-为什么需要工作流"><a href="#1-1-4-为什么需要工作流" class="headerlink" title="1.1.4 为什么需要工作流"></a>1.1.4 为什么需要工作流</h3><h4 id="日常开发中经常遇到的问题"><a href="#日常开发中经常遇到的问题" class="headerlink" title="日常开发中经常遇到的问题:"></a>日常开发中经常遇到的问题:</h4><ol><li>产品需求遗漏, 开发上线之后需求经常改;</li><li>业务代码复杂, 开发时间紧迫;</li><li>代码后期维护不足, 逐渐难以维护.</li></ol><h4 id="使用工作流能够带来的改变"><a href="#使用工作流能够带来的改变" class="headerlink" title="使用工作流能够带来的改变:"></a>使用工作流能够带来的改变:</h4><ol><li>可以快速响应, 灵活调整线上产品流程;</li><li>业务和开发基于流程模型沟通, 基于业务建模快速部署;</li><li>流程可视化, 方便查看流程的运行进展.</li></ol><h4 id="使用工作流对团队的作用"><a href="#使用工作流对团队的作用" class="headerlink" title="使用工作流对团队的作用:"></a>使用工作流对团队的作用:</h4><ol><li>提高效率, 减少等待;</li><li>规范行为, 落实制度;</li><li>协同内外, 快速响应;</li><li>监控全面, 提升执行.</li></ol><h2 id="1-2-工作流技术选型"><a href="#1-2-工作流技术选型" class="headerlink" title="1.2 工作流技术选型"></a>1.2 工作流技术选型</h2><blockquote><p>二者都是成熟的工作流框架</p></blockquote><table><thead><tr><th>jBPM</th><th>Activiti</th></tr></thead><tbody><tr><td>Hibernate</td><td>ByBatis</td></tr><tr><td>Drools Flow</td><td>JBPM4</td></tr><tr><td>JPA</td><td>Spring</td></tr><tr><td>Message</td><td>RESTful</td></tr></tbody></table><h2 id="1-3-Activiti6-0-快速体验"><a href="#1-3-Activiti6-0-快速体验" class="headerlink" title="1.3 Activiti6.0 快速体验"></a>1.3 Activiti6.0 快速体验</h2><h3 id="1-3-1-准备物料"><a href="#1-3-1-准备物料" class="headerlink" title="1.3.1 准备物料"></a>1.3.1 准备物料</h3><ul><li>Activiti 软件包: <code>activiti-6.0.0.zip</code></li><li>JDK</li><li>Servlet 容器 (如 Tomcat)</li></ul><h4 id="安装-sdkman"><a href="#安装-sdkman" class="headerlink" title="安装 sdkman"></a>安装 sdkman</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -s <span class="string">"https://get.sdkman.io"</span> | bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="string">"<span class="variable">$HOME</span>/.sdkman/bin/sdkman-init.sh"</span></span><br><span class="line"></span><br><span class="line">sdk version</span><br></pre></td></tr></table></figure><h4 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sdk install java 8u161-oracle</span><br><span class="line"></span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure><h4 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/tomcat/tomcat/8/v8.0.50/bin/apache-tomcat-8.0.50.zip</span><br><span class="line"></span><br><span class="line">tar -zxvf apache-tomcat-8.0.50.zip</span><br><span class="line"></span><br><span class="line">./apache-tomcat-8.0.50/bin/startup.sh</span><br><span class="line"></span><br><span class="line">jdp-mlv</span><br></pre></td></tr></table></figure><h4 id="部署-Activiti"><a href="#部署-Activiti" class="headerlink" title="部署 Activiti"></a>部署 Activiti</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/Activiti/Activiti/releases/download/activiti-6.0.0/activiti-6.0.0.zip</span><br><span class="line"></span><br><span class="line">tar -zxvf activiti-6.0.0.zip</span><br><span class="line"></span><br><span class="line">cp activiti-6.0.0/wars/activiti-app.war apache-tomcat-8.0.50/webapps</span><br><span class="line">cp activiti-6.0.0/wars/activiti-admin.war apache-tomcat-8.0.50/webapps</span><br></pre></td></tr></table></figure><p>此时打开浏览器, 输入 <a href="http://localhost:8080/activiti-app" target="_blank" rel="noopener">http://localhost:8080/activiti-app</a> 即可进入流程引擎的登录界面</p><pre><code>账号: admin密码: test</code></pre><h3 id="1-3-2-设计一个审批流程"><a href="#1-3-2-设计一个审批流程" class="headerlink" title="1.3.2 设计一个审批流程"></a>1.3.2 设计一个审批流程</h3><p>设计如下流程:</p><p>开始 -&gt; TL 审批 -&gt; HR 审批 -&gt; 结束</p><h4 id="流程参与者"><a href="#流程参与者" class="headerlink" title="流程参与者"></a>流程参与者</h4><table><thead><tr><th>ID</th><th>Email</th><th>Name</th></tr></thead><tbody><tr><td>admin</td><td>admin</td><td>Administrator</td></tr><tr><td>userdev</td><td><a href="mailto:userdev@126.com" target="_blank" rel="noopener">userdev@126.com</a></td><td>userdevDEV</td></tr><tr><td>userhr</td><td><a href="mailto:userhr@126.com" target="_blank" rel="noopener">userhr@126.com</a></td><td>userhrHR</td></tr><tr><td>usertl</td><td><a href="mailto:usertl@126.com" target="_blank" rel="noopener">usertl@126.com</a></td><td>usertlTL</td></tr></tbody></table><h1 id="2-源码概述"><a href="#2-源码概述" class="headerlink" title="2. 源码概述"></a>2. 源码概述</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:DestinyWang/Activiti.git</span><br><span class="line"></span><br><span class="line">git checkout -b study6 activiti-6.0.0</span><br><span class="line"></span><br><span class="line">mvn clean <span class="built_in">test</span>-compile</span><br></pre></td></tr></table></figure><table><thead><tr><th>路径</th><th>功能</th></tr></thead><tbody><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/cfg</code></td><td>Activiti 的启动依赖 <code>activiti.cfg.xml</code>, 在该目录完成</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/compatibility</code></td><td>Activiti 从 5 升级到 6 的时候有部分不兼容, 在该目录完成适配</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/debug</code></td><td>调试相关目录</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/delegate</code></td><td>需要制定的节点 Task 都需要实现 <code>JavaDelegate</code></td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/event</code></td><td>定义了事件和监听机制</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/form</code></td><td>通用表单</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/history</code></td><td>历史数据归档</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/identity</code></td><td>身份认证相关操作</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/impl</code></td><td>各个接口层的实现</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/logging</code></td><td>LogMDC 将重要的变量(如流程 id 放在上下文, logback 可以打印出来)</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/management</code></td><td>管理相关</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/parse</code></td><td>流程文件是 xml, 需要解析和验证</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/query</code></td><td>抽象了一些查询接口, 基于 mybatis</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/repository</code></td><td>抽象流程部署到数据库的过程</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/runtime</code></td><td>与 history 相对应, 是流程在流转过程中的数据</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/task</code></td><td>每个流程在需要人工处理的时候都会对应一个 task</td></tr><tr><td><code>Activiti/activiti-engine/src/main/java/org/activiti/engine/test</code></td><td>支持集成测试的帮助类</td></tr></tbody></table><p>核心模块:</p><ul><li><code>module/activiti-engine</code>: 核心引擎</li><li><code>module/activiti-spring</code>: Spring 集成模块</li><li><code>module/activiti-spring-boot</code>: SpringBoot 集成模块</li><li><code>module/activiti-rest</code>: 对外提供 rest api 模块</li><li><code>module/activiti-form-engine</code>: 表单引擎模块</li><li><code>module/activiti-ldap</code>: 集成 ldap 用户模块</li></ul><p>Activiti-engine 依赖的模块:</p><ul><li>bpmn-converter: 模型转换</li><li>process-validation: 流程校验</li><li>image-generator: 流程图绘制(BPMN 转 PNG)</li><li>dmn-api: 决策标准</li><li>form-api/form-model: form 表单相关</li></ul><h2 id="2-1-基于源码运行-activiti-app"><a href="#2-1-基于源码运行-activiti-app" class="headerlink" title="2.1 基于源码运行 activiti-app"></a>2.1 基于源码运行 activiti-app</h2><h3 id="2-1-1-启动-activiti-app"><a href="#2-1-1-启动-activiti-app" class="headerlink" title="2.1.1 启动 activiti-app"></a>2.1.1 启动 activiti-app</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> modules/activiti-ui/activiti-app</span><br><span class="line"></span><br><span class="line">mvn clean tomcat7:run</span><br><span class="line"></span><br><span class="line">open http://localhost:9999/activi-app</span><br></pre></td></tr></table></figure><h2 id="2-2-剖析-activiti-app"><a href="#2-2-剖析-activiti-app" class="headerlink" title="2.2 剖析 activiti-app"></a>2.2 剖析 activiti-app</h2><p>activiti-ui 的组成:</p><ul><li>activiti-app: 集成发布的 war 工程</li><li>activiti-app-conf: UI 独立域业务外的配置</li><li>activiti-app-logic: UI 的业务逻辑</li><li>activiti-app-rest: 提供接口的 rest api</li></ul><h1 id="3-HelloWorld"><a href="#3-HelloWorld" class="headerlink" title="3. HelloWorld"></a>3. HelloWorld</h1><p><img src="https://user-images.githubusercontent.com/17758731/49322695-b05cee00-f54c-11e8-8aeb-8f47882a7de9.png" alt="image"></p><ul><li>填写审批信息: 姓名, 时间, 是否提交</li><li>主管审批: 审批结果, 备注</li><li>审批结果, 备注</li></ul><h2 id="3-1-在-IDEA-中完成流程图的设计并配置"><a href="#3-1-在-IDEA-中完成流程图的设计并配置" class="headerlink" title="3.1 在 IDEA 中完成流程图的设计并配置"></a>3.1 在 IDEA 中完成流程图的设计并配置</h2><p><img src="https://user-images.githubusercontent.com/17758731/49323198-d7b6b980-f552-11e8-960e-271783710299.png" alt="image"></p><p>配置点:</p><ol><li>节点 id, 名称;</li><li>对每个网关的分支做判断(基于填写信息);</li><li>Task 节点接收的表单信息.</li></ol><h3 id="3-1-2-Task-节点接收的表单信息"><a href="#3-1-2-Task-节点接收的表单信息" class="headerlink" title="3.1.2 Task 节点接收的表单信息"></a>3.1.2 Task 节点接收的表单信息</h3><h4 id="填写申请信息"><a href="#填写申请信息" class="headerlink" title="填写申请信息"></a>填写申请信息</h4><table><thead><tr><th>Id</th><th>Name</th><th>Type</th><th>Expression</th><th>Variable</th><th>Default</th><th>Date Pattern</th><th>Readable</th><th>Writable</th><th>Required</th><th>Values</th></tr></thead><tbody><tr><td>message</td><td>申请信息</td><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td>True</td><td></td></tr><tr><td>name</td><td>申请人姓名</td><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td>True</td><td></td></tr><tr><td>submitTime</td><td>提交时间</td><td>date</td><td></td><td></td><td></td><td>yyyy-MM-dd</td><td></td><td></td><td>True</td><td></td></tr><tr><td>submitType</td><td>确认申请</td><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td>True</td></tr></tbody></table><h4 id="主管审批"><a href="#主管审批" class="headerlink" title="主管审批"></a>主管审批</h4><table><thead><tr><th>Id</th><th>Name</th><th>Type</th><th>Expression</th><th>Variable</th><th>Default</th><th>Date Pattern</th><th>Readable</th><th>Writable</th><th>Required</th><th>Values</th></tr></thead><tbody><tr><td>tlApprove</td><td>主管审批结果</td><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td>false</td><td></td></tr><tr><td>tlMessage</td><td>主管审批备注</td><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td>true</td></tr></tbody></table><h4 id="人事审批"><a href="#人事审批" class="headerlink" title="人事审批"></a>人事审批</h4><table><thead><tr><th>Id</th><th>Name</th><th>Type</th><th>Expression</th><th>Variable</th><th>Default</th><th>Date Pattern</th><th>Readable</th><th>Writable</th><th>Required</th><th>Values</th></tr></thead><tbody><tr><td>hrApprove</td><td>人事审批结果</td><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td>true</td><td></td></tr><tr><td>hrMessage</td><td>人事审批备注</td><td>string</td><td></td><td></td><td></td><td></td><td></td><td></td><td>true</td></tr></tbody></table><h3 id="3-1-3-排他网关配置"><a href="#3-1-3-排他网关配置" class="headerlink" title="3.1.3 排他网关配置"></a>3.1.3 排他网关配置</h3><blockquote><p>排他网关需要对流入网关的某个值做判断, 从而决定流程后续的流向</p></blockquote><h4 id="flow3-配置"><a href="#flow3-配置" class="headerlink" title="flow3 配置"></a>flow3 配置</h4><pre><code>${submitType==&quot;Y&quot; || submitType==&quot;y&quot;}</code></pre><h4 id="flow4-配置"><a href="#flow4-配置" class="headerlink" title="flow4 配置"></a>flow4 配置</h4><pre><code>${submitType==&quot;N&quot; || submitType==&quot;n&quot;}</code></pre><h4 id="flow6-配置"><a href="#flow6-配置" class="headerlink" title="flow6 配置"></a>flow6 配置</h4><pre><code>${tlApprove == &quot;Y&quot; || tlApprove == &quot;y&quot;}</code></pre><h4 id="flow7-配置"><a href="#flow7-配置" class="headerlink" title="flow7 配置"></a>flow7 配置</h4><pre><code>${tlApprove == &quot;N&quot; || tlApprove == &quot;n&quot;}</code></pre><h4 id="flow9-配置"><a href="#flow9-配置" class="headerlink" title="flow9 配置"></a>flow9 配置</h4><pre><code>${hrApprove == &quot;Y&quot; || tlApprove == &quot;y&quot;}</code></pre><h4 id="flow10-配置"><a href="#flow10-配置" class="headerlink" title="flow10 配置"></a>flow10 配置</h4><pre><code>${hrApprove == &quot;N&quot; || tlApprove == &quot;n&quot;}</code></pre><p>配置后的流程图</p><p><img src="https://user-images.githubusercontent.com/17758731/49323670-e18feb00-f559-11e8-9967-a2bac264e9fe.png" alt="image"></p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><h1 id="4-Activiti-流程引擎配置"><a href="#4-Activiti-流程引擎配置" class="headerlink" title="4. Activiti 流程引擎配置"></a>4. Activiti 流程引擎配置</h1><p>流程引擎配置的载体就是 <code>ProcessEngineConfiguration</code> 及其子类, Activiti 是通过 <code>activiti.cfg.xml</code> 来完成配置</p><p>然后构建出流程引擎 <code>ProcessEngine</code>, 最终获取业务开发中需要的各个 Service.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[activiti.cfg.xml] --&gt;|解析配置| B(ProcessEngineConfiguration)</span><br><span class="line">B --&gt; |获取流程引擎|C[ProcessEngine]</span><br><span class="line">C --&gt; D[RepositoryService]</span><br><span class="line">C --&gt; E[RuntimeService]</span><br><span class="line">C --&gt; F[...Service]</span><br></pre></td></tr></table></figure><p>ProcessorEngineConfiguration:</p><ol><li>查找并解析 XML 配置文件 <code>activiti.cfg.xml</code></li><li>提供多个静态方法创建配置对象</li><li>实现几个基于不同场景的子类, 配置方式灵活</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 ProcessEngineConfiguration  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"processEngineConfiguration"</span> <span class="attr">class</span>=<span class="string">"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcDriver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/activitiDB?createDatabaseIfNotExist=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUsername"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcPassword"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- false: 不会自动创建表, 没有表, 则抛异常 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- create-drop: 先删除, 再创建表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- true: 没有表时，自动创建--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"databaseSchemaUpdate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ProcessEngineConfigurationImpl: 抽象类, 配置了 ProcessEngineConfiguration 大部分属性;<br>StandaloneProcessEngineConfiguration: 独立部署运行, 可以通过 new 的方式创建;<br>SpringProcessEngineConfiguration: 完成与 Spring 的集成, 同时扩展了数据源配置, 事务, 自动装载部署文件的目录.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前段时间入职字节跳动, 目前负责 Lark 工作流审批功能的开发, 选用工作流引擎 &lt;code&gt;Activiti&lt;/code&gt; 进行开发, 因此在此记录下对 &lt;code&gt;Activiti&lt;/code&gt; 的学习过程.&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/categories/Activiti/"/>
    
      <category term="Java" scheme="https://destinywang.github.io/blog/categories/Activiti/Java/"/>
    
      <category term="工作流" scheme="https://destinywang.github.io/blog/categories/Activiti/Java/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>Golang快速入门</title>
    <link href="https://destinywang.github.io/blog/2018/11/24/Golang%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://destinywang.github.io/blog/2018/11/24/Golang快速入门/</id>
    <published>2018-11-24T02:56:30.000Z</published>
    <updated>2018-11-25T03:13:17.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h1><h2 id="6-2-包的引出和使用原理"><a href="#6-2-包的引出和使用原理" class="headerlink" title="6.2 包的引出和使用原理"></a>6.2 包的引出和使用原理</h2><p>当调用另一个文件的函数时, 就需要在调用方引入该文件所在的 <code>package</code></p><blockquote><p>Go 代码的每一个文件都是属于一个包的, 也就是说 Go 是以包的形式来管理文件和项目目录结构的.</p></blockquote><p>Go 语言中, 每个文件夹下的所有 Go 源代码必须属于同一个包, 推荐与文件夹名相同. 而在 import 的时候, 只以包为基本单位而不是 Go 源码文件.</p><p>包的基本作用:</p><ol><li>区分相同名称的函数, 变量等标识符</li><li>管理项目</li><li>控制函数, 变量等访问范围</li></ol><p>声明 package 的基本语法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="string">`包名`</span></span><br></pre></td></tr></table></figure></p><p>引入包的基本语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">`包路径`</span></span><br></pre></td></tr></table></figure></p><p>在引入包路径的时候, 是从 <code>$GOPATH/src</code> 路径下开始引入</p><h4 id="包的注意事项和细节"><a href="#包的注意事项和细节" class="headerlink" title="包的注意事项和细节"></a>包的注意事项和细节</h4><ol><li>在该一个文件打包的时候, 该包对应一个文件夹, 文件的包名通常和文件所在的文件夹名一致, 且一般为小写字母;</li><li>当一个文件要使用其他包函数或变量的时候, 需要先引入对应的包<br>package 指令在文件第一行, 然后是 import 指令<br>在 import 包时, 路径从 <code>$GOPATH/src</code> 下开始, 不用带 src, 编译器会自动从 src 下开始引入. 如当执行 <code>import fmt</code> 的时候, 实际上是从 <code>$GOPATH/src/fmt</code> 进行引入.</li><li>为了让其他包的文件可以访问到本包的函数, 则需要首字母大写, 类似其他编程语言的 <code>public</code>, 这样才能跨包访问;</li><li>在访问其他包函数的时候, 去语法是 <code>包名.函数名</code></li><li>如果报名比较长, Go 支持给包取别名, 而取别名后, 原包名就不可再使用;</li><li>在同一个包下, 不能有相同的函数名或相同的全局变量, 否则会报重复定义的错;</li><li>如果需要编译一个可执行程序文件, 就需要将这个包声明为 <code>main</code>, 即 <code>package main</code></li></ol><h2 id="6-3-函数调用机制底层剖析"><a href="#6-3-函数调用机制底层剖析" class="headerlink" title="6.3 函数调用机制底层剖析"></a>6.3 函数调用机制底层剖析</h2><h3 id="6-3-1-运行时内存结构"><a href="#6-3-1-运行时内存结构" class="headerlink" title="6.3.1 运行时内存结构"></a>6.3.1 运行时内存结构</h3><ol><li>在调用一个函数时, 会给该函数重新分配一个新的空间, 编译器会通过自身的处理让这个新的空间和其他栈空间分开;</li><li>在每个函数对应的栈中, 数据空间是独立的, 不会混淆;</li><li>当一个函数调用完毕后, 程序会销毁这个函数对应的栈空间.</li></ol><p><img src=".Golang快速入门_images/a4522b60.png" alt=""></p><h3 id="6-3-2-return-语句"><a href="#6-3-2-return-语句" class="headerlink" title="6.3.2 return 语句"></a>6.3.2 return 语句</h3><blockquote><p>Go 函数支持返回多个值</p></blockquote><ol><li>如果返回多个值时, 在接收时, 如果希望忽略某个返回值, 可以使用 <code>_</code> 符号表示忽略</li><li>如果返回值只有一个, <code>(返回值类型列表)</code> 可以不写 <code>()</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形参列表...)</span> <span class="params">(返回值类型列表...)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-4-函数的递归调用"><a href="#6-4-函数的递归调用" class="headerlink" title="6.4 函数的递归调用"></a>6.4 函数的递归调用</h2><blockquote><p>函数体内又调用了自身, 这个过程就叫做递归</p></blockquote><p>递归函数需要遵守的规则:</p><ol><li>执行一个函数时, 就创建一个新的受保护的独立内存空间(新函数栈);</li><li>函数的局部变量是独立的, 不会相互影响;</li><li>递归必须向退出的条件逼近;</li><li>当一个函数执行完毕, 或者遇到 <code>return</code>, 就会返回, 遵守谁调用就将结果返回给谁, 同时当函数执行完毕或者返回时, 该函数本身也会被系统销毁.</li></ol><h3 id="6-4-1-Fibonacci-数列"><a href="#6-4-1-Fibonacci-数列" class="headerlink" title="6.4.1 Fibonacci 数列"></a>6.4.1 Fibonacci 数列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + finonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-2-求函数值"><a href="#6-4-2-求函数值" class="headerlink" title="6.4.2 求函数值"></a>6.4.2 求函数值</h3><blockquote><p>f(1)=3;<br>f(n)=2*f(n-1)+1</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * f(n<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-3-猴子吃桃"><a href="#6-4-3-猴子吃桃" class="headerlink" title="6.4.3 猴子吃桃"></a>6.4.3 猴子吃桃</h3><blockquote><p>有一堆桃子, 猴子第一天吃了其中的一半又多吃了一个, 后面每天都吃其中的一半再多一个, 当吃到第 10 天的时候发现只有一个桃子, 求最初有多少个桃子.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peach(n) = (peach(n+1) + 1) * 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">peach</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (peach(n+<span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-函数注意事项和细节讨论"><a href="#6-5-函数注意事项和细节讨论" class="headerlink" title="6.5 函数注意事项和细节讨论"></a>6.5 函数注意事项和细节讨论</h2><ol><li>函数的形参列表可以是多个, 返回值列表也可以是多个;</li><li>形参列表和返回值列表的数据类型可以是值类型和引用类型;</li><li>函数的命名规范遵循标识符命名规范, 首字母不能使数字, 首字母大写该函数可以被其他包访问, 类似 <code>public</code>; 首字母小写, 只能被本包文件使用, 其他包文件不能访问, 类似 <code>private</code>;</li><li>函数中变量是局部的, 函数外不生效;</li><li>基本数据类型和数组默认是值传递, 即进行值拷贝, 在函数内修改, 不会影响到原来的值;</li><li>如果希望函数内的变量能修改函数外的变量, 可以传入变量的地址 <code>&amp;变量标识符</code>, 函数内以指针的方式操作变量;</li><li>Go 语言的函数不支持重载;</li><li>在 Go 中, 函数也是一种数据类型, 可以赋值给一个变量, 则该变量就是一个函数类型的变量了, 通过该变量可以对函数调用;</li><li>既然函数时一种数据类型, 那么在 Go 中, 函数可以作为形参传递并且被调用.</li><li>为了简化数据类型定义, Go 支持自定义数据类型, 基本语法 <code>type 自定义数据类型名 数据类型</code>, 相当于一个别名;</li><li>支持对函数返回值命名.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6-函数&quot;&gt;&lt;a href=&quot;#6-函数&quot; class=&quot;headerlink&quot; title=&quot;6. 函数&quot;&gt;&lt;/a&gt;6. 函数&lt;/h1&gt;&lt;h2 id=&quot;6-2-包的引出和使用原理&quot;&gt;&lt;a href=&quot;#6-2-包的引出和使用原理&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Golang" scheme="https://destinywang.github.io/blog/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://destinywang.github.io/blog/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门(3)--面向接口</title>
    <link href="https://destinywang.github.io/blog/2018/11/18/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8-3-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <id>https://destinywang.github.io/blog/2018/11/18/Go语言入门-3-面向接口/</id>
    <published>2018-11-18T02:53:18.000Z</published>
    <updated>2018-11-18T12:28:56.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go 语言面向对象只支持封装, 传统面向对象语言中靠继承和多态完成的事情在 Go 中都是通过接口来完成, 因此 Go 中的接口比传统的语言灵活很多</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Traversal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Traverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    traversal := getTraversal()</span><br><span class="line">    traversal.Traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-duck-typing"><a href="#1-duck-typing" class="headerlink" title="1. duck typing"></a>1. duck typing</h1><blockquote><p>“像鸭子走路, 像鸭子叫(长得像鸭子), 那么它就是鸭子”</p></blockquote><p>描述事物的外部行为而非内部结构</p><p>严格来说 Go 属于结构化类型系统, 类似 <code>duck typing</code></p><h2 id="1-1-python-中的-ducking-typing"><a href="#1-1-python-中的-ducking-typing" class="headerlink" title="1.1 python 中的 ducking typing"></a>1.1 python 中的 ducking typing</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(retriever)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> retriever.get(<span class="string">"org.destiny.io"</span>)</span><br></pre></td></tr></table></figure><ul><li>运行时才知道传入的 retriever 有没有 <code>get</code></li><li>通常需要注释来说明接口</li></ul><h2 id="1-2-C-中的-ducking-typing"><a href="#1-2-C-中的-ducking-typing" class="headerlink" title="1.2 C++ 中的 ducking typing"></a>1.2 C++ 中的 ducking typing</h2><p>通过模板来实现 duck typing, 编译时才知道传入的 retriever 有没有 get, 而在编写代码的时候不能直接感知, 因此也需要注释来说明接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">string</span> <span class="title">download</span>(<span class="title">const</span> <span class="title">R</span>&amp; <span class="title">retriever</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> retriever.get(<span class="string">"org.destiny.io"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-Java-中的类似代码"><a href="#1-3-Java-中的类似代码" class="headerlink" title="1.3 Java 中的类似代码"></a>1.3 Java 中的类似代码</h2><p>传入的参数必须实现 Retriever 接口<br>但不属于 duck typing</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;R extends Retriever&gt;</span><br><span class="line"><span class="function">String <span class="title">downlaad</span><span class="params">(R r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.get(<span class="string">"org.destiny.io"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-Go-语言中的-duck-typing"><a href="#1-4-Go-语言中的-duck-typing" class="headerlink" title="1.4 Go 语言中的 duck typing"></a>1.4 Go 语言中的 duck typing</h2><ul><li>同时需要 <code>Readable</code>, <code>Appendable</code> 怎么办</li><li>同时具有 python, C++ 的 duck typing 的灵活性</li><li>又具有 Java 的类型检查</li></ul><h1 id="2-接口的定义和实现"><a href="#2-接口的定义和实现" class="headerlink" title="2. 接口的定义和实现"></a>2. 接口的定义和实现</h1><ul><li>download: 使用者</li><li>retriever: 实现者</li></ul><p>接口由使用者定义</p><blockquote><p>main.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.Get(<span class="string">"org.destiny.io"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Retriever</span><br><span class="line">    r = mock.Retriever&#123;<span class="string">"this is a mock Retriever"</span>&#125;</span><br><span class="line">    fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>retriever.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line">    Contents <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.Contents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>real/retriever.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserAgent <span class="keyword">string</span></span><br><span class="line">    TimeOut time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>main/retriever.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Retriever</span><br><span class="line">    r = <span class="built_in">real</span>.Retriever&#123;&#125;</span><br><span class="line">    fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="3-接口的值类型"><a href="#3-接口的值类型" class="headerlink" title="3. 接口的值类型"></a>3. 接口的值类型</h1><p>继续上例:<br>打印出 <code>r</code> 的具体类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r Retriever</span><br><span class="line">    r = mock.Retriever&#123;<span class="string">"this is a mock Retriever"</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%T, %v\n"</span>, r, r)    <span class="comment">// mock.Retriever &#123;this is a mock Retriever&#125;</span></span><br><span class="line">    r = <span class="built_in">real</span>.Retriever&#123;&#125;</span><br><span class="line">    <span class="comment">// 输出的空格代表 string 类型的 UserAgent, 0s 代表 time.Duration 类型的额 TimeOut</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T, %v\n"</span>, r, r)    <span class="comment">// real.Retriever &#123; 0s&#125;</span></span><br><span class="line">    fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>r 中一共包含两项内容:<br>r 的类型以及 r 的内容</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Go 语言面向对象只支持封装, 传统面向对象语言中靠继承和多态完成的事情在 Go 中都是通过接口来完成, 因此 Go 中的接口比传统的语言灵活很多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="golang" scheme="https://destinywang.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://destinywang.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门(2)--面向接口</title>
    <link href="https://destinywang.github.io/blog/2018/11/06/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8-2-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <id>https://destinywang.github.io/blog/2018/11/06/Go语言入门-2-面向接口/</id>
    <published>2018-11-06T12:14:18.000Z</published>
    <updated>2018-11-07T12:25:33.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-结构体和方法"><a href="#1-结构体和方法" class="headerlink" title="1. 结构体和方法"></a>1. 结构体和方法</h1><ul><li>go 语言只支持封装, 不支持继承和多态</li><li>go 语言没有 class, 只有 struct</li></ul><h2 id="1-1-结构的创建"><a href="#1-1-结构的创建" class="headerlink" title="1.1 结构的创建"></a>1.1 结构的创建</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Left, Right * TreeNode</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 value 为 0, left, right 都为 nil 的 treeNode</span></span><br><span class="line"><span class="keyword">var</span> root treeNode</span><br><span class="line">fmt.Println(root)<span class="comment">// &#123;0 &lt;nil&gt; &lt;nil&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">root1 := treeNode&#123;value:<span class="number">3</span>, left:&amp;treeNode&#123;&#125;, right:&amp;treeNode&#123;<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;&#125;</span><br><span class="line">root1.right.left = <span class="built_in">new</span>(treeNode)</span><br><span class="line">fmt.Println(root1)<span class="comment">// &#123;3 0xc00000a080 0xc00000a0a0&#125;</span></span><br><span class="line">fmt.Println(*root1.left)<span class="comment">// &amp;&#123;0 &lt;nil&gt; &lt;nil&gt;&#125;</span></span><br><span class="line">fmt.Println(*root1.right)<span class="comment">// &amp;&#123;5 0xc00000a0c0 &lt;nil&gt;&#125;</span></span><br><span class="line">fmt.Println(*root1.right.left)<span class="comment">// &amp;&#123;0 &lt;nil&gt; &lt;nil&gt;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-结构的方法"><a href="#1-2-结构的方法" class="headerlink" title="1.2 结构的方法"></a>1.2 结构的方法</h2><p>行如接受者的写法, 也是采用值传递, 也就意味着如果需要在函数内对结构体做修改, 必须采用传指针的方式</p><ul><li><code>func (node treeNode) print() {...}</code> 只能完成读操作</li><li><code>func (node *treeNode) setValue() {...}</code> 才能进行修改</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> treeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="keyword">int</span></span><br><span class="line">left, right * treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结构体创建方法的时候, 不能直接写在结构体内部</span></span><br><span class="line"><span class="comment">// 在函数名的前面加了一个括号, 称为接收者</span></span><br><span class="line"><span class="comment">// 代表 print 函数并非无参, 而是必须由 treeNode 对象来调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(node.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 value 为 0, left, right 都为 nil 的 treeNode</span></span><br><span class="line"><span class="keyword">var</span> root treeNode</span><br><span class="line">fmt.Println(root)<span class="comment">// &#123;0 &lt;nil&gt; &lt;nil&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">root1 := treeNode&#123;value:<span class="number">3</span>, left:&amp;treeNode&#123;&#125;, right:&amp;treeNode&#123;<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;&#125;</span><br><span class="line">root1.right.left = <span class="built_in">new</span>(treeNode)</span><br><span class="line">fmt.Println(root1)<span class="comment">// &#123;3 0xc00000a080 0xc00000a0a0&#125;</span></span><br><span class="line">fmt.Println(*root1.left)<span class="comment">// &amp;&#123;0 &lt;nil&gt; &lt;nil&gt;&#125;</span></span><br><span class="line">fmt.Println(*root1.right)<span class="comment">// &amp;&#123;5 0xc00000a0c0 &lt;nil&gt;&#125;</span></span><br><span class="line">fmt.Println(*root1.right.left)<span class="comment">// &amp;&#123;0 &lt;nil&gt; &lt;nil&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">root.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 语言中的函数自身做了兼容, 调用参数的使用, 不论采用传值还是传地址, 都可以按照函数的要求自动转型</p><ul><li>实际调用如果是传指针, 编译器会自动将结构体取地址</li><li>实际调用如果是传值, 编译器会自动将指针解引用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(node.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">node.value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pRoot := &amp;root</span><br><span class="line">pRoot.<span class="built_in">print</span>()</span><br><span class="line">pRoot.setValue(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">aRoot := root</span><br><span class="line">aRoot.<span class="built_in">print</span>()</span><br><span class="line">aRoot.setValue(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只有使用指针才能改变结构的内容<br>nil 指针也可以调用方法</p></blockquote><blockquote><p>值接受者与指针接收者:<br>要改变必须使用指针接收者<br>结构过大也需要考虑使用指针接收者<br>值接受者是 go 语言特有的概念<br>值/指针接受者均可接受值/指针, 编译器会自行做修正</p></blockquote><h1 id="2-包和封装"><a href="#2-包和封装" class="headerlink" title="2. 包和封装"></a>2. 包和封装</h1><ul><li>名字一般使用 <code>CamelCase</code></li><li>首字母大写: public</li><li>首字母小写: private</li></ul><blockquote><p>而 public 和 private 的概念是针对包提出的</p></blockquote><ul><li>每个目录一个包</li><li>main 包比较特殊, 包含可执行入口</li><li>为结构定义的方法必须放在同一个包内</li><li>可以是不同的文件</li></ul><h1 id="3-扩展已有类型"><a href="#3-扩展已有类型" class="headerlink" title="3. 扩展已有类型"></a>3. 扩展已有类型</h1><p>既然 go 语言没有继承和多态, 该如何去扩充系统类型或者别人的类型:</p><ul><li>定义别名</li><li>使用组合</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">head := (*q)[<span class="number">0</span>]</span><br><span class="line">*q = (*q)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"demo/queue"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">q := queue.Queue&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">q.Push(<span class="number">2</span>)</span><br><span class="line">q.Push(<span class="number">3</span>)</span><br><span class="line">fmt.Println(q.Pop())<span class="comment">// 1</span></span><br><span class="line">fmt.Println(q.Pop())<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">fmt.Println(q.IsEmpty())<span class="comment">// false</span></span><br><span class="line">fmt.Println(q.Pop())<span class="comment">// 3</span></span><br><span class="line">fmt.Println(q.IsEmpty())<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-结构体和方法&quot;&gt;&lt;a href=&quot;#1-结构体和方法&quot; class=&quot;headerlink&quot; title=&quot;1. 结构体和方法&quot;&gt;&lt;/a&gt;1. 结构体和方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;go 语言只支持封装, 不支持继承和多态&lt;/li&gt;
&lt;li&gt;go 语言没有 
      
    
    </summary>
    
      <category term="golang" scheme="https://destinywang.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://destinywang.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言入门(1)--基本语法</title>
    <link href="https://destinywang.github.io/blog/2018/11/04/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://destinywang.github.io/blog/2018/11/04/Go语言入门-1-基本语法/</id>
    <published>2018-11-04T03:12:52.000Z</published>
    <updated>2018-11-06T12:15:43.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装与环境"><a href="#1-安装与环境" class="headerlink" title="1. 安装与环境"></a>1. 安装与环境</h1><ul><li>下载: <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></li><li>Mac 默认安装在 <code>/usr/local/go/</code> 路径下</li></ul><h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h1><h3 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h2><h3 id="2-1-1-定义变量"><a href="#2-1-1-定义变量" class="headerlink" title="2.1.1 定义变量"></a>2.1.1 定义变量</h3><ul><li>使用 <code>var</code> 关键字<ul><li><code>var a, b, c</code></li><li><code>var s1, s2 = &quot;abc&quot;, &quot;def&quot;</code></li><li>可放在函数内, 也可放在保内</li><li>在 <code>var()</code> 中集中定义</li></ul></li><li>编译器可以自动决定类型<ul><li><code>var q, w, e, r = 1, true, variable, &quot;a&quot;</code></li></ul></li><li>使用 <code>:=</code> 定义变量<ul><li><code>z, x, v, c := 1, true, variable, &quot;a&quot;</code></li><li>只能在函数内使用</li></ul></li></ul><h3 id="2-1-2-内建变量类型"><a href="#2-1-2-内建变量类型" class="headerlink" title="2.1.2 内建变量类型"></a>2.1.2 内建变量类型</h3><ul><li>bool, string</li><li>(u)int, (u)int8, (u)int16, (u)int32, (u)int64, uintptr</li><li>byte, rune(长度四个字节, 代表一个字符, 类似 char)</li><li>float32, float64, complex64, complex128(复数类型)</li></ul><p>特别需要注意 go 对复数的支持:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">euler</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="comment">// 在表示负数的时候, 虚部直接与 i 连写就可以</span></span><br><span class="line">c1 := <span class="number">3</span> + <span class="number">4i</span></span><br><span class="line"><span class="comment">// 如果中间加上 *, 会变成乘法表达式</span></span><br><span class="line">c2 := <span class="number">3</span> + <span class="number">4</span> * i</span><br><span class="line">fmt.Println(c1, c2)<span class="comment">// 输出结果: (3+4i) 7</span></span><br><span class="line">fmt.Println(cmplx.Abs(c1))<span class="comment">// 输出结果: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 证明欧拉定律</span></span><br><span class="line">fmt.Printf(<span class="string">"%.4f"</span>, cmplx.Pow(math.E, <span class="number">1i</span> * math.Pi) + <span class="number">1</span>)<span class="comment">// 输出结果: (0.0000+0.0000i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-1-3-强制类型转换"><a href="#2-1-3-强制类型转换" class="headerlink" title="2.1.3 强制类型转换"></a>2.1.3 强制类型转换</h3><blockquote><p>go 语言只有强制类型转换, 没有隐式类型转换</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triangle</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 最初的方案 math.Sqrt(a * a + b * b) 会报错</span></span><br><span class="line"><span class="comment">// 因为 Sqrt 函数的参数和返回值都是 float64 类型的, 需要进行强制类型转换</span></span><br><span class="line">c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-常量的定义"><a href="#2-1-4-常量的定义" class="headerlink" title="2.1.4 常量的定义"></a>2.1.4 常量的定义</h3><ul><li>语法: <code>const filename = &quot;abc.txt&quot;</code></li><li>const 数值可作为各种类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consts</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">"abc.txt"</span></span><br><span class="line"><span class="keyword">const</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 此处不同于 var, 常量类似于文本替换, 只要不定义类型, 就可以表示成多种类型</span></span><br><span class="line">c = <span class="keyword">int</span>(math.Sqrt(a*a + b*b))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-5-枚举"><a href="#2-1-5-枚举" class="headerlink" title="2.1.5 枚举"></a>2.1.5 枚举</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enums</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">cpp    = <span class="number">0</span></span><br><span class="line">java   = <span class="number">1</span></span><br><span class="line">python = <span class="number">2</span></span><br><span class="line">golang = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(cpp, java, python, golang)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 语言为这种语法做了简化<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enums</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// iota 表示这组 const 是自增值</span></span><br><span class="line">cpp = <span class="literal">iota</span></span><br><span class="line">java</span><br><span class="line">python</span><br><span class="line">golang</span><br><span class="line">)</span><br><span class="line">fmt.Println(cpp, java, python, golang)<span class="comment">// 输出: 0 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用 <code>iota</code> 参与运算, 实现复杂的枚举初始值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enums</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用 iota 参与运算</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">kb</span><br><span class="line">mb</span><br><span class="line">gb</span><br><span class="line">tb</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Println(b, kb, mb, gb, tb)<span class="comment">// 输出结果: 1 1024 1048576 1073741824 1099511627776</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-条件语句"><a href="#2-2-条件语句" class="headerlink" title="2.2 条件语句"></a>2.2 条件语句</h2><h3 id="2-2-1-if-else"><a href="#2-2-1-if-else" class="headerlink" title="2.2.1 if else"></a>2.2.1 if else</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">"abc.txt"</span></span><br><span class="line">contents, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 中的条件判断可以简化成如下形式:</p><ul><li>if 条件语句中可以赋值;</li><li>if 条件中赋值的变量作用域就在这个 if 中.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">"abc.txt"</span></span><br><span class="line"><span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-switch"><a href="#2-2-2-switch" class="headerlink" title="2.2.2 switch"></a>2.2.2 switch</h3><blockquote><p>go 中的 switch 会自动 break, 除非使用 <code>fallthrough</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grade</span><span class="params">(score <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">g := <span class="string">""</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> score &lt; <span class="number">60</span>:</span><br><span class="line">g = <span class="string">"F"</span></span><br><span class="line"><span class="keyword">case</span> score &lt; <span class="number">80</span>:</span><br><span class="line">g = <span class="string">"C"</span></span><br><span class="line"><span class="keyword">case</span> score &lt; <span class="number">90</span>:</span><br><span class="line">g = <span class="string">"B"</span></span><br><span class="line"><span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">g = <span class="string">"A"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"wrong score: %d"</span>, score))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-循环"><a href="#2-2-3-循环" class="headerlink" title="2.2.3 循环"></a>2.2.3 循环</h3><ul><li>for 的条件中不需要括号</li><li>for 的条件里可以省略初始条件, 结束条件, 递增表达式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToBin</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    result := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">lsb := n % <span class="number">2</span></span><br><span class="line">result = strconv.Itoa(lsb) + result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>省略初始条件, 相当于 while</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无限循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"forever"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-函数"><a href="#2-3-函数" class="headerlink" title="2.3 函数"></a>2.3 函数</h2><ul><li>函数名在前, 返回类型在后</li><li>可返回多个值</li><li>函数可以作为参数</li><li>没有默认参数, 可选参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">result := <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> op &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">result = a + b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">result = a - b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">result = a * b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">result = a / b</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"unsupported operation: "</span> + op)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 语言中的函数还可以一次返回多个值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当需要返回多种类型时, 所有类型需要按顺序写在参数列表后的括号中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>go 语言的函数在返回多值的情况下, 可以指定变量名<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在接受具有多个返回值的函数执行结果时, 如果存在某些返回值不需要, 可以使用 <code>_</code> 的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q, r = div(16, 7)       // 两个返回值都需要</span><br><span class="line">q, _ = div(16, 7)       // 只需要第一个返回值</span><br></pre></td></tr></table></figure></p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * apply 函数接收三个参数 1. 一个参数为两个 int 并且返回一个 int 的函数</span></span><br><span class="line"><span class="comment"> * 2. 一个 int</span></span><br><span class="line"><span class="comment"> * 3. 一个 int</span></span><br><span class="line"><span class="comment"> * 并且自身返回一个int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取指向 op 函数的指针</span></span><br><span class="line">pointer := reflect.ValueOf(op).Pointer()</span><br><span class="line"><span class="comment">// 通过反射获取函数名</span></span><br><span class="line">opName := runtime.FuncForPC(pointer).Name()</span><br><span class="line">fmt.Printf(<span class="string">"Calling function %s with args (%d, %d)"</span>, opName, a, b)     <span class="comment">// 输出结果: Calling function main.pow with args (3, 4)</span></span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(apply(pow, <span class="number">3</span>, <span class="number">4</span>))       <span class="comment">// 输出结果: 81</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接把 pow 函数调用处在调用处声明为匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(apply(<span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">&#125;, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-指针"><a href="#2-4-指针" class="headerlink" title="2.4 指针"></a>2.4 指针</h2><ul><li>go 语言的指针不同于 C 的指针, 不能参与运算</li><li>go 语言之后值传递一种方式</li></ul><blockquote><p>值传递与引用传递<br>值传递: 调用方法的时候将参数做了一份拷贝, 与调用方的参数无关<br>引用传递: 不进行拷贝, 可能会对原值进行修改<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_val</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_ref</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    pass_by_val(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After pass_by_val: %d\n"</span>, a)    <span class="comment">// 3</span></span><br><span class="line">    pass_by_ref(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After pass_by_ref: %d\n"</span>, a)    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><table><thead><tr><th>变量</th><th>函数</th><th>调用结果</th></tr></thead><tbody><tr><td><code>var a int</code></td><td><code>func f(a int)</code></td><td>f 函数的会对 a 的副本进行操作, 无论如何操作都不会影响原值</td></tr><tr><td><code>var a int</code></td><td><code>func f(pa *int)</code></td><td>f 函数对 a 的修改会影响到原值</td></tr><tr><td><code>var cache Cache</code></td><td><code>func f(cache Cache)</code></td><td>cache 本身是一个指针</td></tr></tbody></table><p>交换值:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap1</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-内建容器"><a href="#3-内建容器" class="headerlink" title="3. 内建容器"></a>3. 内建容器</h1><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><ul><li>数量写在类型前</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果不进行初始化, int 数组所有元素都是0</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 使用 := 初始化的时候, 必须初始化内容</span></span><br><span class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 可以不指定长度, 由编译器去填充</span></span><br><span class="line">arr3 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arr1, arr2, arr3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组是值类型, 即传参的时候会进行 copy</p></blockquote><ul><li>[10]int 和 [20]int 是不同类型</li><li>与大部分语言的设计不同, 调用 func f(arr [10]int) 时会 copy 数组</li><li>在 go 语言中一般不直接使用数组, 而是切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="built_in">println</span>(i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printArray(arr1)</span><br><span class="line">printArray(arr2)    <span class="comment">// 会报错: cannot use arr2 (type [3]int) as type [5]int in argument to printArray</span></span><br><span class="line">printArray(arr3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子说明, 在 go 语言中, 长度为 3 的数组和长度为 5 的数组是不同的数据类型, 不能作为参数传递给 <code>printArray</code></p><h4 id="在函数调用中传递数组指针"><a href="#在函数调用中传递数组指针" class="headerlink" title="在函数调用中传递数组指针"></a>在函数调用中传递数组指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printArray(&amp;arr1)   <span class="comment">// [100, 0, 0, 0, 0]</span></span><br><span class="line">printArray(&amp;arr3)   <span class="comment">// [100, 4, 6, 8, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Slice-切片"><a href="#3-2-Slice-切片" class="headerlink" title="3.2 Slice(切片)"></a>3.2 Slice(切片)</h2><ul><li>slice 本身没有数据, 是对底层 array 的一个 view</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Println(<span class="string">"arr[2:6]: "</span>, s)<span class="comment">// [2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="string">"arr[:6]: "</span>, arr[:<span class="number">6</span>])    <span class="comment">// [0 1 2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="string">"arr[2:]: "</span>, arr[<span class="number">2</span>:])    <span class="comment">// [2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(<span class="string">"arr[:]: "</span>, arr[:])    <span class="comment">// [0 1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的 <code>s</code> 就是一个切片, 表示数组的一个左开右闭的区间</p><pre><code>arr: 0 1 2 3 4 5 6 7s  :     ↑       ↑</code></pre><blockquote><p>slice 是一个引用类型, 对切片的修改会对原数组造成同样的修改<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Println(s)<span class="comment">// [2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">updateSlice(s)</span><br><span class="line">fmt.Println(arr)<span class="comment">// [0 1 100 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(s)<span class="comment">// [100 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>slice 也可以继续生成 slice, 但不论如何生成, 都是针对同一个数组的 view</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Println(<span class="string">"arr[2:6]: "</span>, s)<span class="comment">// [2 3 4 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"ReSlice"</span>)</span><br><span class="line">fmt.Println(<span class="string">"s"</span>, s)<span class="comment">// [2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="string">"arr"</span>, arr)<span class="comment">// [0 1 2 3 4 5 6 7]</span></span><br><span class="line">s = s[:<span class="number">6</span>]</span><br><span class="line">fmt.Println(<span class="string">"s[:6]"</span>, s)<span class="comment">// [2 3 4 5 6 7]</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"s[2:]"</span>, s)<span class="comment">// [4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-Slice-的扩展"><a href="#3-2-1-Slice-的扩展" class="headerlink" title="3.2.1 Slice 的扩展"></a>3.2.1 Slice 的扩展</h3><ul><li>slice 可以向后扩展, 不能向前扩展</li><li>读取 slice 元素的时候, 不能超过 len(s), 向后扩展不能超过底层数组 cap(s)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Extending Slice"</span>)</span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)<span class="comment">// [100 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="string">"len of s1"</span>, <span class="built_in">len</span>(s1))<span class="comment">// 4</span></span><br><span class="line">fmt.Println(<span class="string">"cap of s1"</span>, <span class="built_in">cap</span>(s1))<span class="comment">// 6</span></span><br><span class="line">fmt.Println(s2)<span class="comment">// [5 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Slice 实现中, 有三个主要的元素:</p><ul><li>ptr: 当前指向的数组元素索引</li><li>len: 当前 slice 的总长度, 如 s1:= arr[2:6], len 为 4</li><li>cap: 当前 slice 的最大长度, 为原数组 len 之后的长度, 如 s1:= arr[2:6], cap 为 2</li></ul><pre><code>s2 := s1[3:5]                  0, 1, 2                               ↓  ↓s1 := arr[2:6]        0, 1, 2, 3, 4, 5                      ↓           ↓arr:            0, 1, 2, 3, 4, 5, 6, 7</code></pre><h3 id="3-2-2-向-slice-添加元素"><a href="#3-2-2-向-slice-添加元素" class="headerlink" title="3.2.2 向 slice 添加元素"></a>3.2.2 向 slice 添加元素</h3><ul><li>添加元素时如果超过 cap, 系统会重新分配更大的底层数组</li><li>由于值传递的关系, <code>append()</code> 操作的必须接收返回值</li><li>s = append(s, val)</li><li>slice 的 cap 初始值是0 , 当 slice 的底层数组需要扩容的时候, 底层数组的长度会扩充为之前的 2 倍</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s2)<span class="comment">// [5 6]</span></span><br><span class="line">fmt.Println(arr)<span class="comment">// [0 1 2 3 4 5 6 7]</span></span><br><span class="line">s3 := <span class="built_in">append</span>(s2, <span class="number">10</span>)</span><br><span class="line">s4 := <span class="built_in">append</span>(s3, <span class="number">11</span>)</span><br><span class="line">s5 := <span class="built_in">append</span>(s4, <span class="number">12</span>)</span><br><span class="line">fmt.Println(s3)<span class="comment">// [5 6 10]</span></span><br><span class="line">fmt.Println(s4)<span class="comment">// [5 6 10 11]</span></span><br><span class="line">fmt.Println(s5)<span class="comment">// [5 6 10 11 12]</span></span><br><span class="line">fmt.Println(arr)<span class="comment">// [0 1 2 3 4 5 6 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s2 是 arr 的一个 view, 对应 arr 的 [5, 6] 两个元素, s2 进行 <code>append()</code> 操作时, 由于 arr 数组后面还有空间, 则直接进行替换, 而 s3, s4 在进行 <code>append()</code> 操作的时候, 由于超出了 arr 数组的范围, go 会重新分配一个新的数组, 并将 arr 初始化进去再进行 <code>append()</code></p><h3 id="3-2-3-slice-复制"><a href="#3-2-3-slice-复制" class="headerlink" title="3.2.3 slice 复制"></a>3.2.3 slice 复制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br><span class="line">printSlice(s2)<span class="comment">// [2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0], len = 16, cap = 32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-slice-删除元素"><a href="#3-2-4-slice-删除元素" class="headerlink" title="3.2.4 slice 删除元素"></a>3.2.4 slice 删除元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printSlice(s2)<span class="comment">// [2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0], len = 16, cap = 32</span></span><br><span class="line">s2 = <span class="built_in">append</span>(s2[:<span class="number">3</span>], s2[<span class="number">4</span>:]...)</span><br><span class="line">printSlice(s2)<span class="comment">// [2 4 6 0 0 0 0 0 0 0 0 0 0 0 0], len = 15, cap = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-pop"><a href="#3-2-5-pop" class="headerlink" title="3.2.5 pop"></a>3.2.5 pop</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"popping from front"</span>)</span><br><span class="line">front := s2[<span class="number">0</span>]</span><br><span class="line">s2 = s2[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"popping from back"</span>)</span><br><span class="line">tail := s2[<span class="built_in">len</span>(s2)<span class="number">-1</span>]</span><br><span class="line">s2 = s2[:<span class="built_in">len</span>(s2)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(front, tail)<span class="comment">// 2 0</span></span><br><span class="line">printSlice(s2)<span class="comment">// [4 6 0 0 0 0 0 0 0 0 0 0 0], len = 13, cap = 31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Map"><a href="#3-3-Map" class="headerlink" title="3.3 Map"></a>3.3 Map</h2><p>定义方式:</p><ul><li><code>map[k]v</code>: key 为 k, value 为 v 的 map</li><li><code>map[k1]map[k2]v</code>: key 为 k1, value 为一个 key 为 k2 value 为 v 的 map</li></ul><p>map 中 key 的要求:</p><ol><li>map 底层使用哈希表实现, 必须可以比较相等</li><li>除了 slice, map, function 等内建类型都可以作为 key</li><li>struct 类型不包括上述字段, 也可以作为 key</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 的创建方式一</span></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"destiny"</span>,</span><br><span class="line">    <span class="string">"course"</span>: <span class="string">"golang"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 的创建方式二</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 的创建方式三</span></span><br><span class="line"><span class="keyword">var</span> m3 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h4 id="map-的遍历"><a href="#map-的遍历" class="headerlink" title="map 的遍历"></a>map 的遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"destiny"</span>,</span><br><span class="line"><span class="string">"course"</span>: <span class="string">"golang"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-获取-value"><a href="#map-获取-value" class="headerlink" title="map 获取 value"></a>map 获取 value</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"destiny"</span>,</span><br><span class="line"><span class="string">"course"</span>: <span class="string">"golang"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name := m[<span class="string">"name"</span>]</span><br><span class="line">fmt.Println(name)       <span class="comment">// destiny</span></span><br><span class="line"></span><br><span class="line">gender := m[<span class="string">"gender"</span>]</span><br><span class="line">fmt.Println(gender)     <span class="comment">// "" 不存在的内容返回 zero value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从 map 获取 value 的时候, 不存在的 key 会返回空串, 那么我们应该如何确定这个 key 是原本就不存在还是只是在 map 中确实放置了一个空串?<br>该接口还可以接受一个返回值, 用来判断这个 key 是否真的存在</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"destiny"</span>,</span><br><span class="line"><span class="string">"course"</span>: <span class="string">"golang"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name, ok := m[<span class="string">"name"</span>]</span><br><span class="line">fmt.Println(name, ok)           <span class="comment">// destiny true</span></span><br><span class="line"></span><br><span class="line">gender, ok := m[<span class="string">"gender"</span>]</span><br><span class="line">fmt.Println(gender, ok)         <span class="comment">//  false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成如下格式</span></span><br><span class="line"><span class="keyword">if</span> name, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">    fmt.Println(name, ok)       <span class="comment">// destiny true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key dosen't exist"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-删除元素"><a href="#map-删除元素" class="headerlink" title="map 删除元素"></a>map 删除元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"destiny"</span>,</span><br><span class="line"><span class="string">"course"</span>: <span class="string">"golang"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">fmt.Println(name, ok)       <span class="comment">// there</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"key doesn't exist"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"name"</span>)</span><br><span class="line"><span class="keyword">if</span> name, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">fmt.Println(name, ok)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"key doesn't exist"</span>)<span class="comment">// there</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用-map-寻找最长不含有重复字符的子串"><a href="#利用-map-寻找最长不含有重复字符的子串" class="headerlink" title="利用 map 寻找最长不含有重复字符的子串"></a>利用 map 寻找最长不含有重复字符的子串</h4><p>对于每一个字母 x</p><ul><li><code>lastOccurred[x]</code>不存在, 或者 <code>&lt;start</code>, 则不需要处理</li><li><code>lastOccurred[x] &gt;= start</code>, 更新 start</li><li>更新 <code>lastOccurred[x]</code>, 更新 <code>maxLength</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfNonRepeatingSubStr</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 记录每个字符最后出现的位置</span></span><br><span class="line">lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">start := <span class="number">0</span></span><br><span class="line">maxLength := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;</span><br><span class="line"><span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123;</span><br><span class="line"><span class="comment">// 如果当前字符最后一次出现的位置 &gt;= start, 需要将 start 更新到该字符位置之后</span></span><br><span class="line">start = lastOccurred[ch] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">maxLength = i - start + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">lastOccurred[ch] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(lengthOfNonRepeatingSubStr(<span class="string">"abcabcab"</span>))</span><br><span class="line">fmt.Println(lengthOfNonRepeatingSubStr(<span class="string">"bbbbb"</span>))</span><br><span class="line">fmt.Println(lengthOfNonRepeatingSubStr(<span class="string">"pwwkew"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-rune"><a href="#3-4-rune" class="headerlink" title="3.4 rune"></a>3.4 rune</h2><blockquote><p>rune 相当于 go 语言中的 char</p></blockquote><ul><li>使用 <code>range</code> 遍历 <code>pos, rune</code> 对</li><li>使用 <code>utf8.RuneCountInString</code> 获得字符数量</li><li>使用 <code>len</code> 获得字节长度</li><li>使用 <code>[]byte</code> 获得字节数组</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"我是Destiny!"</span><span class="comment">// UTF-8</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))<span class="comment">// 20</span></span><br><span class="line">fmt.Printf(<span class="string">"%X"</span>, []<span class="keyword">byte</span>(s))<span class="comment">// E68891E698AF44657374696E7921</span></span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="comment">// 每个中文三个字节</span></span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> []<span class="keyword">byte</span>(s) &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%X "</span>, b)<span class="comment">// E6 88 91 E6 98 AF 44 65 73 74 69 6E 79 21</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;<span class="comment">// ch is a rune</span></span><br><span class="line"><span class="comment">// (0: 6211)// E6 88 91 的 UTF-8 编码转换成 Unicode 后为 6211</span></span><br><span class="line"><span class="comment">// (3: 662F)</span></span><br><span class="line"><span class="comment">// (6: 44)</span></span><br><span class="line"><span class="comment">// (7: 65)</span></span><br><span class="line"><span class="comment">// (8: 73)</span></span><br><span class="line"><span class="comment">// (9: 74)</span></span><br><span class="line"><span class="comment">// (10: 69)</span></span><br><span class="line"><span class="comment">// (11: 6E)</span></span><br><span class="line"><span class="comment">// (12: 79)</span></span><br><span class="line"><span class="comment">// (13: 21)</span></span><br><span class="line">fmt.Printf(<span class="string">"(%d: %X)"</span>, i, ch)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s))<span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-安装与环境&quot;&gt;&lt;a href=&quot;#1-安装与环境&quot; class=&quot;headerlink&quot; title=&quot;1. 安装与环境&quot;&gt;&lt;/a&gt;1. 安装与环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;下载: &lt;a href=&quot;https://studygolang.com/dl&quot; t
      
    
    </summary>
    
      <category term="golang" scheme="https://destinywang.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://destinywang.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Redis(1) 常见应用</title>
    <link href="https://destinywang.github.io/blog/2018/11/01/Redis-1-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/"/>
    <id>https://destinywang.github.io/blog/2018/11/01/Redis-1-常见应用/</id>
    <published>2018-11-01T02:48:36.000Z</published>
    <updated>2018-11-01T06:15:19.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Redis-基础数据结构"><a href="#1-Redis-基础数据结构" class="headerlink" title="1. Redis 基础数据结构"></a>1. Redis 基础数据结构</h1><blockquote><p>此处所说的数据结构, 并不只是 Redis 对外提供可供用户使用的数据结构, 而是广义上泛指所有支撑 Redis 运行的所有数据结构.</p></blockquote><p>Redis 有 5 种数据结构:</p><ul><li>string(字符串)</li><li>list(列表)</li><li>set(集合)</li><li>hash(哈希表)</li><li>zset(有序集合)</li></ul><h2 id="1-1-string"><a href="#1-1-string" class="headerlink" title="1.1 string"></a>1.1 string</h2><p>Redis 中所有数据结构都是以一个唯一的字符串 <code>key</code> 作为名称.</p><p>然后通过 <code>key</code> 去获取对应的 value 数据, 不同类型的数据结构, 其 key 都是 string 类型, 而 value 所对应的结构以及内容不同.</p><p>string 在做 value 时, 经常会用来做缓存, 例如可以将内容序列化为 JSON, 再使用 Redis 来存储, 而从应用从缓存中读取数据时, 也需要经过一次反序列化.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Redis-基础数据结构&quot;&gt;&lt;a href=&quot;#1-Redis-基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. Redis 基础数据结构&quot;&gt;&lt;/a&gt;1. Redis 基础数据结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;此处所说的数据
      
    
    </summary>
    
      <category term="Redis" scheme="https://destinywang.github.io/blog/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://destinywang.github.io/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java逃逸分析</title>
    <link href="https://destinywang.github.io/blog/2018/09/07/Java%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>https://destinywang.github.io/blog/2018/09/07/Java逃逸分析/</id>
    <published>2018-09-07T14:45:00.000Z</published>
    <updated>2018-09-07T14:45:38.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-逃逸概念的引入"><a href="#1-逃逸概念的引入" class="headerlink" title="1. 逃逸概念的引入"></a>1. 逃逸概念的引入</h1><blockquote><p>我们都知道, Java 创建的对象都是被分配到堆内存上, 但是事实并不是这么绝对, 通过对Java对象分配的过程分析, 可以知道有两个地方会导致 Java 中创建出来的对象并不一定分别在所认为的堆上. 这两个点分别是 Java 中的 <code>逃逸分析</code> 和 <code>TLAB(Thread Local Allocation Buffer)</code>线程私有的缓存区。</p></blockquote><h1 id="2-逃逸分析基本概念"><a href="#2-逃逸分析基本概念" class="headerlink" title="2. 逃逸分析基本概念"></a>2. 逃逸分析基本概念</h1><p>逃逸分析, 是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法. 通过逃逸分析, <code>Hotspot编译器</code> 能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上.</p><p>在计算机语言编译器优化原理中, 逃逸分析是指分析指针动态范围的方法, 它同编译器优化原理的指针分析和外形分析相关联. 当变量(或者对象)在方法中分配后, 其指针有可能被返回或者被全局引用, 这样就会被其他过程或者线程所引用, 这种现象称作指针(或者引用)的 <code>逃逸(Escape)</code> . 通俗点讲, 如果一个对象的指针被多个方法或者线程引用时, 那么我们就称这个对象的指针发生了逃逸.</p><h2 id="2-1-具体分析"><a href="#2-1-具体分析" class="headerlink" title="2.1. 具体分析"></a>2.1. 具体分析</h2><p>逃逸分析研究对于 java 编译器有什么好处呢? 我们知道 java 对象总是在堆中被分配的, 因此 java 对象的创建和回收对系统的开销是很大的. java 语言被批评的一个地方, 也是认为 java 性能慢的一个原因就是  java 不支持栈上分配对象, JDK6里的 <code>Swing</code> 内存和性能消耗的瓶颈就是由于 GC 来遍历引用树并回收内存的, 如果对象的数目比较多, 将给 GC 带来较大的压力, 也间接得影响了性能. 减少临时对象在堆内分配的数量, 无疑是最有效的优化方法. java 中应用里普遍存在一种场景, 一般是在方法体内, 声明了一个局部变量, 并且该变量在方法执行生命周期内未发生逃逸, 按照  JVM 内存分配机制, 首先会在堆内存上创建类的实例(对象), 然后将此对象的引用压入调用栈, 继续执行, 这是 JVM 优化前的方式. 当然, 我们可以采用逃逸分析对 JVM  进行优化, 即针对栈的重新分配方式, 首先我们需要分析并且找到未逃逸的变量, 将该变量类的实例化内存直接在栈里分配, 无需进入堆, 分配完成之后, 继续调用栈内执行, 最后线程执行结束, 栈空间被回收, 局部变量对象也被回收, 通过这种方式的优化, 与优化前的方案主要区别在于对象的存储介质, 优化前是在堆中, 而优化后的是在栈中, 从而减少了堆中临时对象的分配(较耗时), 最终完成性能的优化.</p><blockquote><p>逃逸分析实际上是 JVM 的一种为优化提供支持的分析手段, 逃逸分析的范围分为两个, 方法逃逸和线程逃逸</p></blockquote><h3 id="2-2-1-方法逃逸"><a href="#2-2-1-方法逃逸" class="headerlink" title="2.2.1 方法逃逸"></a>2.2.1 方法逃逸</h3><blockquote><p>不逃逸出当前方法, 就是说在一个方法内 <code>new</code> 出来的对象, 它的引用没有泄露到这个方法之外<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    foo.a = a;</span><br><span class="line">    foo.b = b;</span><br><span class="line">    <span class="comment">// foo 对象没有逃逸出 bar 方法, 只在 bar 方法里当做局部变量存在</span></span><br><span class="line">    <span class="keyword">return</span> foo.a + foo.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在上面的例子中, Foo 对象就没有逃逸出 bar 方法, 只有一个局部 foo 变量引用这个对象, foo 变量既没有被当做返回值, 也没有当做另一个方法的参数.</p><p>但其实我们一般写的普通 Java Bean 都会有 getter /setter </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 <code>bar()</code> 方法里依然给 Foo 实例对象赋值, 那肯定就会调用到 Foo 的成员方法 <code>setA(), setB()</code>, 把局部变量 foo 的 this 作为参数传递给 foo 的成员方法, 这个时候变量 foo 确实逃逸除了 bar 方法, 而 JIT 提供了 <code>方法内联</code>, 在完成方法内联后, 这个参数传递实际上优化掉了.</p><h3 id="2-2-2-线程逃逸"><a href="#2-2-2-线程逃逸" class="headerlink" title="2.2.2 线程逃逸"></a>2.2.2 线程逃逸</h3><blockquote><p>不逃逸出当前线程, 指的是实例对象没有被别的类引用到. 该对象的引用赋值到其他对象的字段, 或其他类的静态字段上, 没办法让它进入一个全局可见的范围, 这个时候我们认为该实例没有逃逸出当前线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    foo.a = a;</span><br><span class="line">    foo.b = b;</span><br><span class="line">    <span class="keyword">return</span> doBar(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doBar</span><span class="params">(Foo foo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.a + foo.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bar()</code> 方法调用了 <code>doBar()</code>, 把 foo 实例作为入参传入了 <code>doBar()</code>, 这个时候认为 foo 逃逸除了 bar 方法, 但是 bar 和 doBar 都在一个类中, 并没有被其他类引用, 我们认为 foo 对象没有逃逸出线程.</p><h2 id="2-3-JVM-为逃逸分析所做的优化"><a href="#2-3-JVM-为逃逸分析所做的优化" class="headerlink" title="2.3. JVM 为逃逸分析所做的优化"></a>2.3. JVM 为逃逸分析所做的优化</h2><h3 id="2-3-1-标量替换"><a href="#2-3-1-标量替换" class="headerlink" title="2.3.1 标量替换"></a>2.3.1 标量替换</h3><blockquote><p>Java 中标量的意思是不能再分割的量, 如基本类型和 Reference 类型, 反之成为聚合量, 如果把一个对象拆开, 将它的成员变量分割成标量, 这个就叫标量替换.</p></blockquote><p>如果逃逸分析发现一个对象不会被外部访问, 并且该对象可以被拆散, 那么经过优化后, 并不直接生成该对象, 而是在栈上创建若干个成员变量, 原本的对象就无需再堆上整体分配空间了.</p><pre><code>栈帧内分配对象的行为成为栈上分配, 目的是减少新生代的 GC 频率, 见解提高 JVM 性能, 通过 -XX+EliminateAllcations 可以开启标量替换.</code></pre><h3 id="2-3-2-锁消除优化"><a href="#2-3-2-锁消除优化" class="headerlink" title="2.3.2 锁消除优化"></a>2.3.2 锁消除优化</h3><blockquote><p>Java 方法中返回值如果没有被其他类用到, 那这个对象就不会逃逸出线程, 我们知道变量的读写竞争的时候需要加锁访问, 如果确定该变量不会逃逸出该线程, 那同步访问控制就可以优化掉.</p></blockquote><h2 id="2-4-实操"><a href="#2-4-实操" class="headerlink" title="2.4 实操"></a>2.4 实操</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sting name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getters / setters / constructors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(Foo foo)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">return</span> foo.getA() + foo.getB() + user.getAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; ++i) &#123;</span><br><span class="line">        foo.setA(<span class="number">4</span>);</span><br><span class="line">        foo.setB(<span class="number">45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-关闭逃逸分析"><a href="#2-4-1-关闭逃逸分析" class="headerlink" title="2.4.1 关闭逃逸分析"></a>2.4.1 关闭逃逸分析</h3><p>启动 JVM 参数</p><pre><code>-server-XX:-DoEscapeAnalysis</code></pre><p>使用 <code>jmap -histo</code><br><img src="http://oetw0yrii.bkt.clouddn.com/18-8-30/3446787.jpg" alt=""></p><h3 id="2-4-2-打开逃逸分析"><a href="#2-4-2-打开逃逸分析" class="headerlink" title="2.4.2 打开逃逸分析"></a>2.4.2 打开逃逸分析</h3><p>JVM 参数</p><pre><code>-server-XX:+DoEscapeAnalysis</code></pre><p><img src="http://oetw0yrii.bkt.clouddn.com/18-8-30/67522193.jpg" alt=""></p><p>可以看到, 只有少量的对象在堆上实例化, 大部分对象的属性被标量替换了.</p><h1 id="3-JIT-编译"><a href="#3-JIT-编译" class="headerlink" title="3. JIT 编译"></a>3. JIT 编译</h1><p>在 JVM 中触发 JIT 编译是基于两个计数器:</p><ol><li>一个方法被调用的次数</li><li>存在有分支的方法中的循环次数, 如果方法里面有一个很长的循环, 这时候需要编译到这个循环, 每一次分支的循环被调用, 该分支的计数器都会增加</li></ol><p>增加 <code>-XX:+PrintCompileation</code> 参数观察 JVM 输出的编译日志</p><pre><code>- 96    1       3       java.lang.String::equals (81 bytes) 96    4       3       java.io.UnixFileSystem::normalize (75 bytes) 97    9       3       java.lang.String::hashCode (55 bytes) 97    8       3       java.lang.Object::&lt;init&gt; (1 bytes) 97    7       3       java.lang.AbstractStringBuilder::ensureCapacityInternal (16 bytes) 98    3       3       java.lang.String::length (6 bytes) 98   10       3       java.lang.Math::min (11 bytes) 98    2       3       java.lang.System::getSecurityManager (4 bytes) 98    6       3       java.util.Arrays::copyOf (19 bytes) 98   11     n 0       java.lang.System::arraycopy (native)   (static) 98   12       3       java.lang.String::indexOf (70 bytes) 98   15       3       sun.nio.cs.UTF_8$Encoder::encode (359 bytes) 99   13       4       java.lang.String::charAt (29 bytes) 99   16       3       java.lang.String::lastIndexOf (52 bytes) 99    5       3       java.util.HashMap::hash (20 bytes)100   18       3       java.lang.String::&lt;init&gt; (82 bytes)100   14       3       java.lang.StringBuilder::toString (17 bytes)100   19       3       java.lang.String::startsWith (72 bytes)100   20       1       java.util.ArrayList::size (5 bytes)100   17       1       java.lang.ref.Reference::get (5 bytes)101   21       1       sun.instrument.TransformerManager::getSnapshotTransformerList (5 bytes)101   22       3       java.lang.String::startsWith (7 bytes)101   23       3       java.lang.String::indexOf (166 bytes)102   26       1       java.lang.Object::&lt;init&gt; (1 bytes)102    8       3       java.lang.Object::&lt;init&gt; (1 bytes)   made not entrant102   30       3       org.destiny.demo.Foo::setA (6 bytes)102   31       3       org.destiny.demo.Foo::setB (6 bytes)102   32       3       org.destiny.demo.User::bar (25 bytes)102   33       3       org.destiny.demo.User::&lt;init&gt; (10 bytes)103   34       1       org.destiny.demo.Foo::setA (6 bytes)103   30       3       org.destiny.demo.Foo::setA (6 bytes)   made not entrant103   35       1       org.destiny.demo.Foo::setB (6 bytes)103   31       3       org.destiny.demo.Foo::setB (6 bytes)   made not entrant103   27       1       org.destiny.demo.Foo::getA (5 bytes)103   28       1       org.destiny.demo.Foo::getB (5 bytes)103   29       1       org.destiny.demo.User::getAge (5 bytes)103   24       3       java.lang.String::endsWith (17 bytes)103   36       4       org.destiny.demo.User::bar (25 bytes)103   25       3       java.lang.ref.SoftReference::get (29 bytes)104   32       3       org.destiny.demo.User::bar (25 bytes)   made not entrant104   37       1       java.lang.ThreadLocal::access$400 (5 bytes)106   38       3       java.lang.String::indexOf (7 bytes)106   39       3       java.lang.Character::toLowerCase (9 bytes)106   40       3       java.lang.CharacterDataLatin1::toLowerCase (39 bytes)108   41 %     3       org.destiny.demo.User::main @ 18 (48 bytes)108   42       3       org.destiny.demo.User::main (48 bytes)109   43 %     4       org.destiny.demo.User::main @ 18 (48 bytes)112   41 %     3       org.destiny.demo.User::main @ -2 (48 bytes)   made not entrant150   43 %     4       org.destiny.demo.User::main @ -2 (48 bytes)   made not entrant </code></pre><p>编译日志分为 7 列, 依次是</p><ul><li>时间(基于 JVM 启动的时间戳)</li><li>编译任务 id(基本递增)</li><li>编译属性</li><li>tiered_level(分为 4 级)</li><li>方法信息</li><li>占用字节数</li><li>deopt</li></ul><p>其中, 编译属性 <code>attribute</code> 分为:</p><table><thead><tr><th>属性值</th><th>属性描述</th></tr></thead><tbody><tr><td>%</td><td>The compilation is OSR</td></tr><tr><td>s</td><td>The method is synchronized</td></tr><tr><td>!</td><td>The method has an exception handler</td></tr><tr><td>b</td><td>Compliation occurred in blocking mode</td></tr><tr><td>n</td><td>Compliation occurred for a wrapper to a native method</td></tr></tbody></table><p>tiered_level:</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>Interpreted Code</td></tr><tr><td>1</td><td>Simple C1 Compiled Code</td></tr><tr><td>2</td><td>Limited C1 Compiled Code</td></tr><tr><td>3</td><td>Full C1 Compiled Code</td></tr><tr><td>4</td><td>C2 Compile Code</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-逃逸概念的引入&quot;&gt;&lt;a href=&quot;#1-逃逸概念的引入&quot; class=&quot;headerlink&quot; title=&quot;1. 逃逸概念的引入&quot;&gt;&lt;/a&gt;1. 逃逸概念的引入&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我们都知道, Java 创建的对象都是被分配到堆内存上
      
    
    </summary>
    
      <category term="JVM" scheme="https://destinywang.github.io/blog/categories/JVM/"/>
    
      <category term="逃逸分析" scheme="https://destinywang.github.io/blog/categories/JVM/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="逃逸分析" scheme="https://destinywang.github.io/blog/tags/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务总结</title>
    <link href="https://destinywang.github.io/blog/2018/09/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93/"/>
    <id>https://destinywang.github.io/blog/2018/09/02/分布式事务总结/</id>
    <published>2018-09-02T02:21:57.000Z</published>
    <updated>2018-09-02T02:31:04.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><pre><code>事务能够提供一种将一个活动涉及到的所有操作纳入到一个不可分割的执行单元的机制.组成事务的操作只有在操作均能正常执行的情况下才能提交, 只要其中任意一步执行失败, 都将导致整个操作回滚.</code></pre><h1 id="2-数据库本地事务"><a href="#2-数据库本地事务" class="headerlink" title="2. 数据库本地事务"></a>2. 数据库本地事务</h1><h2 id="2-1-ACID"><a href="#2-1-ACID" class="headerlink" title="2.1 ACID"></a>2.1 ACID</h2><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>原子性</td><td>一个事务的所有操作, 要么全部完成, 要么全部不完成, 不会结束在中间某个环节</td></tr><tr><td>一致性</td><td>在一个事务执行之前和执行之后, 数据库必须保持处于一致的状态. 如果事务成功执行, 系统中所有的变化都将正确地被应用, 反之, 所有变化都将被回滚</td></tr><tr><td>隔离性</td><td>当不同的事务操作相同的数据的时候, 每个事务都有各自的完整数据空间, 由事务所做的修改必须与任何其他事务所做的修改隔离, 事务不会看到数据的中间状态.</td></tr><tr><td>持久性</td><td>只要事务成功结束, 它对数据库所做的更新就必须永久保存下来</td></tr></tbody></table><p><img src="http://oetw0yrii.bkt.clouddn.com/18-8-4/3451917.jpg" alt=""></p><p>而事务的 ACID 是通过 InnoDB 日志和锁来保证.</p><ul><li>事务的隔离性是通过数据库锁的机制来实现;</li><li>持久性是通过 redo log(重做日志) 来实现的</li><li>原子性和一致性是通过 undo log(回滚日志)</li></ul><pre><code>Undo log: 为了满足事务的原子性, 在操作任何数据之前, 首先将数据备份到一个地方, 然后对数据进行修改, 如果出现了错误, 或者用户执行 RollBack, 系统可以利用 Undo log 中的备份将数据恢复到事务开始之前的状态Redo log: 记录新数据的备份, 在事务提交之前, 只要将 Redo log 持久化即可, 当系统崩溃时, 虽然数据没有持久化, 但是 Redo log 已经持久化, 系统可以根据 Redo log 的内容, 将所有数据恢复到最新状态.</code></pre><h1 id="3-分布式事务"><a href="#3-分布式事务" class="headerlink" title="3. 分布式事务"></a>3. 分布式事务</h1><h2 id="3-1-分布式事务概念"><a href="#3-1-分布式事务概念" class="headerlink" title="3.1 分布式事务概念"></a>3.1 分布式事务概念</h2><pre><code>指事物的参与者, 支持事务的服务器, 资源服务器以及事务管理器分别位于不同的分布式系统之上.本质上讲, 分布式事务就是为了保证不同数据库的数据一致性.</code></pre><h2 id="3-2-场景"><a href="#3-2-场景" class="headerlink" title="3.2 场景"></a>3.2 场景</h2><h3 id="3-2-1-service-多个节点"><a href="#3-2-1-service-多个节点" class="headerlink" title="3.2.1 service 多个节点"></a>3.2.1 service 多个节点</h3><blockquote><p>随着互联网快速发展, SOA, 微服务等架构模式正在被大规模使用, 一个公司内, 用户的资产可能被分为好多个部分, 比如余额, 积分, 优惠券等</p></blockquote><p><img src="http://oetw0yrii.bkt.clouddn.com/18-8-4/44346101.jpg" alt=""></p><p>这样的话传统的单机事务实现方式无法保证积分扣减成功之后, 优惠券也能正确完成扣减操作.</p><h3 id="3-2-2-resource-多个节点"><a href="#3-2-2-resource-多个节点" class="headerlink" title="3.2.2 resource 多个节点"></a>3.2.2 resource 多个节点</h3><blockquote><p>同样, 由于单表数据过大需要进行拆分, 一次转账业务需要在北京的 MySQL 实例向 上海的 MySQL 实例转账, 同样无法保证他们能同时成功.</p></blockquote><p><img src="http://oetw0yrii.bkt.clouddn.com/18-8-4/47229853.jpg" alt=""></p><h2 id="3-3-分布式事务基础"><a href="#3-3-分布式事务基础" class="headerlink" title="3.3 分布式事务基础"></a>3.3 分布式事务基础</h2><h3 id="3-3-1-CAP"><a href="#3-3-1-CAP" class="headerlink" title="3.3.1 CAP"></a>3.3.1 CAP</h3><ul><li>C: 对某个执行的客户端来说, 读操作能返回最新的写操作. 对于数据分布在不同节点上的数据来说, 如果在某个节点更新了数据, 那么在其他节点都能读取到最新的数据, 那么就成为强一致, 反之就是分布式不一致;</li><li>A: 非故障的节点在一定时间内返回合理的响应(不是错误或超时), 可用性的关键在于: <code>合理的时间</code> 和 <code>合理的响应</code>, 请求不能无限期得不到响应, 并且需要得到系统正确的返回结果;</li><li>P: 当出现网络分区后, 系统依然能够正常工作.</li></ul><p>在分布式系统中, 网络永远无法 100% 可靠, 分区是一个一定会出现的情况, 如果我们选择 AC 而放弃 P, 当分区发生时, 为了保证一致性, 这个时候必须拒绝请求, 当时 A 又不允许拒绝, 所以分布式系统理论上不可能选择 CA 架构, 只能选择 CP 或者 AP 架构.</p><p>对于 CP 来说, 放弃可用性, 追求一致性和分区容错性, 比如 Zookeeper 就是追求强一致.</p><p>对于 AP 来说, 放弃一致性(强一致), 追求分区容错和可用, 这是很多分布式系统的选择.</p><p>CAP 是忽略网络延迟的, 也就是当事务提交时, 从节点 A 复制到节点 B, 但是在现实中总会有一定的时间延迟.</p><h3 id="3-3-2-BASE"><a href="#3-3-2-BASE" class="headerlink" title="3.3.2 BASE"></a>3.3.2 BASE</h3><pre><code>基本可用, 软状态, 最终一致性的缩写本质上是 AP 的一个扩张, 通过软状态实现基本可用和最终一致性.</code></pre><ul><li>BA: 基本可用, 分布式系统出现故障时, 允许损失部分可用功能, 保证核心功能可用;</li><li>软状态: 允许系统中存在中间状态, 这个状态不影响系统可用性, 这里指的是 CAP 中的不一致;</li><li>最终一致性: 经过一段时间后, 所有节点数据都将达到一致.</li></ul><h1 id="4-分布式事务的解决方案"><a href="#4-分布式事务的解决方案" class="headerlink" title="4. 分布式事务的解决方案"></a>4. 分布式事务的解决方案</h1><h2 id="4-1-是否真的需要分布式事务"><a href="#4-1-是否真的需要分布式事务" class="headerlink" title="4.1 是否真的需要分布式事务"></a>4.1 是否真的需要分布式事务</h2><pre><code>首先要明确是否真的需要分布式事务?</code></pre><p>是否存在由于服务拆分过细导致不合理的分布式系统设计?</p><p>可以先考虑将多个微服务聚合成一个单机服务, 避免引入不必要的成本和复杂度.</p><h2 id="4-2-2PC"><a href="#4-2-2PC" class="headerlink" title="4.2 2PC"></a>4.2 2PC</h2><p><img src="http://images2015.cnblogs.com/blog/524341/201607/524341-20160718200514638-1914892480.png" alt="image"></p><p>第一阶段: 事务管理器要求每个涉及到事务的数据库预提交此操作, 并反映是否可以提交</p><p>第二节点: 事务协调器要求每个数据库提交数据, 或者回滚</p><p>优点: 保证数据强一致, 实现简单;</p><p>缺点: 事务管理器存在单机风险; 整个过程存在同步阻塞; 数据可能不一致; 不支持高并发.</p><h2 id="4-3-TCC"><a href="#4-3-TCC" class="headerlink" title="4.3 TCC"></a>4.3 TCC</h2><p>相比 2PC, 解决了以下问题</p><ol><li>解决了协调者单点, 引入集群</li><li>引入超时, 超时后进行补偿, 并且不会锁定整个资源, 将资源转换为业务逻辑形式</li><li>数据一致性, 有了补偿机制后, 由业务管理其控制一致性</li></ol><pre><code>Try 阶段: 尝试执行, 完成所有业务检查(一致性), 预留必须业务资源(准隔离性)Confirm 阶段: 确认执行真正的业务, 不做任何业务检查, 只使用 Try 阶段预留的业务资源, Confirm 操作满足幂等性. 要求具备幂等设计, Confirm 失败后需要进行重试.Cancel 阶段: 取消执行, 释放 Try 阶段预留的业务资源, 也需要满足幂等性.</code></pre><p><img src="http://oetw0yrii.bkt.clouddn.com/18-8-4/81578002.jpg" alt=""></p><h2 id="4-4-本地消息表"><a href="#4-4-本地消息表" class="headerlink" title="4.4 本地消息表"></a>4.4 本地消息表</h2><pre><code>将需要分布式处理的任务通过消息日至的方式来异步执行</code></pre><p>消息日志可以存储到本地文本, 数据库或者消息队列, 再通过业务规则或人工发起重试, 人工重试更多应用于支付系统</p><blockquote><p>举一个购物的例子</p></blockquote><ol><li>当账户扣款的时候, 需要在扣款相关的服务上新增一个本地消息表, 需要把记录扣款和写入扣减商品库存的本地消息表放入同一个事务.</li><li>有个定时任务去轮询本地事务表, 把没有发送的消息扔给商品服务, 让它扣减库存, 到达商品服务后, 先写入这个服务器的事务表, 再进行扣减, 扣减成功后, 更新事务表中的状态;</li><li>商品服务器通过定时任务扫描消息表或者直接通过扣款服务吗扣款服务本地消息表进行更新;</li><li>针对特定情况, 定时扫描未成功处理的消息, 进行重新发送, 在商品服务收到消息后, 先判断是否是重复消息, 如果已经接受, 再判断是否执行, 如果执行再马上又进行通知事务, 如果未执行, 就需要重新执行需要由业务保证幂等.</li></ol><p><img src="http://oetw0yrii.bkt.clouddn.com/18-8-4/62419454.jpg" alt=""></p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><h2 id="4-5-MQ-事务"><a href="#4-5-MQ-事务" class="headerlink" title="4.5 MQ 事务"></a>4.5 MQ 事务</h2><p>还是以转账的模型举例:<br><img src="https://upload-images.jianshu.io/upload_images/175724-92abb226f288ff9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/621" alt="image"></p><h4 id="1-先发送消息"><a href="#1-先发送消息" class="headerlink" title="1. 先发送消息"></a>1. 先发送消息</h4><p><img src="https://upload-images.jianshu.io/upload_images/175724-1927b8f3d14ef823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/618" alt="image"></p><p>如果消息发送成功，但是扣款失败，消费端就会消费此消息，进而向Smith账户加钱。</p><h4 id="2-先扣款"><a href="#2-先扣款" class="headerlink" title="2. 先扣款"></a>2. 先扣款</h4><p><img src="https://upload-images.jianshu.io/upload_images/175724-367b5cf60cbdfa16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/619" alt="image"></p><p>如果扣款成功，发送消息失败，就会出现Bob扣钱了，但是Smith账户未加钱。</p><h4 id="3-RocketMQ-的实现"><a href="#3-RocketMQ-的实现" class="headerlink" title="3. RocketMQ 的实现"></a>3. RocketMQ 的实现</h4><p><img src="https://upload-images.jianshu.io/upload_images/175724-ab0085543c6d02d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/621" alt="image"></p><ol><li>发送 <code>Prepared</code> 消息时，会拿到消息的地址;</li><li>执行本地事物;</li><li>通过第一阶段拿到的地址去访问消息, 并修改消息的状态.</li></ol><p>这样可以保证消息发送消息和本地事务执行成功保持原子性操作.</p><h4 id="问题1-如果步骤-3-失败怎么办"><a href="#问题1-如果步骤-3-失败怎么办" class="headerlink" title="问题1: 如果步骤 3 失败怎么办"></a>问题1: 如果步骤 3 失败怎么办</h4><pre><code>RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============================发送事务消息的一系列准备工作========================================</span></span><br><span class="line"><span class="comment">// 未决事务，MQ服务器回查客户端</span></span><br><span class="line"><span class="comment">// 也就是上文所说的，当RocketMQ发现`Prepared消息`时，会根据这个Listener实现的策略来决断事务</span></span><br><span class="line">TransactionCheckListener transactionCheckListener = <span class="keyword">new</span> TransactionCheckListenerImpl();</span><br><span class="line"><span class="comment">// 构造事务消息的生产者</span></span><br><span class="line">TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"groupName"</span>);</span><br><span class="line"><span class="comment">// 设置事务决断处理类</span></span><br><span class="line">producer.setTransactionCheckListener(transactionCheckListener);</span><br><span class="line"><span class="comment">// 本地事务的处理逻辑，相当于示例中检查Bob账户并扣钱的逻辑</span></span><br><span class="line">TransactionExecuterImpl tranExecuter = <span class="keyword">new</span> TransactionExecuterImpl();</span><br><span class="line">producer.start()</span><br><span class="line"><span class="comment">// 构造MSG，省略构造参数</span></span><br><span class="line">Message msg = <span class="keyword">new</span> Message(......);</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">SendResult sendResult = producer.sendMessageInTransaction(msg, tranExecuter, <span class="keyword">null</span>);</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure><p>接着查看 <code>sendMessageInTransaction</code> 方法的源码，总共分为3个阶段：发送 Prepared 消息、执行本地事务、发送确认消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ================================事务消息的发送过程=============================================</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(.....)</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑代码，非实际代码</span></span><br><span class="line">    <span class="comment">// 1.发送消息</span></span><br><span class="line">    sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">    <span class="comment">// sendResult.getSendStatus() == SEND_OK</span></span><br><span class="line">    <span class="comment">// 2.如果消息发送成功，处理与消息关联的本地事务单元</span></span><br><span class="line">    LocalTransactionState localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">    <span class="comment">// 3.结束事务</span></span><br><span class="line">    <span class="keyword">this</span>.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>endTransaction</code> 方法会将请求发往 <code>broker(mq server)</code> 去更新事务消息的最终状态：</p><ol><li>根据 sendResult 找到 Prepared 消息, sendResult 包含事务消息的 ID</li><li>根据 localTransaction 更新消息的最终状态</li></ol><h4 id="问题2-Consumer-消费失败怎么办"><a href="#问题2-Consumer-消费失败怎么办" class="headerlink" title="问题2: Consumer 消费失败怎么办"></a>问题2: Consumer 消费失败怎么办</h4><pre><code>如果 Bob 的账户的余额已经减少，且消息已经发送成功，Smith 端开始消费这条消息，这个时候就会出现消费失败和消费超时两个问题.解决超时问题的思路就是一直重试，直到消费端消费消息成功，整个过程中有可能会出现消息重复的问题，按照前面的思路解决即可。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/175724-1d9ba7bcd230e0dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/624" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;事务能够提供一种将一个活动涉及到的所有操作纳入到一个不可分割的执行单元的机制.
组成事务的操作只有在操作
      
    
    </summary>
    
      <category term="分布式事务" scheme="https://destinywang.github.io/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="https://destinywang.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>实现简易JVM</title>
    <link href="https://destinywang.github.io/blog/2018/06/24/%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93JVM/"/>
    <id>https://destinywang.github.io/blog/2018/06/24/实现简易JVM/</id>
    <published>2018-06-24T15:07:51.000Z</published>
    <updated>2018-07-01T15:04:36.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-23/68954491.jpg" alt=""></p><ol><li>Java 源代码经过编译生成 class 文件</li><li>在不同的操作系统上分别实现 JVM, JVM 在不同操作系统上实现差异很大, 如线程, 图形界面等, 由 JVM 屏蔽与操作系统的接口</li></ol><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-23/18183015.jpg" alt=""></p><h2 id="1-1-Class-文件格式"><a href="#1-1-Class-文件格式" class="headerlink" title="1.1 Class 文件格式"></a>1.1 Class 文件格式</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-23/7574723.jpg" alt=""></p><h3 id="1-1-1-魔数-amp-版本-amp-常量池个数"><a href="#1-1-1-魔数-amp-版本-amp-常量池个数" class="headerlink" title="1.1.1 魔数 &amp; 版本 &amp; 常量池个数"></a>1.1.1 魔数 &amp; 版本 &amp; 常量池个数</h3><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-23/37222872.jpg" alt=""></p><ul><li>Magic Number <ul><li>确定这是一个 Java 文件</li></ul></li><li>Minor / Major Version: 版本号</li><li>16 进制<ul><li>Major Version (0x34) = 52</li><li>常量池个数 (0x36) = 54</li></ul></li><li>大端模式(Big-Endian): 高位在前<ul><li><code>00 36</code> 而不是 <code>36 00</code></li></ul></li></ul><h3 id="1-1-2-常量池"><a href="#1-1-2-常量池" class="headerlink" title="1.1.2 常量池"></a>1.1.2 常量池</h3><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-23/57215332.jpg" alt=""></p><p><code>0036</code> 代表常量池常量的个数, 后面的 <code>07</code> 通过查表发现含义为 <code>ClassInfo</code> 的 <code>tag</code> 值, 而 <code>name_index</code> 值为 2, 代表类名在第二个常量中.</p><p>第二个常量开头为 <code>01</code>, 查表得知是一个 <code>Utf8</code> 字符串, <code>0021</code> 代表长度 <code>length</code> 值为 33. 而后面 33 个字节 <code>63 6F 6D 2F 63 6F 64 65 72 69 73 69 6E 67 2F 65 78 61 6D 70 6C 65 2F 45 6D 70 6C 6F 79 65 65 56 31</code> 转换成字符串之后的值为 <code>com/coderising/example/EmployeeV1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;         // 值为7</span><br><span class="line">    u2 name_index;  // 名称索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;             // 值为1</span><br><span class="line">    u2 length;          // 长度</span><br><span class="line">    u1 bytes[length];   // 内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-1-常量池实例"><a href="#1-1-2-1-常量池实例" class="headerlink" title="1.1.2.1 常量池实例"></a>1.1.2.1 常量池实例</h4><table><thead><tr><th style="text-align:center">索引</th><th style="text-align:center">类型</th><th style="text-align:center">操作数 1</th><th style="text-align:center">操作数 2</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">#1</td><td style="text-align:center">ClassInfo</td><td style="text-align:center">#2</td></tr><tr><td style="text-align:center">#2</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">org/destiny/jvm/model/Employee</td></tr><tr><td style="text-align:center">#3</td><td style="text-align:center">ClassInfo</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">#4</td></tr><tr><td style="text-align:center">#4</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">java/lang/Object</td></tr><tr><td style="text-align:center">#5</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">name</td></tr><tr><td style="text-align:center">#6</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">Ljava/lang/String</td></tr><tr><td style="text-align:center">#7</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">age</td></tr><tr><td style="text-align:center">#8</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">#9</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><init></init></td></tr><tr><td style="text-align:center">#10</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">#11</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">#12</td><td style="text-align:center">MethodRef</td><td style="text-align:center">#3</td><td style="text-align:center">#13</td><td style="text-align:center"><code>java.lang.Object&lt;init&gt;()V</code></td></tr><tr><td style="text-align:center">#13</td><td style="text-align:center">NameAndType</td><td style="text-align:center">#9</td><td style="text-align:center">#14</td><td style="text-align:center"><code>&lt;init&gt;()V</code></td></tr><tr><td style="text-align:center">#14</td><td style="text-align:center">Utf8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">()V</td></tr><tr><td style="text-align:center">#15</td><td style="text-align:center">FieldRef</td><td style="text-align:center">#1</td><td style="text-align:center">#16</td><td style="text-align:center"><code>org/destiny/jvm/model/Employee 包含一个 Ljava/lang/String 类型的变量 name</code></td></tr><tr><td style="text-align:center">#16</td><td style="text-align:center">NameAndType</td><td style="text-align:center">#5</td><td style="text-align:center">#6</td><td style="text-align:center"><code>Ljava/lang/String 类型的变量 name</code></td></tr></tbody></table><h3 id="1-1-3-访问标志"><a href="#1-1-3-访问标志" class="headerlink" title="1.1.3 访问标志"></a>1.1.3 访问标志</h3><table><thead><tr><th style="text-align:center">标志名称</th><th style="text-align:center">标志值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:center">0x0001</td><td style="text-align:center">public 类型</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:center">0x0002</td><td style="text-align:center">声明为 final 类型</td></tr><tr><td style="text-align:center">ACC_SUPER</td><td style="text-align:center">0x0020</td><td style="text-align:center">是否允许使用 <code>invokespecial</code> 字节码指令的新语义</td></tr><tr><td style="text-align:center">ACC_INTERFACE</td><td style="text-align:center">0x0200</td><td style="text-align:center">声明为接口</td></tr><tr><td style="text-align:center">ACC_ABSTRACT</td><td style="text-align:center">0x0400</td><td style="text-align:center">Abstract 类型</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:center">0x1000</td><td style="text-align:center">这个类并非由用户代码产生</td></tr><tr><td style="text-align:center">ACC_ANNOTATION</td><td style="text-align:center">0x2000</td><td style="text-align:center">注解</td></tr><tr><td style="text-align:center">ACC_ENUM</td><td style="text-align:center">0x4000</td><td style="text-align:center">枚举</td></tr></tbody></table><h3 id="1-1-4-类索引-父类索引"><a href="#1-1-4-类索引-父类索引" class="headerlink" title="1.1.4 类索引, 父类索引"></a>1.1.4 类索引, 父类索引</h3><pre><code>类索引和父类索引都是指向常量池的索引</code></pre><p>由于 Java 采用动态连接</p><p>动态连接是一个将符号引用解析为直接引用的过程。当java虚拟机执行字节码时，如果它遇到一个操作码，这个操作码第一次使用一个指向另一个类的符号引用</p><p>那么虚拟机就必须解析这个符号引用。在解析时，虚拟机执行两个基本任务</p><ol><li>查找被引用的类，（如果必要的话就装载它）</li><li>将符号引用替换为直接引用，这样当它以后再次遇到相同的引用时，它就可以立即使用这个直接引用，而不必花时间再次解析这个符号引用了。</li></ol><h3 id="1-1-5-接口"><a href="#1-1-5-接口" class="headerlink" title="1.1.5 接口"></a>1.1.5 接口</h3><h3 id="1-1-6-字段"><a href="#1-1-6-字段" class="headerlink" title="1.1.6 字段"></a>1.1.6 字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u2 fields_count;         // 字段数量</span><br><span class="line"></span><br><span class="line">field_info &#123;</span><br><span class="line">    u2 access_flags;                            // 访问控制符</span><br><span class="line">    u2 name_index;                              // 指向常量池的入口</span><br><span class="line">    u2 descriptor_index;                        // 指向常量池的入口</span><br><span class="line">    u2 attribute_count;                         // 该字段的属性数量</span><br><span class="line">    attribute_info attributes[attribute_count]; // 属性信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标志字符含义</p><table><thead><tr><th>header 1</th><th>header 2</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>void</td></tr><tr><td>L</td><td>对象类型的通用前缀, 如 <code>Ljava/lang/Object</code></td></tr></tbody></table><h3 id="1-1-7-方法"><a href="#1-1-7-方法" class="headerlink" title="1.1.7 方法"></a>1.1.7 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u2 methods_count;           // 方法数量</span><br><span class="line"></span><br><span class="line">method_info &#123;</span><br><span class="line">    u2 access_flags;                // 访问标志</span><br><span class="line">    u2 name_index;                  // 指向常量池的入口</span><br><span class="line">    u2 descriptor_index;            // 指向常量池的入口</span><br><span class="line">    u2 attributes_count;            // 该字段的属性数量</span><br><span class="line">    attribute_info attributes[attributes_count];    // 属性信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>(Ljava/lang/String;)V</code> 表示 <code>参数为 String, 返回值为 void 的方法</code><br><code>(Ljava/lang/String;IF)V</code> 表示 <code>参数为 String, int, float, 返回值为 void 的方法</code></p></blockquote><h3 id="1-1-8-属性"><a href="#1-1-8-属性" class="headerlink" title="1.1.8 属性"></a>1.1.8 属性</h3><ul><li>方法和字段都可能有属性<ul><li>方法中可能有 <code>Code</code> 属性, 字段可能有 <code>Constant Value</code> 属性</li></ul></li><li>属性中可能嵌套属性<ul><li><code>code</code> 属性中还可能有 <code>Line Number Table</code>, <code>Local Variable Table</code>, <code>Stack Map Table</code> 等属性</li></ul></li><li>虚拟机的实现中还可以自定义属性</li></ul><h4 id="1-1-8-1-Constant-Value"><a href="#1-1-8-1-Constant-Value" class="headerlink" title="1.1.8.1 Constant Value"></a>1.1.8.1 Constant Value</h4><pre><code>如果某字段为静态类型(access_flag 中包含 ACC_STATIC 标志)将会被分配 Constant Value 属性</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;    <span class="comment">// 必须是对常量池的一个有效索引, 常量池在该索引处的项必须是 UTF8Info, 表示字符串 "ConstantValue"</span></span><br><span class="line">    u4 attribute_length;        <span class="comment">// 固定为 2</span></span><br><span class="line">    u2 constantvalue_index;     <span class="comment">// 必须是对常量池的一个有效索引, 常量池在该索引处的项给出该属性表示的常量值, 可能的值有 Constant_String, Constant_Long 等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-8-2-Code"><a href="#1-1-8-2-Code" class="headerlink" title="1.1.8.2 Code"></a>1.1.8.2 Code</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;            <span class="comment">// 指向常量池, 应该是 UTF8Info, 且值为 "Code"</span></span><br><span class="line">    u4 attribute_length;                <span class="comment">// 属性长度, 不包括开始的 6 个字节</span></span><br><span class="line">    u2 max_stack;                       <span class="comment">// 操作数栈的最大深度</span></span><br><span class="line">    u2 max_locals;                      <span class="comment">// 最大局部变量表个数</span></span><br><span class="line">    u4 code_length;                     <span class="comment">// 该方法的代码长度</span></span><br><span class="line">    u1 code[code_length];               <span class="comment">// 真正的字节码</span></span><br><span class="line">    u2 exception_table_length;          <span class="comment">// 捕获异常表的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;        <span class="comment">// 捕获起始地址</span></span><br><span class="line">        u2 end_pc;          <span class="comment">// 捕获结束地址</span></span><br><span class="line">        u2 handler_pc;      <span class="comment">// </span></span><br><span class="line">        u2 catch_type;      <span class="comment">// 异常类型</span></span><br><span class="line">    &#125; exception_table[exception_table_length];  <span class="comment">// 捕获异常表</span></span><br><span class="line">    u2 attributes_count;                <span class="comment">// </span></span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Code 属性中的字节码</strong></p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/71745531.jpg" alt=""></p><table><thead><tr><th style="text-align:center">字节码</th><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">2A</td><td style="text-align:center">aload_0</td><td style="text-align:center">从局部变量表第 0 个值压入操作数栈</td></tr><tr><td style="text-align:center">B4 00 15</td><td style="text-align:center">getfield #21</td><td style="text-align:center">获取对象的字段值</td></tr><tr><td style="text-align:center">10 1E</td><td style="text-align:center">bipush 30</td><td style="text-align:center">将 30 压入栈中</td></tr><tr><td style="text-align:center">A2 00 0E</td><td style="text-align:center">if_icmp_ge 20</td><td style="text-align:center">将当前</td></tr></tbody></table><h4 id="1-1-8-3-LineNumber"><a href="#1-1-8-3-LineNumber" class="headerlink" title="1.1.8.3 LineNumber"></a>1.1.8.3 LineNumber</h4><pre><code>code属性的一个子属性可选的变长属性, 维护 Java 源代码行号与字节码行号(偏移量之间的对应关系)</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;        <span class="comment">// 字节码偏移量</span></span><br><span class="line">        u2 line_number;     <span class="comment">// 行号</span></span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-8-4-LocalVariableTable-属性"><a href="#1-1-8-4-LocalVariableTable-属性" class="headerlink" title="1.1.8.4 LocalVariableTable 属性"></a>1.1.8.4 LocalVariableTable 属性</h4><pre><code>code属性的一个子属性可选的变长属性, 维护栈帧中局部变量表中变量与 Java 源码中定义变量的关系</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;            <span class="comment">// 局部变量位于 [start_pc, start_pc + length)之间</span></span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;          <span class="comment">// 局部变量的名称索引</span></span><br><span class="line">        u2 descriptor_index;    <span class="comment">// 局部变量的描述符索引</span></span><br><span class="line">        u2 index;               <span class="comment">// 局部变量在栈帧中的索引</span></span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-JVM-运行时动态行为"><a href="#1-2-JVM-运行时动态行为" class="headerlink" title="1.2 JVM 运行时动态行为"></a>1.2 JVM 运行时动态行为</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/2593924.jpg" alt=""></p><ul><li>线程中包含函数栈帧, 其中每个函数帧表示某一个函数的调用过程</li><li>在每一个函数帧的内部, JVM 又细分了 <code>局部变量表</code>, <code>操作数栈</code> 等</li><li>局部变量和操作数栈中的变量会引用堆中的对象</li><li>常量池引用指向方法区, 方法区保存了类的元数据以及方法的字节码</li></ul><h3 id="1-2-1-实例"><a href="#1-2-1-实例" class="headerlink" title="1.2.1 实例"></a>1.2.1 实例</h3><p>Java 源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>转换成字节码后:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">demo:</span><br><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: bipush   <span class="number">10</span></span><br><span class="line"><span class="number">3</span>: bipush   <span class="number">20</span></span><br><span class="line"><span class="number">5</span>: invokevirtial    #<span class="number">2</span></span><br><span class="line"><span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">add:</span><br><span class="line"><span class="number">0</span>: aload_1</span><br><span class="line"><span class="number">1</span>: aload_2</span><br><span class="line"><span class="number">2</span>: iadd</span><br><span class="line"><span class="number">3</span>: istore_3</span><br><span class="line"><span class="number">4</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/39159076.jpg" alt=""></p><p>调用 <code>add</code> 函数, 生成新的函数帧</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/5082789.jpg" alt=""></p><p><code>0: aload_1</code>: 将局部变量表第 1 个变量压入操作数栈;<br><code>1: aload_2</code>: 将局部变量表第 2 个变量压入操作数栈;<br><code>2: iadd</code>: 将操作数栈顶端的两个元素弹出, 相加并将结果压入栈顶<br><code>3: istore_3</code>: 将操作数栈栈顶元素放在局部变量表第 3 个元素中<br><code>4: return</code>: 执行完毕</p><h1 id="2-ClassLoader"><a href="#2-ClassLoader" class="headerlink" title="2. ClassLoader"></a>2. ClassLoader</h1><h2 id="2-1-Java-是动态链接"><a href="#2-1-Java-是动态链接" class="headerlink" title="2.1 Java 是动态链接"></a>2.1 Java 是动态链接</h2><ul><li>C: 编译 -&gt; 链接 -&gt; 生成 <code>.exe</code> -&gt; 执行<ul><li>函数 A 调用函数 B, 在链接时会直接在函数 A 中记录函数 B 的地址</li></ul></li><li>Java: 编译 -&gt; <code>.class</code> -&gt; 装载执行<ul><li>类 A 中使用了另一个类 B, 在 A.class 中只保存类 B 的名称, 而不会保留 B 的 “地址”</li><li>在运行时根据名称来查找类, 装载类</li></ul></li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/64108809.jpg" alt=""></p><h2 id="2-2-类加载器的委托模型"><a href="#2-2-类加载器的委托模型" class="headerlink" title="2.2 类加载器的委托模型"></a>2.2 类加载器的委托模型</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/90661799.jpg" alt=""></p><p>工作原理</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/74913726.jpg" alt=""></p><h2 id="2-3-类加载器的命名空间"><a href="#2-3-类加载器的命名空间" class="headerlink" title="2.3 类加载器的命名空间"></a>2.3 类加载器的命名空间</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/81556783.jpg" alt=""></p><p><code>类加载器 + 类名</code> 唯一确定一个类, 只有同一个加载器加载的类才是相同的类.</p><h2 id="2-4-验证"><a href="#2-4-验证" class="headerlink" title="2.4 验证"></a>2.4 验证</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/9057717.jpg" alt=""></p><h2 id="2-5-自定义类加载器"><a href="#2-5-自定义类加载器" class="headerlink" title="2.5 自定义类加载器"></a>2.5 自定义类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classPaths = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteCodes = loadByteCode(name);</span><br><span class="line">        <span class="keyword">if</span> (byteCodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassFile(String classFileName) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String classPath: classPaths) &#123;</span><br><span class="line">            String realPath = classPath + File.separatorChar + classFileName.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">            </span><br><span class="line">            File file = <span class="keyword">new</span> File(classFileName);</span><br><span class="line">            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> IOUtils.toByteArray(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefineClass</code> 方法</p><ul><li><code>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int length) throws ClassFormatError;</code></li><li>只要传递给该方法一个合法字节数组, 就可以转化成一个 Class 对象, 这就意味着可以从任何地方组装类:<ul><li>磁盘</li><li>zip 文件</li><li>网络</li><li>运行时动态生成</li></ul></li></ul><h1 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3. 常量池"></a>3. 常量池</h1><h2 id="3-1-常见结构"><a href="#3-1-常见结构" class="headerlink" title="3.1 常见结构"></a>3.1 常见结构</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/54920383.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;         <span class="comment">// 7</span></span><br><span class="line">    u2 name_index;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;             <span class="comment">// 1</span></span><br><span class="line">    u2 length;          <span class="comment">// 长度</span></span><br><span class="line">    u1 bytes[length];   <span class="comment">// content</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    u1 tag;             <span class="comment">// </span></span><br><span class="line">    u2 string_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">    u1 tag;             <span class="comment">// 9</span></span><br><span class="line">    u2 class_index;     <span class="comment">// </span></span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1 tag;             <span class="comment">// 10</span></span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">    u1 tag;             <span class="comment">// 12</span></span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/51804525.jpg" alt=""></p><h2 id="3-2-访问标志"><a href="#3-2-访问标志" class="headerlink" title="3.2 访问标志"></a>3.2 访问标志</h2><table><thead><tr><th style="text-align:center">标志名称</th><th style="text-align:center">标志值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:center">0x0001</td><td style="text-align:center">public 类型</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:center">0x0002</td><td style="text-align:center">声明为 final 类型</td></tr><tr><td style="text-align:center">ACC_SUPER</td><td style="text-align:center">0x0020</td><td style="text-align:center">是否允许使用 <code>invokespecial</code> 字节码指令的新语义</td></tr><tr><td style="text-align:center">ACC_INTERFACE</td><td style="text-align:center">0x0200</td><td style="text-align:center">声明为接口</td></tr><tr><td style="text-align:center">ACC_ABSTRACT</td><td style="text-align:center">0x0400</td><td style="text-align:center">Abstract 类型</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:center">0x1000</td><td style="text-align:center">这个类并非由用户代码产生</td></tr><tr><td style="text-align:center">ACC_ANNOTATION</td><td style="text-align:center">0x2000</td><td style="text-align:center">注解</td></tr><tr><td style="text-align:center">ACC_ENUM</td><td style="text-align:center">0x4000</td><td style="text-align:center">枚举</td></tr></tbody></table><h1 id="4-字段-amp-方法"><a href="#4-字段-amp-方法" class="headerlink" title="4. 字段 &amp; 方法"></a>4. 字段 &amp; 方法</h1><h2 id="4-1-字段"><a href="#4-1-字段" class="headerlink" title="4.1 字段"></a>4.1 字段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u2 fields_count;         // 字段数量</span><br><span class="line"></span><br><span class="line">field_info &#123;</span><br><span class="line">    u2 access_flags;                            // 访问控制符</span><br><span class="line">    u2 name_index;                              // 指向常量池的入口</span><br><span class="line">    u2 descriptor_index;                        // 指向常量池的入口</span><br><span class="line">    u2 attribute_count;                         // 该字段的属性数量</span><br><span class="line">    attribute_info attributes[attribute_count]; // 属性信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/51718592.jpg" alt=""></p><p>可以看到上图中有两个字段, 分别为 <code>String</code> 类型的 <code>name</code>, 和 <code>int</code> 类型的 <code>age</code></p><ul><li><code>Name Index</code> 表示常量池中变量名称的索引</li><li><code>Desc Index</code> 表示常量池中变量类型的索引</li></ul><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u2 methods_count;           // 方法数量</span><br><span class="line"></span><br><span class="line">method_info &#123;</span><br><span class="line">    u2 access_flags;                // 访问标志</span><br><span class="line">    u2 name_index;                  // 指向常量池的入口</span><br><span class="line">    u2 descriptor_index;            // 指向常量池的入口</span><br><span class="line">    u2 attributes_count;            // 该字段的属性数量</span><br><span class="line">    attribute_info attributes[attributes_count];    // 属性信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/11946975.jpg" alt=""></p><p>以第一个方法为例:</p><ul><li><code>Name Index</code> 表示方法名称为 <code>&lt;init&gt;</code>, 即构造方法</li><li><code>Desc Index</code> 表示方法签名为 <code>(Ljava/lang/String;I)V</code>, 即 <code>(String, int):void</code></li></ul><h2 id="4-3-属性"><a href="#4-3-属性" class="headerlink" title="4.3 属性"></a>4.3 属性</h2><h3 id="4-3-1-Code-属性"><a href="#4-3-1-Code-属性" class="headerlink" title="4.3.1 Code 属性"></a>4.3.1 Code 属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;            <span class="comment">// 指向常量池, 应该是 UTF8Info, 且值为 "Code"</span></span><br><span class="line">    u4 attribute_length;                <span class="comment">// 属性长度, 不包括开始的 6 个字节</span></span><br><span class="line">    u2 max_stack;                       <span class="comment">// 操作数栈的最大深度</span></span><br><span class="line">    u2 max_locals;                      <span class="comment">// 最大局部变量表个数</span></span><br><span class="line">    u4 code_length;                     <span class="comment">// 该方法的代码长度</span></span><br><span class="line">    u1 code[code_length];               <span class="comment">// 真正的字节码</span></span><br><span class="line">    u2 exception_table_length;          <span class="comment">// 捕获异常表的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;        <span class="comment">// 捕获起始地址</span></span><br><span class="line">        u2 end_pc;          <span class="comment">// 捕获结束地址</span></span><br><span class="line">        u2 handler_pc;      <span class="comment">// </span></span><br><span class="line">        u2 catch_type;      <span class="comment">// 异常类型</span></span><br><span class="line">    &#125; exception_table[exception_table_length];  <span class="comment">// 捕获异常表</span></span><br><span class="line">    u2 attributes_count;                <span class="comment">// 嵌套属性数量</span></span><br><span class="line">    attribute_info attributes[attributes_count];    <span class="comment">// 嵌套属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code 属性一般由两个常见的子属性, 分别是:</p><ul><li>LineNumberTable</li><li>LocalVariableTable</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-24/56894058.jpg" alt=""></p><h3 id="4-3-2-LocalLineTable"><a href="#4-3-2-LocalLineTable" class="headerlink" title="4.3.2 LocalLineTable"></a>4.3.2 LocalLineTable</h3><pre><code>通过该属性可以完成字节码与 Java 源码的行号映射可以在 debug 的时候准确找到源码并且抛出异常的时候堆栈信息可以找到对应行号</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_arrtibute &#123;</span><br><span class="line">    u2 attribute_name_index;        <span class="comment">// 指向常量池, 必须是值为 "LineNumberTable" 的 Utf8 常量</span></span><br><span class="line">    u4 arrtibute_length;            <span class="comment">// 当前属性长度, 不包括开始的 6 个字节</span></span><br><span class="line">    u2 line_number_table_length;    <span class="comment">// line_number_table 数组元素个数</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;                <span class="comment">// start_pc 值必须是 code[] 数组的一个索引</span></span><br><span class="line">        u2 line_number;             <span class="comment">// 源文件的行号</span></span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-LocalVariableTable"><a href="#4-3-3-LocalVariableTable" class="headerlink" title="4.3.3 LocalVariableTable"></a>4.3.3 LocalVariableTable</h3><pre><code>LocalVariableTable 属性建立了方法中的局部变量与源代码中的局部变量之间的对应关系。 </code></pre><p>每个 LocalVariableTable  的 local_variable_table 部分可以看做是一个数组， 每个数组项是一个叫做local_variable_info的结构， 该结构描述了某个局部变量的变量名和描述符， 还有和源代码的对应关系。</p><p>下面讲解 <code>local_variable_info</code> 的各个部分：   </p><ul><li><code>start_pc</code> 是当前 local_variable_info 所对应的局部变量的作用域的起始字节码偏移量； </li><li><code>length</code> 是当前 <code>local_variable_info</code> 所对应的局部变量的作用域的大小。 也就是从字节码偏移量 <code>start_pc</code>  到 <code>start_pc+length</code> 就是当前局部变量的作用域范围； </li><li><code>name_index</code> 指向常量池中的一个 <code>CONSTANT_Utf8_info</code> ， 该 <code>CONSTANT_Utf8_info</code> 描述了当前局部变量的变量名； </li><li><code>descriptor_index</code> 指向常量池中的一个 <code>CONSTANT_Utf8_info</code> ， 该 <code>CONSTANT_Utf8_info</code> 描述了当前局部变量的描述符； </li><li><code>index</code> 描述了在该方法被执行时，当前局部变量在栈中局部变量表中的位置。 </li></ul><p>由此可知， 方法中的每个局部变量都会对应一个local_variable_info 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;        <span class="comment">// 指向常量池, 必须是值为 "LocalVariableTable_attribute" 的 Utf8 常量</span></span><br><span class="line">    u4 attribute_length;            <span class="comment">// 当前属性长度, 不包括开始的 6 个字节</span></span><br><span class="line">    u2 local_variable_table_length; <span class="comment">// local_variable_table[] 的元素个数</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;                <span class="comment">// 局部变量的索引都在范围 [start_pc, start_pc + length)</span></span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;              <span class="comment">// 变量名索引, 在常量池中</span></span><br><span class="line">        u2 descriptor_index;        <span class="comment">// 变量描述索引(在常量池中)</span></span><br><span class="line">        u2 index;                   <span class="comment">// 此局部变量在当前栈帧的局部变量表中的索引</span></span><br><span class="line">    &#125; local_variable_table[local_variable_table_length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-25/6624730.jpg" alt=""></p><p>解析以上字节码得到:</p><table><thead><tr><th style="text-align:center">start pc</th><th style="text-align:center">length</th><th style="text-align:center">slot</th><th style="text-align:center">name</th><th style="text-align:center">descript</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">15</td><td style="text-align:center">0</td><td style="text-align:center">this</td><td style="text-align:center">Lorg/destiny/jvm/model/Employee</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">15</td><td style="text-align:center">1</td><td style="text-align:center">name</td><td style="text-align:center">Ljava/lang/String</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">15</td><td style="text-align:center">2</td><td style="text-align:center">age</td><td style="text-align:center">I</td></tr></tbody></table><p>在解析 <code>code</code> 属性时需要注意的两点:</p><ul><li><code>code</code> 属性中包含了方法真正的字节码</li><li><code>code</code> 属性中包含几个子属性, 包括 <code>LineNumberTable</code>, <code>LocalVariableTable</code>等, 也需要进行解析.</li></ul><p>在 <code>Field</code>, <code>Method</code>, <code>Attribute</code> 三者中, 我们可以抽象出如下的关系:</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-25/90459462.jpg" alt=""></p><h3 id="4-3-4-Exceptions"><a href="#4-3-4-Exceptions" class="headerlink" title="4.3.4 Exceptions"></a>4.3.4 Exceptions</h3><pre><code>如果代码中出现了try{}catch{}块,那么try{}块内的机器指令的地址范围记录下来, 并且记录对应的catch{}块中的起始机器指令地址.当运行时在try块中有异常抛出的话, JVM会将catch{}块对应懂得其实机器指令地址传递给PC寄存器，从而实现指令跳转.</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u2 exception_table_length;          <span class="comment">// 捕获异常表的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    u2 start_pc;        <span class="comment">// 捕获起始地址</span></span><br><span class="line">    u2 end_pc;          <span class="comment">// 捕获结束地址</span></span><br><span class="line">    u2 handler_pc;      <span class="comment">// </span></span><br><span class="line">    u2 catch_type;      <span class="comment">// 异常类型</span></span><br><span class="line">&#125; exception_table[exception_table_length];  <span class="comment">// 捕获异常表</span></span><br></pre></td></tr></table></figure><p><code>exception_table</code> 记录了该 code 属性中所有显示抛出的异常信心, 包括异常的作用于及类型.</p><h1 id="5-字节码指令"><a href="#5-字节码指令" class="headerlink" title="5. 字节码指令"></a>5. 字节码指令</h1><h2 id="5-1-main-方法字节码"><a href="#5-1-main-方法字节码" class="headerlink" title="5.1 main 方法字节码"></a>5.1 main 方法字节码</h2><p>Employee 的 main 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="string">"destiny"</span>, <span class="number">24</span>);</span><br><span class="line">    employee.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过编译后的字节码:<br><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/52634127.jpg" alt=""></p><h3 id="5-1-1-new"><a href="#5-1-1-new" class="headerlink" title="5.1.1 new"></a>5.1.1 new</h3><pre><code>new indexbyte1 indexbyte2</code></pre><ul><li>操作: 创建一个对象</li><li>(indexbyte1 &lt;&lt; 8) | indexbyte2 得到一个指向常量池的索引</li><li>BB 00 01 对应 <code>new #1</code>, 对应的类就是 <code>org/destiny/jvm/model/Employee</code></li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/55866163.jpg" alt=""></p><ol><li>在堆中创建一个新对象</li><li>将该对象的引用压入栈中</li></ol><h3 id="5-1-2-dup"><a href="#5-1-2-dup" class="headerlink" title="5.1.2 dup"></a>5.1.2 dup</h3><ul><li>操作: 复制操作数栈栈顶的值, 并压入栈中</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/56559512.jpg" alt=""></p><h3 id="5-1-3-ldc"><a href="#5-1-3-ldc" class="headerlink" title="5.1.3 ldc"></a>5.1.3 ldc</h3><pre><code>ldc index</code></pre><ul><li>操作: 从运行时常量池中提取数据压入栈中</li><li><code>ldc #43</code>, 43 在常量池中的值为字符串 <code>destiny</code></li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/3305320.jpg" alt=""></p><h3 id="5-1-4-bipush"><a href="#5-1-4-bipush" class="headerlink" title="5.1.4 bipush"></a>5.1.4 bipush</h3><pre><code>bipush byte</code></pre><ul><li>将有符号 byte 扩展为一个 int 类型的值 value, 然后将 value 压入到操作数栈中.</li><li>byte 是一个立即数而非常量池引用</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/78725468.jpg" alt=""></p><h3 id="5-1-5-invokespecial-indexbyte1-indexbyte2"><a href="#5-1-5-invokespecial-indexbyte1-indexbyte2" class="headerlink" title="5.1.5 invokespecial indexbyte1 indexbyte2"></a>5.1.5 invokespecial indexbyte1 indexbyte2</h3><ul><li>操作: 对一个对象进行初始化, 父类的初始化, 调用私有方法(因为没有多态性为)</li><li>(indexbyte1 &lt;&lt; 8) | indexbyte2 得到一个指向常量池的索引</li><li><code>invokespecial #45</code></li><li>常量池 #45 是一个 <code>methodref</code>: <code>&lt;init&gt;:(Ljava/lang/String;I)V</code></li><li>需要形成新的栈帧</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/44315742.jpg" alt=""></p><h3 id="5-1-6-astore-n"><a href="#5-1-6-astore-n" class="headerlink" title="5.1.6 astore_n"></a>5.1.6 astore_n</h3><ul><li>操作: 将栈顶的 <code>reference</code> 类型数据保存到局部变量表中</li><li>astore_0</li><li>astore_1</li><li>astore_2</li><li>astore_3</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/31300372.jpg" alt=""></p><h3 id="5-1-7-aload-n"><a href="#5-1-7-aload-n" class="headerlink" title="5.1.7 aload_n"></a>5.1.7 aload_n</h3><ul><li>操作: 从局部变量表中加载一个 reference 类型的值到操作数栈中</li><li>aload_0</li><li>aload_1</li><li>aload_2</li><li>aload_3</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/9829577.jpg" alt=""></p><h3 id="5-1-8-invokevirtual-indexbyte1-indexbyte2"><a href="#5-1-8-invokevirtual-indexbyte1-indexbyte2" class="headerlink" title="5.1.8 invokevirtual indexbyte1 indexbyte2"></a>5.1.8 invokevirtual indexbyte1 indexbyte2</h3><ul><li>操作: 调用实例方法, 依据实例的具体类型进行分派(多态)</li><li>(indexbyte1 &lt;&lt; 8) | indexbyte2</li><li><code>invokevirtual #47</code> =&gt; <code>sayHello: ()V</code></li><li>也需要形成新的栈帧</li></ul><h3 id="5-1-9-return"><a href="#5-1-9-return" class="headerlink" title="5.1.9 return"></a>5.1.9 return</h3><ul><li>操作: 方法返回, 从当前函数栈帧退出, 无返回值.</li></ul><h2 id="5-2-方法指令"><a href="#5-2-方法指令" class="headerlink" title="5.2  方法指令"></a>5.2 <init> 方法指令</init></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/3230642.jpg" alt=""></p><h3 id="5-2-1-aload-0"><a href="#5-2-1-aload-0" class="headerlink" title="5.2.1 aload_0"></a>5.2.1 aload_0</h3><ul><li>操作: 从局部变量表中加载 index 为 0 的 reference 类型的值到操作数栈中</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/18433274.jpg" alt=""></p><h3 id="5-2-2-aload-1"><a href="#5-2-2-aload-1" class="headerlink" title="5.2.2 aload_1"></a>5.2.2 aload_1</h3><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/25073553.jpg" alt=""></p><h3 id="5-2-3-putfield-indexbyte1-indexbyte2"><a href="#5-2-3-putfield-indexbyte1-indexbyte2" class="headerlink" title="5.2.3 putfield indexbyte1 indexbyte2"></a>5.2.3 putfield indexbyte1 indexbyte2</h3><ul><li>操作: 给一个对象字段赋值</li><li>(indexbyte1 &lt;&lt; 8) | indexbyte2</li><li><code>putfield #15</code> =&gt; <code>putfield name:Ljava/lang/String</code></li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/36898043.jpg" alt=""></p><h3 id="5-3-3-iload-2"><a href="#5-3-3-iload-2" class="headerlink" title="5.3.3 iload_2"></a>5.3.3 iload_2</h3><ul><li>操作: 从局部变量中把 index 为 2 的 int 类型的值加载到操作数栈中</li><li>reference 类型使用 <code>aload</code>, int 类型使用 <code>iload</code></li></ul><h2 id="5-4-字节码指令的设计实现"><a href="#5-4-字节码指令的设计实现" class="headerlink" title="5.4 字节码指令的设计实现"></a>5.4 字节码指令的设计实现</h2><p>使用 <code>命令模式</code> 来抽象该场景, 即将所有字节码指令抽象为命令对象, 基类声明 <code>command</code> 方法, 再根据操作数的不同泛化出不同的抽象子类</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-26/32409326.jpg" alt=""></p><h1 id="6-JVM-执行引擎"><a href="#6-JVM-执行引擎" class="headerlink" title="6 JVM 执行引擎"></a>6 JVM 执行引擎</h1><p><img src="http://oetw0yrii.bkt.clouddn.com/18-7-1/2187429.jpg" alt=""></p><h2 id="6-1-Java-命令"><a href="#6-1-Java-命令" class="headerlink" title="6.1 Java 命令"></a>6.1 Java 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp path1;path2 org.destiny.jvm.Employee</span><br></pre></td></tr></table></figure><ul><li>cp: classpath(s), 默认是当前路径</li><li>class name: 系统需要找到这个类的 main 方法, 然后执行它的字节码</li></ul><h2 id="6-2-执行过程"><a href="#6-2-执行过程" class="headerlink" title="6.2 执行过程"></a>6.2 执行过程</h2><ul><li>加载类<ul><li>工具: <code>ClassFileLoader</code></li><li>目的地: 方法区</li></ul></li><li>获取类的 <code>public static void main(String[] args)</code> 方法<ul><li>从方法区寻找</li></ul></li><li>执行 <code>main</code> 方法的字节码<ul><li>字节码指令</li><li>栈帧(StackFrame)</li><li>堆(Heap)</li></ul></li></ul><h2 id="6-3-字节码指令的分类"><a href="#6-3-字节码指令的分类" class="headerlink" title="6.3 字节码指令的分类"></a>6.3 字节码指令的分类</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td style="text-align:center">依次执行</td><td style="text-align:center"><code>new</code><br><code>bipush</code><br><code>ldc</code><br><code>dup</code></td></tr><tr><td style="text-align:center">暂停当前栈帧并创建新栈帧</td><td style="text-align:center"><code>invokespecial</code><br><code>invokevirtual</code></td></tr><tr><td style="text-align:center">跳转到另一行去执行</td><td style="text-align:center"><code>if_icmp_ge</code><br><code>if_icmple</code><br><code>goto</code></td></tr><tr><td style="text-align:center">退出当前栈帧</td><td style="text-align:center"><code>return</code></td></tr></tbody></table><h1 id="7-垃圾回收机制"><a href="#7-垃圾回收机制" class="headerlink" title="7. 垃圾回收机制"></a>7. 垃圾回收机制</h1><h2 id="7-1-Java-对象的内存布局"><a href="#7-1-Java-对象的内存布局" class="headerlink" title="7.1 Java 对象的内存布局"></a>7.1 Java 对象的内存布局</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-7-1/13981658.jpg" alt=""></p><ul><li>MarkWord: 标注对象的元信息<ul><li>GC 年龄</li><li>锁的标志位</li></ul></li><li>ClassPointer: 指向方法区的类信息的指针</li><li>InstanceData: 类实例对象的数据<ul><li>方法信息保存在方法区</li></ul></li><li>padding: 填充</li></ul><h2 id="7-2-对象分配和垃圾回收"><a href="#7-2-对象分配和垃圾回收" class="headerlink" title="7.2 对象分配和垃圾回收"></a>7.2 对象分配和垃圾回收</h2><ul><li>对象优先分配在新生代<ul><li>如果 Eden 区没有足够的空间, 则触发一次 MinorGC</li><li>Java 对象大多具有生命周期短暂的特点, MinorGC 非常频繁, 速度也很快</li></ul></li><li>大对象直接进入老年代<ul><li>可以根据参数设置阈值</li></ul></li><li>长期存活对象进入老年代<ul><li>每个对象都有一个年龄(age), 在 MarkWord 中</li><li>如果 age 超过阈值, 则晋升到老年代</li></ul></li><li>动态年龄判断<ul><li>如果在 Survivor 空间中相同年龄的所有对象大小的总数和大于 Survivor 空间的一半, 年龄大于或等于该年龄的对象可以直接进入老年代</li></ul></li></ul><h2 id="MinorGC-时-新生代与老年代的关系"><a href="#MinorGC-时-新生代与老年代的关系" class="headerlink" title="MinorGC 时 新生代与老年代的关系"></a>MinorGC 时 新生代与老年代的关系</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-7-1/2587031.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oetw0yrii.bkt.clouddn.com/18-6-23/68954491.
      
    
    </summary>
    
      <category term="JVM" scheme="https://destinywang.github.io/blog/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://destinywang.github.io/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Netty(1)基本概念</title>
    <link href="https://destinywang.github.io/blog/2018/06/24/Netty-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://destinywang.github.io/blog/2018/06/24/Netty-1-基本概念/</id>
    <published>2018-06-24T09:43:11.000Z</published>
    <updated>2018-06-24T15:06:29.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Netty-架构设计"><a href="#1-Netty-架构设计" class="headerlink" title="1. Netty 架构设计"></a>1. Netty 架构设计</h1><p>Netty应用中必不可少的组件：</p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><code>Bootstrap</code> / <code>ServerBootstrap</code></td><td>一个Netty应用通常由一个Bootstrap开始，<br>它主要作用是配置整个Netty程序，串联起各个组件。</td></tr><tr><td><code>EventLoop</code></td><td>为 Channel 处理 IO 操作，一个 EventLoop 可以为多个 Channel 服务。</td></tr><tr><td><code>EventLoopGroup</code></td><td>包含多个 EventLoopGroup</td></tr><tr><td><code>Channel</code></td><td>一个 Socket 连接，或者其他和 IO 操作相关的组件，它和 EventLoop 一起用来参与 IO 处理。</td></tr><tr><td><code>Future</code> / <code>ChannelFuture</code></td><td>在 Netty 中所有的 IO 操作都是异步的，<br>因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，<br>具体的实现就是通过 Future 和 ChannelFutures ,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。<br>总之，所有的操作都会返回一个 ChannelFuture。</td></tr><tr><td><code>ChannelInitializer</code></td><td>当一个链接建立时，我们需要知道怎么来接收或者发送数据，<br>当然，我们有各种各样的 Handler 实现来处理它，那么 ChannelInitializer 便是用来配置这些 Handler ，<br>它会提供一个  ChannelPipeline，并把 Handler 加入到 ChannelPipeline。</td></tr><tr><td><code>ChannelHandler</code></td><td>为了支持各种协议和处理数据的方式，便诞生了 Handler 组件。<br>Handler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</td></tr><tr><td><code>ChannelPipeline</code></td><td>一个 Netty 应用基于 ChannelPipeline 机制，这种机制需要依赖于 EventLoop 和 EventLoopGroup ，因为它们三个都和事件或者事件处理相关</td></tr></tbody></table><h2 id="1-1-Netty-是如何处理连接请求和业务逻辑"><a href="#1-1-Netty-是如何处理连接请求和业务逻辑" class="headerlink" title="1.1 Netty 是如何处理连接请求和业务逻辑"></a>1.1 Netty 是如何处理连接请求和业务逻辑</h2><p>Netty是一个非阻塞的、事件驱动的、网络编程框架。</p><p>一个Channel会对应一个EventLoop，而一个EventLoop会对应着一个线程，也就是说，仅有一个线程在负责一个Channel的IO操作。</p><blockquote><p>当一个连接到达，Netty会注册一个channel，然后EventLoopGroup会分配一个EventLoop绑定到这个channel,在这个channel的整个生命周期过程中，都会由绑定的这个EventLoop来为它服务，而这个EventLoop就是一个线程。</p></blockquote><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-4/60707346.jpg" alt=""></p><blockquote><p>EventLoopGroup 和 EventLoop 的关系</p></blockquote><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-4/9536915.jpg" alt=""></p><h2 id="1-2-BootsStrapping"><a href="#1-2-BootsStrapping" class="headerlink" title="1.2 BootsStrapping"></a>1.2 BootsStrapping</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-4/35530633.jpg" alt=""></p><p>我们利用 BootsStrapping 来配置 netty 应用，它有两种类型，一种用于 Client 端：BootsStrap，另一种用于Server端：ServerBootstrap，要想区别如何使用它们，你仅需要记住一个用在 Client 端，一个用在 Server 端。下面我们来详细介绍一下这两种类型的区别：</p><ol><li>ServerBootstrap 用于 Server 端，通过调用 <code>bind()</code> 方法来绑定到一个端口监听连接； Bootstrap 用于 Client 端，需要调用 <code>connect()</code> 方法来连接服务器端，但我们也可以通过调用 <code>bind()</code> 方法返回的 <code>ChannelFuture</code> 中获取 Channel 去 connect 服务器端。</li><li>客户端的 Bootstrap 一般用一个 EventLoopGroup，而服务器端的 ServerBootstrap 会用到两个（这两个也可以是同一个实例）。为何服务器端要用到两个 EventLoopGroup 呢？这么设计有明显的好处，如果一个 ServerBootstrap 有两个 EventLoopGroup，那么就可以把第一个 EventLoopGroup 用来专门负责绑定到端口监听连接事件，而把第二个 EventLoopGroup 用来处理每个接收到的连接。</li></ol><h2 id="1-3-ChannelHandler"><a href="#1-3-ChannelHandler" class="headerlink" title="1.3 ChannelHandler"></a>1.3 ChannelHandler</h2><p>应用程序中用到的最多的应该就是ChannelHandler，我们可以这么想象，数据在一个ChannelPipeline中流动，而ChannelHandler便是其中的一个个的小阀门，这些数据都会经过每一个ChannelHandler并且被它处理。</p><p>一个ChannelPipeline可以把两种Handler（ChannelInboundHandler和ChannelOutboundHandler）混合在一起，当一个数据流进入ChannelPipeline时，它会从ChannelPipeline头部开始传给第一个ChannelInboundHandler，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的“最后”一个ChannelOutboundHandler，当它处理完成后会传递给前一个ChannelOutboundHandler。</p><p>数据在各个Handler之间传递，这需要调用方法中传递的ChanneHandlerContext来操作， 在netty的API中提供了两个基类分ChannelOutboundHandlerAdapter和ChannelOutboundHandlerAdapter，他们仅仅实现了调用ChanneHandlerContext来把消息传递给下一个Handler，因为我们只关心处理数据，因此我们的程序中可以继承这两个基类来帮助我们做这些，而我们仅需实现处理数据的部分即可。</p><p>我们知道InboundHandler和OutboundHandler在ChannelPipeline中是混合在一起的，那么它们如何区分彼此呢？其实很容易，因为它们各自实现的是不同的接口，对于inbound event，Netty会自动跳过OutboundHandler,相反若是outbound event，ChannelInboundHandler会被忽略掉。</p><p>当一个ChannelHandler被加入到ChannelPipeline中时，它便会获得一个ChannelHandlerContext的引用，而ChannelHandlerContext可以用来读写Netty中的数据流。因此，现在可以有两种方式来发送数据，一种是把数据直接写入Channel，一种是把数据写入ChannelHandlerContext，它们的区别是写入Channel的话，数据流会从Channel的头开始传递，而如果写入ChannelHandlerContext的话，数据流会流入管道中的下一个Handler。  </p><h2 id="1-4-Encoders-Decoders-and-Domain-Logic"><a href="#1-4-Encoders-Decoders-and-Domain-Logic" class="headerlink" title="1.4  Encoders, Decoders and Domain Logic"></a>1.4  Encoders, Decoders and Domain Logic</h2><h3 id="Encoders和Decoders"><a href="#Encoders和Decoders" class="headerlink" title="Encoders和Decoders"></a>Encoders和Decoders</h3><p>因为我们在网络传输时只能传输字节流，因此，才发送数据之前，我们必须把我们的message型转换为bytes，与之对应，我们在接收数据后，必须把接收到的bytes再转换成message。我们把bytes to message这个过程称作Decode(解码成我们可以理解的)，把message to bytes这个过程成为Encode。</p><p>Netty中提供了很多现成的编码/解码器，我们一般从他们的名字中便可知道他们的用途，如ByteToMessageDecoder、MessageToByteEncoder，如专门用来处理Google Protobuf协议的ProtobufEncoder、 ProtobufDecoder。</p><p>我们前面说过，具体是哪种Handler就要看它们继承的是InboundAdapter还是OutboundAdapter，对于Decoders,很容易便可以知道它是继承自ChannelInboundHandlerAdapter或 ChannelInboundHandler，因为解码的意思是把ChannelPipeline传入的bytes解码成我们可以理解的message（即Java Object），而ChannelInboundHandler正是处理Inbound Event，而Inbound Event中传入的正是字节流。Decoder会覆盖其中的“ChannelRead()”方法，在这个方法中来调用具体的decode方法解码传递过来的字节流，然后通过调用ChannelHandlerContext.fireChannelRead(decodedMessage)方法把编码好的Message传递给下一个Handler。与之类似，Encoder就不必多少了。</p><h3 id="Domain-Logic"><a href="#Domain-Logic" class="headerlink" title="Domain Logic"></a>Domain Logic</h3><p>其实我们最最关心的事情就是如何处理接收到的解码后的数据，我们真正的业务逻辑便是处理接收到的数据。Netty提供了一个最常用的基类SimpleChannelInboundHandler<t>，其中T就是这个Handler处理的数据的类型（上一个Handler已经替我们解码好了），消息到达这个Handler时，Netty会自动调用这个Handler中的channelRead0(ChannelHandlerContext,T)方法，T是传递过来的数据对象，在这个方法中我们便可以任意写我们的业务逻辑了。</t></p><h1 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h1><h2 id="2-1-依赖"><a href="#2-1-依赖" class="headerlink" title="2.1 依赖"></a>2.1 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.21.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Server-端-ChannelHandler"><a href="#2-2-Server-端-ChannelHandler" class="headerlink" title="2.2 Server 端 ChannelHandler"></a>2.2 Server 端 ChannelHandler</h2><p>我们不需要使每一个 <code>InboundChannel</code> 继承自 <code>ChannelInboundHandler</code>，因为直接继承的话需要实现 <code>ChannelInboundHandler</code> 中的所有接口，在一般的 <code>Channel</code> 中没必要这么做，只需要继承 <code>ChannelInboundHandelAdapter</code>，继承它的适配器就可以。</p><p>需要实现几个重要的方法，包括读取方法 <code>channelRead(ChannelHandlerContext, ctx)</code> 和异常处理方法 <code>exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorldServerHandler.channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorldServerHandler.channelRead"</span>);</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress().toString() + <span class="string">"-&gt; server: "</span> + msg.toString());</span><br><span class="line">        ctx.write(<span class="string">"server write: "</span> + msg);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-服务端"><a href="#2-3-服务端" class="headerlink" title="2.3 服务端"></a>2.3 服务端</h2><p>需要一个 <code>ServerBootStrap</code>，用于引导 Netty Server 端的初始化工作。<br>我们需要指定它的 <code>transports</code>，是 <code>NIO还</code> 是 <code>OIO</code> ,还需要指定端口号，安装 <code>server</code> 端的处理器，也就是我们之前写的 <code>HelloWorldServerHandler</code> ，还有一些 <code>Option</code> 的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap().group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class).localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline()</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HelloWorldServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            future.channel().write(<span class="string">"Hello Netty Client, I am a Server"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">9527</span>;</span><br><span class="line">        <span class="keyword">new</span> HelloWorldServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-Client-端-ChannelHandler"><a href="#2-4-Client-端-ChannelHandler" class="headerlink" title="2.4 Client 端 ChannelHandler"></a>2.4 Client 端 ChannelHandler</h2><p>整体与 <code>HelloWorldServerHandler</code> 类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorldClientHandler.channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorldClientHandler.channelRead: ==&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-Client-端"><a href="#2-5-Client-端" class="headerlink" title="2.5 Client 端"></a>2.5 Client 端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline()</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HelloWorldClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">9527</span>).sync();</span><br><span class="line">            future.channel().writeAndFlush(<span class="string">"Hello Netty Server, I am a common client"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别启动 <code>Server 端</code> 和 <code>Client 端</code> 即可看到运行结果。</p><p>具体过程如下：</p><ol><li><code>HelloWorldServer</code> 启动，完成 <code>ChannelHandler</code> 的初始化，监听指定端口，在 <code>ChannelFuture future = serverBootstrap.bind(port).sync()</code> 处进行阻塞；</li><li><code>HelloWorldClient</code> 启动，完成 <code>ChannelHandler</code> 的初始化，并向 <code>127.0.0.1:9527</code> 发送一条信息，同时阻塞等待返回结果；</li><li><code>HelloWorldServerHandler</code> 读取到 <code>HelloWorldClient</code> 发送的消息，并写入自己的消息 <code>ctx.write(&quot;server write: &quot; + msg)</code></li><li><code>HelloWorldClientHandler</code> 读取到 <code>HelloWorldServerHandler</code>； 发送的消息，打印到控制台。</li></ol><h1 id="3-Hello-World-结构图"><a href="#3-Hello-World-结构图" class="headerlink" title="3. Hello World 结构图"></a>3. Hello World 结构图</h1><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-31/70138342.jpg" alt=""></p><h1 id="4-ChannelHandler、ChannelHandlerContext-和-ChannelPipeline"><a href="#4-ChannelHandler、ChannelHandlerContext-和-ChannelPipeline" class="headerlink" title="4. ChannelHandler、ChannelHandlerContext 和 ChannelPipeline"></a>4. <code>ChannelHandler</code>、<code>ChannelHandlerContext</code> 和 <code>ChannelPipeline</code></h1><blockquote><p>ChannelInboundHandlerAdapter<br><img src="http://oetw0yrii.bkt.clouddn.com/18-6-3/26874824.jpg" alt=""></p></blockquote><blockquote><p>ChannelOutboundHandlerAdapter<br><img src="http://oetw0yrii.bkt.clouddn.com/18-6-3/88244957.jpg" alt=""></p></blockquote><p>我们平时继承的最多的就是 <code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> ，这两个不是接口也不是抽象类，所以我们可以仅仅重写我们需要的方法，没有必须要实现的方法</p><p><code>ChannelHandler</code>, <code>ChannelHandlerContext</code> , <code>ChannelPipeline</code> 这三者的关系很特别，相辅相成，一个 <code>ChannelPipeline</code> 中可以有多个 <code>ChannelHandler</code> 实例，而每一个 <code>ChannelHandler</code> 实例与 <code>ChannelPipeline</code> 之间的桥梁就是 <code>ChannelHandlerContext</code> 实例</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-3/34681069.jpg" alt=""></p><p>如果能够获取到 <code>ChannelHandlerContext</code> 实例的话，就可以获取到需要的一切。同时，可以根据 <code>ChannelHandlerContext</code> 执行 <code>ChannelHandler</code> 中的方法</p><h2 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h2><ul><li>首先新增两个 <code>ChannelHandler</code></li><li>修改 <code>HelloWorldClient</code> 中的代码</li></ul><h3 id="4-1-1-BaseClient1Handler"><a href="#4-1-1-BaseClient1Handler" class="headerlink" title="4.1.1 BaseClient1Handler"></a>4.1.1 <code>BaseClient1Handler</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClient1Handler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BaseClient1Handler.channelActive"</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BaseClient1Handler.channelInactive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-BaseClient2Handler"><a href="#4-1-2-BaseClient2Handler" class="headerlink" title="4.1.2 BaseClient2Handler"></a>4.1.2 <code>BaseClient2Handler</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClient2Handler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BaseClient2Handler.channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-HelloWorldClient"><a href="#4-1-3-HelloWorldClient" class="headerlink" title="4.1.3 HelloWorldClient"></a>4.1.3 HelloWorldClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline()</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())</span><br><span class="line"><span class="comment">//                                    .addLast(new HelloWorldClientHandler());</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> BaseClient1Handler())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> BaseClient2Handler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">9527</span>).sync();</span><br><span class="line">            future.channel().writeAndFlush(<span class="string">"Hello Netty Server, I am a common client"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-4-执行结果"><a href="#4-1-4-执行结果" class="headerlink" title="4.1.4 执行结果"></a>4.1.4 执行结果</h3><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-3/12664699.jpg" alt=""></p><p>此时看到，<code>BaseClient1Handler</code> 和 <code>BaseClient2Handler</code> 都执行了 <code>channelActive()</code> 方法。</p><p>但如果把 <code>BaseClient1Handler</code> 的 <code>ctx.fireChannelActive()</code> 去掉，那么只会有 <code>BaseClient1Handler</code> 执行该方法</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-3/67183442.jpg" alt=""></p><pre><code>也就是说如果一个 channelPipeline 中有多个 channelHandler 时，且这些 channelHandler 中有同样的方法时，例如这里的 channelActive 方法，只会调用处在第一个的 channelHandler 中的 channelActive 方法，如果你想要调用后续的 channelHandler 的同名的方法就需要调用以 &quot;fire&quot; 为开头的方法了，这样做很灵活</code></pre><p>这样设计的优点：</p><ol><li>每一个 <code>handler</code> 只需要关注自己要处理的方法，如果你不关注 <code>channelActive</code> 方法时，你自定义的 <code>channelhandler</code> 就不需要重写 <code>channelActive</code> 方法;</li><li>异常处理，如果 <code>exceptionCaught</code> 方法每个 <code>handler</code> 都重写了，只需有一个类捕捉到然后做处理就可以了，不需要每个 <code>handler</code> 都处理一遍;</li><li>灵活性，也许左侧第一个 <code>ChannelHandler</code> 根本不需要管理某个业务逻辑，但是从第二个 <code>ChannelHandler</code> 就需要关注处理某个业务需求了，那么就可以很灵活地从第二个 <code>ChannelHandler</code> 开始处理业务，不需要从channel中的第一个 <code>ChannelHandler</code> 开始处理.</li></ol><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-3/72901126.jpg" alt=""></p><h1 id="5-ByteBuf"><a href="#5-ByteBuf" class="headerlink" title="5. ByteBuf"></a>5. <code>ByteBuf</code></h1><pre><code>网络传输的载体是 byte, 这是任何框架谁也逃脱不了的一种规定. JAVA 的 NIO 提供了 ByteBuffer, 用来完成这项任务.</code></pre><p><img src="http://oetw0yrii.bkt.clouddn.com/18-6-4/88956497.jpg" alt=""></p><p>读的时候，可读的区域是下标区间是 <code>[readerIndex，writeIndex)</code> ，可写区间的是 <code>[writerIndex,capacity-1]</code> ，但是 <code>discardable</code> 这段区间就会变得相对无用，既不能读，也不能写</p><p>从内存分配角度看，ByteBuf 可以分为两类：</p><ol><li>堆内存字节缓冲区: 特点是内存的分配和回收速度快，可以被 JVM 自动回收，缺点是如果进行 Socket 的 I/O 读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核 Channel 中，性能会有一定程度的下降。</li><li><p>直接内存字节缓冲区: 非堆内存，它在堆外进行内存分配，相比于堆内存，它的分配和回收速度会慢一些，但是将它写入或者从 Socket Channel 中读取时，由于少了一次内存复制，速度比堆内存快。</p><p> ByteBuf 最佳实践: 在 I/O 通信线程的读写缓冲区使用 <code>DirectByteBuf</code>, 后端业务消息的编码模块使用 <code>HeapByteBuf</code>, 这样组合可以达到性能最优.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Netty-架构设计&quot;&gt;&lt;a href=&quot;#1-Netty-架构设计&quot; class=&quot;headerlink&quot; title=&quot;1. Netty 架构设计&quot;&gt;&lt;/a&gt;1. Netty 架构设计&lt;/h1&gt;&lt;p&gt;Netty应用中必不可少的组件：&lt;/p&gt;
&lt;table&gt;
      
    
    </summary>
    
      <category term="Netty" scheme="https://destinywang.github.io/blog/categories/Netty/"/>
    
    
      <category term="Netty" scheme="https://destinywang.github.io/blog/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>dubbo踩坑总结</title>
    <link href="https://destinywang.github.io/blog/2018/05/20/dubbo%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    <id>https://destinywang.github.io/blog/2018/05/20/dubbo踩坑总结/</id>
    <published>2018-05-20T11:05:20.000Z</published>
    <updated>2018-06-03T05:27:51.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-注册服务-IP-解析异常"><a href="#2-注册服务-IP-解析异常" class="headerlink" title="2. 注册服务 IP 解析异常"></a>2. 注册服务 IP 解析异常</h1><pre><code>在使用 dubbo 注册服务的时候遇到了 IP 解析错误导致无法正常访问的问题。</code></pre><p>在实际问题中，consumer 无法连接到 provider 的服务。<br>其具体表现为：</p><blockquote><p>本机的 IP 设置为 192.168.1.116，但 dubbo 绑定的却是 dubbo://30.250.11.135:20880，本机 ping 30.250.11.135 提示连接超时，provider 可以启动成功，但是 consumer 无法连接，提示连接超时。</p></blockquote><h2 id="2-1-复现场景"><a href="#2-1-复现场景" class="headerlink" title="2.1 复现场景"></a>2.1 复现场景</h2><h3 id="2-1-1-provider"><a href="#2-1-1-provider" class="headerlink" title="2.1.1 provider"></a>2.1.1 provider</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 具体的实现 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"provider"</span> <span class="attr">class</span>=<span class="string">"org.destiny.dubbo.impl.ProviderImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用 Zookeeper 注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://10.211.55.4:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用 dubbo 协议在 20880 端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 增加暴露远程服务配置，写操作可以设置 retries=0 避免重复调用 SOA 服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">retries</span>=<span class="string">"0"</span> <span class="attr">interface</span>=<span class="string">"org.destiny.dubbo.Provider"</span> <span class="attr">ref</span>=<span class="string">"provider"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>provider 的启动日志如下：<br><img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/19059838.jpg" alt=""></p><h3 id="2-1-2-consumer"><a href="#2-1-2-consumer" class="headerlink" title="2.1.2 consumer"></a>2.1.2 consumer</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用 Zookeeper 注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://10.211.55.4:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生成远程代理，可以像本地使用 bean 一样使用 demoService，检查级联依赖默认为 true，当有依赖服务的时候，需要根据需求进行设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"consumer"</span> <span class="attr">interface</span>=<span class="string">"org.destiny.dubbo.Provider"</span> <span class="attr">check</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer 启动日志如下：<br><img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/31806797.jpg" alt=""></p><h2 id="2-2-定位问题"><a href="#2-2-定位问题" class="headerlink" title="2.2 定位问题"></a>2.2 定位问题</h2><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/94603035.jpg" alt=""></p><ul><li><p>在 provider 启动时，定位到日志中第一次出现 <code>30.250.11.135</code> 的的位置： <code>current host</code></p></li><li><p>然后全局搜索 <code>current host</code>，定位到对应源码：<code>com.alibaba.dubbo.common.logger.support.FailsafeLogger</code></p></li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/79552638.jpg" alt=""></p><ul><li>怀疑 <code>NetUtils.getLocalHost()</code> 获取到的 IP 就是 <code>30.250.11.135</code></li><li>单独执行 <code>System.out.println(NetUtils.getLocalHost())</code>，发现结果确实是 <code>30.250.11.135</code></li></ul><p>此时结果已经很明确了，是 <code>NetUtils.getLocalHost()</code> 返回的 IP 地址已经错误，导致上面的问题发生。</p><h2 id="2-3-分析问题"><a href="#2-3-分析问题" class="headerlink" title="2.3 分析问题"></a>2.3 分析问题</h2><p>通过阅读 dubbo 相关部分源码，其大致运行过程如下：</p><ol><li>dubbo 在获取本地 IP 的时候，先调用 <code>NetUtils.getLocalHost()</code>，如果该方法返回一个合法的地址，则直接认为是一本地 IP 的地址。</li><li>如果 <code>NetUtils.getLocalHost()</code> 没有返回合法地址，则会遍历本地所有网卡，并返回第一个合法的 IP 作为本地 IP。</li></ol><p>而问题就出在 <code>NetUtils.getLocalHost()</code> 返回的并不是真正的本机 IP，却被 dubbo 误认为正确。</p><pre><code>NetUtils.getLocalHost() 的原理是通过获取本机的 hostname，然后对此 hostname 做解析，从而获取 IP 地址；而如果在本机的 /etc/hosts/ 文件中对这个主机名指向了一个错误的 IP 地址，那么 NetUtils.getLocalHost() 就会返回这个错误的 IP 地址；如果 hostname 是到 DNS 中去解析的，而碰巧 DNS 也是错误的，那么返回的同样是错误的 IP。</code></pre><p>因此就可以解释我们遇到的问题了：</p><blockquote><p>provider 实际上是运行在 A 地址上，但是 dubbo 检测到本地的 IP 是 B，然后在 Zookeeper 上注册自己服务地址的时候，使用的是 B 地址，那么当 consumer 连接到 Zookeeper 上的时候，查询到 provider 是在 B 地址上，但显然 B 地址上没有该服务，甚至根本无法连接到。因此就出现了该问题。</p></blockquote><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/86549838.jpg" alt=""></p><p>这个地址就是一开始被 dubbo 意外解析到的 <code>30.250.11.135</code>。</p><h2 id="2-4-解决问题"><a href="#2-4-解决问题" class="headerlink" title="2.4 解决问题"></a>2.4 解决问题</h2><ol><li>先检查 <code>/etc/hosts</code> 文件中设置的 A 地址指向哪里</li><li>再检查 DNS 解析出的地址</li></ol><ul><li><code>/etc/hosts</code> 文件修改前：  <img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/54420075.jpg" alt=""></li><li>向 <code>/etc/hosts</code> 文件中追加 <code>destiny     127.0.0.1</code>  <img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/87386483.jpg" alt=""></li><li><code>/etc/hosts</code> 文件修改后：  <img src="http://oetw0yrii.bkt.clouddn.com/18-5-20/91260183.jpg" alt=""></li></ul><h2 id="2-5-引申-——-如何在-Java-代码中正确的读取本地-IP-地址"><a href="#2-5-引申-——-如何在-Java-代码中正确的读取本地-IP-地址" class="headerlink" title="2.5 引申 —— 如何在 Java 代码中正确的读取本地 IP 地址"></a>2.5 引申 —— 如何在 Java 代码中正确的读取本地 IP 地址</h2><pre><code>目前最普遍的方法是使用 `InetAddress.getLocalHost().getHostAddress()` 获取但该方法只能获取简单网络环境下的 IP 地址如果当前的网络环境比较复杂，存在多个网卡，则会被忽视</code></pre><p>比如列出我当前本机的 <code>ifconfig</code> 命令直接结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">lo0: flags=<span class="number">8049</span>&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu <span class="number">16384</span></span><br><span class="line">    options=<span class="number">1203</span>&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;</span><br><span class="line">    inet <span class="number">127.0</span>.<span class="number">0.1</span> netmask <span class="number">0</span>xff000000</span><br><span class="line">    inet6 ::<span class="number">1</span> prefixlen <span class="number">128</span></span><br><span class="line">    inet6 fe80::<span class="number">1</span>%lo0 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>x1</span><br><span class="line">    nd6 options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">gif0: flags=<span class="number">8010</span>&lt;POINTOPOINT,MULTICAST&gt; mtu <span class="number">1280</span></span><br><span class="line">stf0: flags=<span class="number">0</span>&lt;&gt; mtu <span class="number">1280</span></span><br><span class="line">XHC20: flags=<span class="number">0</span>&lt;&gt; mtu <span class="number">0</span></span><br><span class="line">en0: flags=<span class="number">8863</span>&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">    ether <span class="number">98</span>:<span class="number">01</span>:a7:a2:<span class="number">9</span>a:c1</span><br><span class="line">    inet6 fe80::<span class="number">1</span>ca6:<span class="number">7</span>ed1:<span class="number">3</span>b63:<span class="number">235</span>f%en0 prefixlen <span class="number">64</span> secured scopeid <span class="number">0</span>x5</span><br><span class="line">    inet <span class="number">192.168</span>.<span class="number">1.103</span> netmask <span class="number">0</span>xffffff00 broadcast <span class="number">192.168</span>.<span class="number">1.255</span></span><br><span class="line">    nd6 options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">    media: autoselect</span><br><span class="line">    status: active</span><br><span class="line">p2p0: flags=<span class="number">8843</span>&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">2304</span></span><br><span class="line">    ether <span class="number">0</span>a:<span class="number">01</span>:a7:a2:<span class="number">9</span>a:c1</span><br><span class="line">    media: autoselect</span><br><span class="line">    status: inactive</span><br><span class="line">awdl0: flags=<span class="number">8943</span>&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu <span class="number">1484</span></span><br><span class="line">    ether ba:<span class="number">98</span>:<span class="number">20</span>:<span class="number">03</span>:<span class="number">2</span>e:f7</span><br><span class="line">    inet6 fe80::b898:<span class="number">20</span>ff:fe03:<span class="number">2</span>ef7%awdl0 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>x7</span><br><span class="line">    nd6 options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">    media: autoselect</span><br><span class="line">    status: active</span><br><span class="line">en1: flags=<span class="number">8963</span>&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">    options=<span class="number">60</span>&lt;TSO4,TSO6&gt;</span><br><span class="line">    ether <span class="number">6</span>a:<span class="number">00</span>:<span class="number">02</span>:<span class="number">3</span>e:<span class="number">5</span>e:<span class="number">80</span></span><br><span class="line">    media: autoselect &lt;full-duplex&gt;</span><br><span class="line">    status: inactive</span><br><span class="line">en2: flags=<span class="number">8963</span>&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">    options=<span class="number">60</span>&lt;TSO4,TSO6&gt;</span><br><span class="line">    ether <span class="number">6</span>a:<span class="number">00</span>:<span class="number">02</span>:<span class="number">3</span>e:<span class="number">5</span>e:<span class="number">81</span></span><br><span class="line">    media: autoselect &lt;full-duplex&gt;</span><br><span class="line">    status: inactive</span><br><span class="line">bridge0: flags=<span class="number">8863</span>&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">    options=<span class="number">63</span>&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;</span><br><span class="line">    ether <span class="number">6</span>a:<span class="number">00</span>:<span class="number">02</span>:<span class="number">3</span>e:<span class="number">5</span>e:<span class="number">80</span></span><br><span class="line">    Configuration:</span><br><span class="line">        id <span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span> priority <span class="number">0</span> hellotime <span class="number">0</span> fwddelay <span class="number">0</span></span><br><span class="line">        maxage <span class="number">0</span> holdcnt <span class="number">0</span> proto stp maxaddr <span class="number">100</span> timeout <span class="number">1200</span></span><br><span class="line">        root id <span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span> priority <span class="number">0</span> ifcost <span class="number">0</span> port <span class="number">0</span></span><br><span class="line">        ipfilter disabled flags <span class="number">0</span>x2</span><br><span class="line">    member: en1 flags=<span class="number">3</span>&lt;LEARNING,DISCOVER&gt;</span><br><span class="line">            ifmaxaddr <span class="number">0</span> port <span class="number">8</span> priority <span class="number">0</span> path cost <span class="number">0</span></span><br><span class="line">    member: en2 flags=<span class="number">3</span>&lt;LEARNING,DISCOVER&gt;</span><br><span class="line">            ifmaxaddr <span class="number">0</span> port <span class="number">9</span> priority <span class="number">0</span> path cost <span class="number">0</span></span><br><span class="line">    nd6 options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">    media: &lt;unknown type&gt;</span><br><span class="line">    status: inactive</span><br><span class="line">utun0: flags=<span class="number">8051</span>&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu <span class="number">2000</span></span><br><span class="line">    inet6 fe80::a5b9:<span class="number">4</span>c1f:b4b8:<span class="number">9414</span>%utun0 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>xb</span><br><span class="line">    nd6 options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">utun1: flags=<span class="number">8051</span>&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu <span class="number">1380</span></span><br><span class="line">    inet6 fe80::<span class="number">3</span>de1:<span class="number">6926</span>:<span class="number">1140</span>:<span class="number">2956</span>%utun1 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>xc</span><br><span class="line">    inet6 fdd5:<span class="number">8</span>db9:<span class="number">2302</span>:<span class="number">60</span>f0:<span class="number">3</span>de1:<span class="number">6926</span>:<span class="number">1140</span>:<span class="number">2956</span> prefixlen <span class="number">64</span></span><br><span class="line">    nd6 options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">utun2: flags=<span class="number">8051</span>&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu <span class="number">1380</span></span><br><span class="line">    inet6 fe80::<span class="number">4568</span>:<span class="number">978</span>c:<span class="number">85</span>d3:ecd9%utun2 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>xd</span><br><span class="line">    nd6 options=<span class="number">201</span>&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">vnic0: flags=<span class="number">8843</span>&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">    options=<span class="number">3</span>&lt;RXCSUM,TXCSUM&gt;</span><br><span class="line">    ether <span class="number">00</span>:<span class="number">1</span>c:<span class="number">42</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">08</span></span><br><span class="line">    inet <span class="number">10.211</span>.<span class="number">55.2</span> netmask <span class="number">0</span>xffffff00 broadcast <span class="number">10.211</span>.<span class="number">55.255</span></span><br><span class="line">    media: autoselect</span><br><span class="line">    status: active</span><br><span class="line">vnic1: flags=<span class="number">8843</span>&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">    options=<span class="number">3</span>&lt;RXCSUM,TXCSUM&gt;</span><br><span class="line">    ether <span class="number">00</span>:<span class="number">1</span>c:<span class="number">42</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">09</span></span><br><span class="line">    inet <span class="number">10.37</span>.<span class="number">129.2</span> netmask <span class="number">0</span>xffffff00 broadcast <span class="number">10.37</span>.<span class="number">129.255</span></span><br><span class="line">    media: autoselect</span><br><span class="line">    status: active</span><br></pre></td></tr></table></figure><p>可以看到有很多类型的网络接口<code>(network interfaces)</code>：</p><ul><li><code>loopback</code> 地址: 最常见的就是 127.0.0.1，即本地回环地址，只对本机可见，一般用于调试。</li><li><code>site local address</code> 地址: private 私有地址，属于本地组织内部访问，只能在本地局域网可见，同样 <code>10.xxx.xxx.xxx</code> 等也属于私有地址</li><li><code>link local</code> 地址: 属于连接本地地址，在单独网段可用</li><li><code>UP BROADCAST RUNNING MULTICAST</code> 地址：如果网卡信息中包含 <code>UP BROADCAST RUNNING MULTICAST</code>，则支持广播和组播</li><li>除此之外的地址都是点对点可用的刚开的 <code>IPv4</code> 地址</li></ul><p>刚才提到的 <code>InetAddress.getLocalHost().getHostAddress()</code> 一般情况下只会在如下两种情况中返回正确结果：</p><ol><li>只使用 <code>wifi</code></li><li>只使用网线</li></ol><p>而在复杂环境下，获取 IP 地址最好能够遍历所有的网卡，然后依次筛选，最终找到符合条件的网卡的 IP：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getLocalHostLANAddress</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InetAddress candidateAddress = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历所有网络接口</span></span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        <span class="keyword">while</span> (networkInterfaces.hasMoreElements()) &#123;</span><br><span class="line">            NetworkInterface networkInterface = networkInterfaces.nextElement();</span><br><span class="line">            <span class="comment">// 在所有的接口下再遍历 IP</span></span><br><span class="line">            Enumeration&lt;InetAddress&gt; inetAddresses = networkInterface.getInetAddresses();</span><br><span class="line">            <span class="keyword">while</span> (inetAddresses.hasMoreElements()) &#123;</span><br><span class="line">                InetAddress inetAddress = inetAddresses.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (!inetAddress.isLoopbackAddress()) &#123;</span><br><span class="line">                    <span class="comment">// 排除 loopback 类型地址</span></span><br><span class="line">                    <span class="keyword">if</span> (inetAddress.isSiteLocalAddress()) &#123;</span><br><span class="line">                        <span class="comment">// 如果是 site-local 地址，直接返回</span></span><br><span class="line">                        <span class="keyword">return</span> inetAddress;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果是 site-local 地址未被发现，先记录候选地址</span></span><br><span class="line">                        candidateAddress = inetAddress;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (candidateAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> candidateAddress;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.err.println(<span class="string">"获取本机 IP 失败"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-注册服务-IP-解析异常&quot;&gt;&lt;a href=&quot;#2-注册服务-IP-解析异常&quot; class=&quot;headerlink&quot; title=&quot;2. 注册服务 IP 解析异常&quot;&gt;&lt;/a&gt;2. 注册服务 IP 解析异常&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;在使用 dubbo 注册
      
    
    </summary>
    
      <category term="dubbo" scheme="https://destinywang.github.io/blog/categories/dubbo/"/>
    
    
      <category term="踩坑总结" scheme="https://destinywang.github.io/blog/tags/%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    
      <category term="dubbo" scheme="https://destinywang.github.io/blog/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Lucene(二) —— 搭建简易搜索引擎</title>
    <link href="https://destinywang.github.io/blog/2018/05/07/Lucene-%E4%BA%8C-%E2%80%94%E2%80%94-%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    <id>https://destinywang.github.io/blog/2018/05/07/Lucene-二-——-搭建简易搜索引擎/</id>
    <published>2018-05-07T13:08:45.000Z</published>
    <updated>2018-05-07T13:09:48.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h1><h2 id="1-1-爬取数据"><a href="#1-1-爬取数据" class="headerlink" title="1.1 爬取数据"></a>1.1 爬取数据</h2><ul><li>爬取网站数据，为实现搜索引擎做准备</li><li><code>wget -o /tmp/wget.log -P /root/data --no-parent --no-verbose -m -D destiny -N --convert-links --random-wait -A html,HTML https://destinywang.github.io/blog/</code></li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-6/96451093.jpg" alt=""></p><p>将 <a href="https://destinywang.github.io/blog/">本人个人博客</a> 爬取的结果为：</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-6/16891715.jpg" alt=""></p><p>放在浏览器中展示的效果为：</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-6/24255196.jpg" alt=""></p><p>在 html 文件中，实际的文件格式如下图所示：</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-6/56955141.jpg" alt=""></p><p>以此类推，可以多爬几个 HTML 文件。</p><h2 id="1-2-HTML-parser"><a href="#1-2-HTML-parser" class="headerlink" title="1.2 HTML parser"></a>1.2 HTML parser</h2><p>在搜索中，我们往往更关注文字部分，而对于 HTML 标签最好能够予以过滤，为此，我们使用 <code>jericho</code> 进行 HTML 过滤</p><p>添加依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/net.htmlparser.jericho/jericho-html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.htmlparser.jericho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jericho-html<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="1-3-IKAnalyzer-中文分词器"><a href="#1-3-IKAnalyzer-中文分词器" class="headerlink" title="1.3 IKAnalyzer 中文分词器"></a>1.3 IKAnalyzer 中文分词器</h2><p>之前的示例中，使用的是默认的StandardAnalyzer分词器，不能有效的进行中文分词，下面演示下如何在Lucene5.0中使用IKAnalyzer分词器。</p><p>首先下载IKAnalyzer分词器源码，IKAnalyzer分词器源码托管在<a href="http://git.oschina.net/wltea/IK-Analyzer-2012FF" target="_blank" rel="noopener">OSChina</a></p><p>不过目前项目已经停止更新了，<code>IKAnalyzer</code> 由于已经停止更新，所以并不支持 <code>Lucene5</code>，这里需要对源码做一些修改，否则启动时会抛出如下异常：<br><img src="http://oetw0yrii.bkt.clouddn.com/18-5-7/95267985.jpg" alt=""></p><h3 id="1-3-1-下载-IKAnalyzer-源码并打开"><a href="#1-3-1-下载-IKAnalyzer-源码并打开" class="headerlink" title="1.3.1 下载 IKAnalyzer 源码并打开"></a>1.3.1 下载 IKAnalyzer 源码并打开</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@gitee.com:wltea/IK-Analyzer-<span class="number">2012</span>FF.git</span><br></pre></td></tr></table></figure><p>然后在 IDE 中打开</p><h3 id="1-3-2-修改-IKAnalyzer-源码"><a href="#1-3-2-修改-IKAnalyzer-源码" class="headerlink" title="1.3.2 修改 IKAnalyzer 源码"></a>1.3.2 修改 IKAnalyzer 源码</h3><pre><code>由于Lucene5.0 API上有些变化，我们需要对IK源码做些修改</code></pre><h4 id="1-3-2-1-IKTokenizer-类"><a href="#1-3-2-1-IKTokenizer-类" class="headerlink" title="1.3.2.1 IKTokenizer 类"></a>1.3.2.1 IKTokenizer 类</h4><pre><code>第一处需要修改的就是IKTokenizer类，在其构造函数里把//super(in);这句注释掉即可</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * IK 中文分词  版本 5.0.1 </span></span><br><span class="line"><span class="comment"> * IK Analyzer release 5.0.1 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one or more </span></span><br><span class="line"><span class="comment"> * contributor license agreements.  See the NOTICE file distributed with </span></span><br><span class="line"><span class="comment"> * this work for additional information regarding copyright ownership. </span></span><br><span class="line"><span class="comment"> * The ASF licenses this file to You under the Apache License, Version 2.0 </span></span><br><span class="line"><span class="comment"> * (the "License"); you may not use this file except in compliance with </span></span><br><span class="line"><span class="comment"> * the License.  You may obtain a copy of the License at </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software </span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS, </span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. </span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and </span></span><br><span class="line"><span class="comment"> * limitations under the License. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 源代码由林良益(linliangyi2005@gmail.com)提供 </span></span><br><span class="line"><span class="comment"> * 版权声明 2012，乌龙茶工作室 </span></span><br><span class="line"><span class="comment"> * provided by Linliangyi and copyright 2012 by Oolong studio </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">package</span> org.wltea.analyzer.lucene;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.Reader;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Tokenizer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.CharTermAttribute;  </span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.OffsetAttribute;  </span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.TypeAttribute;  </span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.util.Version;  </span><br><span class="line"><span class="keyword">import</span> org.wltea.analyzer.core.IKSegmenter;  </span><br><span class="line"><span class="keyword">import</span> org.wltea.analyzer.core.Lexeme;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * IK分词器 Lucene Tokenizer适配器类 </span></span><br><span class="line"><span class="comment"> * 兼容Lucene 4.0版本 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IKTokenizer</span> <span class="keyword">extends</span> <span class="title">Tokenizer</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//IK分词器实现  </span></span><br><span class="line">    <span class="keyword">private</span> IKSegmenter _IKImplement;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//词元文本属性  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CharTermAttribute termAtt;  </span><br><span class="line">    <span class="comment">//词元位移属性  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OffsetAttribute offsetAtt;  </span><br><span class="line">    <span class="comment">//词元分类属性（该属性分类参考org.wltea.analyzer.core.Lexeme中的分类常量）  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeAttribute typeAtt;  </span><br><span class="line">    <span class="comment">//记录最后一个词元的结束位置  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> endPosition;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> Version version = Version.LATEST;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Lucene 4.0 Tokenizer适配器类构造函数 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useSmart </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IKTokenizer</span><span class="params">(Reader in , <span class="keyword">boolean</span> useSmart)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//super(in);  </span></span><br><span class="line">        offsetAtt = addAttribute(OffsetAttribute.class);  </span><br><span class="line">        termAtt = addAttribute(CharTermAttribute.class);  </span><br><span class="line">        typeAtt = addAttribute(TypeAttribute.class);  </span><br><span class="line">        _IKImplement = <span class="keyword">new</span> IKSegmenter(input , useSmart);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* (non-Javadoc) </span></span><br><span class="line"><span class="comment">     * @see org.apache.lucene.analysis.TokenStream#incrementToken() </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">incrementToken</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        <span class="comment">//清除所有的词元属性  </span></span><br><span class="line">        clearAttributes();  </span><br><span class="line">        Lexeme nextLexeme = _IKImplement.next();  </span><br><span class="line">        <span class="keyword">if</span>(nextLexeme != <span class="keyword">null</span>)&#123;  </span><br><span class="line">            <span class="comment">//将Lexeme转成Attributes  </span></span><br><span class="line">            <span class="comment">//设置词元文本  </span></span><br><span class="line">            termAtt.append(nextLexeme.getLexemeText());  </span><br><span class="line">            <span class="comment">//设置词元长度  </span></span><br><span class="line">            termAtt.setLength(nextLexeme.getLength());  </span><br><span class="line">            <span class="comment">//设置词元位移  </span></span><br><span class="line">            offsetAtt.setOffset(nextLexeme.getBeginPosition(), nextLexeme.getEndPosition());  </span><br><span class="line">            <span class="comment">//记录分词的最后位置  </span></span><br><span class="line">            endPosition = nextLexeme.getEndPosition();  </span><br><span class="line">            <span class="comment">//记录词元分类  </span></span><br><span class="line">            typeAtt.setType(nextLexeme.getLexemeTypeString());            </span><br><span class="line">            <span class="comment">//返会true告知还有下个词元  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//返会false告知词元输出完毕  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * (non-Javadoc) </span></span><br><span class="line"><span class="comment">     * @see org.apache.lucene.analysis.Tokenizer#reset(java.io.Reader) </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.reset();  </span><br><span class="line">        _IKImplement.reset(input);  </span><br><span class="line">    &#125;     </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// set final offset  </span></span><br><span class="line">        <span class="keyword">int</span> finalOffset = correctOffset(<span class="keyword">this</span>.endPosition);  </span><br><span class="line">        offsetAtt.setOffset(finalOffset, finalOffset);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-2-IKAnalyzer"><a href="#1-3-2-2-IKAnalyzer" class="headerlink" title="1.3.2.2 IKAnalyzer"></a>1.3.2.2 IKAnalyzer</h4><pre><code>createComponents()方法是继承Luecene的Analyzer接口的由于Lucene5.0里把createComponents()方法的第二个参数去掉了所以需要对该方法做同样的修改</code></pre><p>而上文中真正抛出异常的地方也在于此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 重载Analyzer接口，构造分词组件 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> TokenStreamComponents <span class="title">createComponents</span><span class="params">(String text)</span> </span>&#123;  </span><br><span class="line">    Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(text));  </span><br><span class="line">    Tokenizer _IKTokenizer = <span class="keyword">new</span> IKTokenizer(reader , <span class="keyword">this</span>.useSmart());  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TokenStreamComponents(_IKTokenizer);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-将依赖安装到本地仓库"><a href="#1-3-3-将依赖安装到本地仓库" class="headerlink" title="1.3.3 将依赖安装到本地仓库"></a>1.3.3 将依赖安装到本地仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn install:install-file -DgroupId=org.wltea.analyzer -DartifactId=IKAnalyzer -Dversion=5.0 -Dpackaging=jar -Dfile=/User/destiny/.m2/repository/IKAnalyzer-5.0.jar</span><br></pre></td></tr></table></figure><h3 id="1-3-4-导入依赖"><a href="#1-3-4-导入依赖" class="headerlink" title="1.3.4 导入依赖"></a>1.3.4 导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.wltea.analyzer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>IKAnalyzer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-核心代码"><a href="#2-核心代码" class="headerlink" title="2. 核心代码"></a>2. 核心代码</h1><h2 id="2-1-HTML-对象"><a href="#2-1-HTML-对象" class="headerlink" title="2.1 HTML 对象"></a>2.1 HTML 对象</h2><p>在搜索结果中，返回给用户的主要信息包括：</p><ul><li>文档标题</li><li>文档正文（缩略信息）</li><li>URL</li></ul><p>所以对应的实体类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;       <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">private</span> String content;     <span class="comment">// 正文</span></span><br><span class="line">    <span class="keyword">private</span> String url;         <span class="comment">// URL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-HTML-转换对象"><a href="#2-2-HTML-转换对象" class="headerlink" title="2.2 HTML 转换对象"></a>2.2 HTML 转换对象</h2><p>由于爬取的原始数据中，HTML 正文含有大量的标签，对搜索而言没有意义，因此使用 <code>jericho</code> 进行过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlBeanUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件转换为 HtmlBean 页面对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HtmlBean <span class="title">parseHtml</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解析 HTML</span></span><br><span class="line">        HtmlBean htmlBean = <span class="keyword">new</span> HtmlBean();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Source source = <span class="keyword">new</span> Source(file);</span><br><span class="line">            <span class="comment">// 取第一个标题元素</span></span><br><span class="line">            Element firstElement = source.getFirstElement(HTMLElementName.TITLE);</span><br><span class="line"></span><br><span class="line">            htmlBean.setTitle(firstElement.getTextExtractor().toString());</span><br><span class="line">            htmlBean.setContent(source.getTextExtractor().toString());</span><br><span class="line">            htmlBean.setUrl(<span class="string">"http://"</span> + file.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> htmlBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-创建索引"><a href="#2-3-创建索引" class="headerlink" title="2.3 创建索引"></a>2.3 创建索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuceneService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_DIR = <span class="string">"/Users/destiny/IdeaProjects/lucene-demo/src/main/resources/index"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_DIR = <span class="string">"/Users/destiny/IdeaProjects/lucene-demo/src/main/resources/html"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 目录对象，需要由 Path 进行初始化</span></span><br><span class="line">            Directory directory = FSDirectory.open(Paths.get(INDEX_DIR));</span><br><span class="line">            <span class="comment">// 创建分词器</span></span><br><span class="line">            Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">            <span class="comment">// 由分词器对 IndexWriterConfig 进行初始化</span></span><br><span class="line">            IndexWriterConfig indexWriterConfig = <span class="keyword">new</span> IndexWriterConfig(analyzer);</span><br><span class="line">            indexWriterConfig.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);</span><br><span class="line">            IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, indexWriterConfig);</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(DATA_DIR);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 用递归的方式获取指定路径的文件列表(org.apache.commons.io)</span></span><br><span class="line">            Collection&lt;File&gt; files = FileUtils.listFiles(file, TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将每个文件转换成 Document 对象</span></span><br><span class="line">            <span class="keyword">for</span> (File file1 : files) &#123;</span><br><span class="line">                System.out.println(<span class="string">"file: "</span> + file1.getName());</span><br><span class="line">                HtmlBean htmlBean = HtmlBeanUtil.parseHtml(file1);</span><br><span class="line">                Document document = <span class="keyword">new</span> Document();</span><br><span class="line">                document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, htmlBean.getTitle(), Field.Store.YES));</span><br><span class="line">                document.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, htmlBean.getContent(), Field.Store.YES));</span><br><span class="line">                document.add(<span class="keyword">new</span> StringField(<span class="string">"url"</span>, htmlBean.getUrl(), Field.Store.YES));</span><br><span class="line">                indexWriter.addDocument(document);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            indexWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-搜索"><a href="#2-4-搜索" class="headerlink" title="2.4 搜索"></a>2.4 搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/search/&#123;keyword&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;HtmlBean&gt; <span class="title">search</span><span class="params">(@PathVariable(value = <span class="string">"keyword"</span>)</span> String keyword) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Directory directory = FSDirectory.open(Paths.get(INDEX_DIR));</span><br><span class="line">        IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line">        <span class="comment">// 创建中文分词器</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> IKAnalyzer();</span><br><span class="line">        <span class="comment">// 多 field 查询</span></span><br><span class="line">        MultiFieldQueryParser multiFieldQueryParser = <span class="keyword">new</span> MultiFieldQueryParser(<span class="keyword">new</span> String[]&#123;<span class="string">"title"</span>, <span class="string">"content"</span>&#125;, analyzer);</span><br><span class="line">        Query query = multiFieldQueryParser.parse(keyword);</span><br><span class="line">        <span class="comment">// 搜索前 10 个匹配度最高的文档</span></span><br><span class="line">        TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装查询结果</span></span><br><span class="line">        List&lt;HtmlBean&gt; htmlBeanList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line">            <span class="keyword">int</span> docId = scoreDoc.doc;</span><br><span class="line">            Document document = indexReader.document(docId);</span><br><span class="line">            HtmlBean htmlBean = <span class="keyword">new</span> HtmlBean();</span><br><span class="line">            htmlBean.setTitle(document.get(<span class="string">"title"</span>));</span><br><span class="line">            htmlBean.setContent(document.get(<span class="string">"content"</span>));</span><br><span class="line">            htmlBean.setUrl(document.get(<span class="string">"url"</span>));</span><br><span class="line">            htmlBeanList.add(htmlBean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> htmlBeanList;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-使用结果"><a href="#3-使用结果" class="headerlink" title="3. 使用结果"></a>3. 使用结果</h1><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-7/55592553.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前期准备&quot;&gt;&lt;a href=&quot;#1-前期准备&quot; class=&quot;headerlink&quot; title=&quot;1. 前期准备&quot;&gt;&lt;/a&gt;1. 前期准备&lt;/h1&gt;&lt;h2 id=&quot;1-1-爬取数据&quot;&gt;&lt;a href=&quot;#1-1-爬取数据&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Luence" scheme="https://destinywang.github.io/blog/categories/Luence/"/>
    
    
      <category term="Lucene" scheme="https://destinywang.github.io/blog/tags/Lucene/"/>
    
      <category term="搜索引擎" scheme="https://destinywang.github.io/blog/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Lucene(一) —— 快速入门</title>
    <link href="https://destinywang.github.io/blog/2018/05/05/Lucene-%E4%B8%80-%E2%80%94%E2%80%94-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://destinywang.github.io/blog/2018/05/05/Lucene-一-——-快速入门/</id>
    <published>2018-05-04T16:01:42.000Z</published>
    <updated>2018-05-05T16:30:57.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-搜索引擎组件"><a href="#1-搜索引擎组件" class="headerlink" title="1. 搜索引擎组件"></a>1. 搜索引擎组件</h1><h2 id="1-1-索引组件"><a href="#1-1-索引组件" class="headerlink" title="1.1 索引组件"></a>1.1 索引组件</h2><pre><code>为了快速搜索大量的文本，必须针对文本建立索引，将文本内容转换成能够进行快速搜索的格式。这个过程就叫做索引操作(indexing)，输出就是索引(index)</code></pre><h3 id="1-1-1-获取内容"><a href="#1-1-1-获取内容" class="headerlink" title="1.1.1 获取内容"></a>1.1.1 获取内容</h3><p>使用网络爬虫或者蜘蛛程序来搜索和界定需要索引的内容。</p><h3 id="1-1-2-建立文档"><a href="#1-1-2-建立文档" class="headerlink" title="1.1.2 建立文档"></a>1.1.2 建立文档</h3><p>获取原始内容之后，就需要对内容进行索引，首先必须将内容转换成<strong>文档</strong>，以供搜索引擎使用。</p><p>文档主要包括几个带值的域，比如<code>标题</code>、<code>正文</code>、<code>摘要</code>、<code>作者</code>和<code>链接(URL)</code>。</p><p>然后需要将原始内容中的文本提取出来写入各个文档。</p><h3 id="1-1-3-文档分析"><a href="#1-1-3-文档分析" class="headerlink" title="1.1.3 文档分析"></a>1.1.3 文档分析</h3><p>搜索引擎不能直接对文本进行索引，而必须将文本分割成一系列被称为 <code>词汇单元</code> 的独立原子元素。</p><p>这一步骤决定文档中的文本域如何分割成 <code>词汇单元</code> 系列。</p><p>Lucene 提供了大量内嵌的分析器能够轻松完成这步操作。</p><h3 id="1-1-4-文档索引"><a href="#1-1-4-文档索引" class="headerlink" title="1.1.4 文档索引"></a>1.1.4 文档索引</h3><p>在本步骤中，文档将被加入到索引列表。</p><h2 id="1-2-搜索组件"><a href="#1-2-搜索组件" class="headerlink" title="1.2 搜索组件"></a>1.2 搜索组件</h2><pre><code>搜索处理过程就是从索引中查找单词，从而找到包含该单词的文档。</code></pre><h3 id="1-2-1-建立查询"><a href="#1-2-1-建立查询" class="headerlink" title="1.2.1 建立查询"></a>1.2.1 建立查询</h3><p>搜索请求会被转换成搜索引擎使用的 <code>查询(query)</code> 对象格式。</p><p>查询对象可能很简单，也可能很复杂。 Lucene 提供了一个称之为 <code>查询解析器(QueryParser)</code> 的强大开发包，用它可以根据通用查询语法将用户输入的文本处理成查询对象。<br>查询语句可以包含 布尔运算、短语查询或通配符查询。</p><h3 id="1-2-2-搜索查询"><a href="#1-2-2-搜索查询" class="headerlink" title="1.2.2 搜索查询"></a>1.2.2 搜索查询</h3><pre><code>查询检索索引并返回与查询语句匹配的文档，结果返回时按照查询请求来排序</code></pre><p>常见的搜索理论模型：</p><ol><li>纯布尔模型：文档不管是否匹配查询请求，都不会被评分，匹配文档与评分不相关，一条查询仅获取所有匹配文档集合的一个子集。</li><li>向量空间模型：查询语句和文档都是高维空间的向量模型，这里每一个独立的项都是一个维度，查询语句和文档之间的相关性或相似性由各个向量之间的距离计算得到。</li><li>概率模型：采用全概率的方法来计算文档和查询语句匹配的概率。</li></ol><p>Lucene 采用了 <code>空间向量模型</code>和<code>纯布尔模型</code>。</p><h1 id="2-核心技术"><a href="#2-核心技术" class="headerlink" title="2. 核心技术"></a>2. 核心技术</h1><pre><code>Lucene 是一个全文搜索框架</code></pre><ul><li>倒排索引</li><li>压缩算法</li><li>二元搜索</li></ul><h2 id="2-1-倒排索引"><a href="#2-1-倒排索引" class="headerlink" title="2.1 倒排索引"></a>2.1 倒排索引</h2><ul><li>根据属性的值来查找记录，这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性，而是由属性值来确定记录的位置，因而成为倒排索引。</li><li>单词——文档矩阵<br><img src="http://oetw0yrii.bkt.clouddn.com/18-5-4/72395859.jpg" alt=""></li></ul><h1 id="3-Lucene-的工作方法"><a href="#3-Lucene-的工作方法" class="headerlink" title="3. Lucene 的工作方法"></a>3. Lucene 的工作方法</h1><pre><code>Lucene 提供的服务实际包含两部分，一入一出：入就是写入，将提供的源（本质上是字符串）写入索引或者将其从索引中删除；出就是读取，向用户提供全文搜索服务，让用户可以通过关键词定位源。</code></pre><ul><li>写入：源字符首先经过 <code>analyzer</code> 处理，包括：分词，拆分成一个个单词；去除 <code>stopword</code> 。将源中需要的信息加入 <code>Document</code> 的各个 <code>Field</code> 中，并把需要索引的 <code>Field</code> 索引起来，把需要存储的 <code>Field</code> 存储起来。</li><li>读取：用户提供关键词，经过 <code>analyzer</code> 处理，对处理后的关键词搜索索引，找出对应的 <code>Document</code>。用户根据需要从找到的 <code>Document</code> 中提取出需要的 <code>Field</code>。</li></ul><blockquote><p>document：用户提供的源是一条条记录，它们可以是文本文件、字符串或者数据库表的一条记录等等。一条记录经过索引之后，就是以一个 <code>Document</code> 的形式存储在索引文件中的。用户进行搜索，也是以 <code>Document</code> 列表的形式返回。</p></blockquote><blockquote><p>field：一个 <code>Document</code> 可以包含多个信息域，例如一篇文章可以包括标题、正文、最后修改时间等信息域，这些信息域是通过 <code>Field</code> 在 <code>Document</code> 中存储的。<br><code>Field</code> 有两个属性可选：存储和索引。通过存储属性，可以控制是否对这个 <code>Field</code> 进行索引。</p></blockquote><h1 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h1><h2 id="4-1-导入依赖"><a href="#4-1-导入依赖" class="headerlink" title="4.1 导入依赖"></a>4.1 导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- lucene --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queries<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queryparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-highlighter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- apache-common --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-环境准备"><a href="#4-2-环境准备" class="headerlink" title="4.2 环境准备"></a>4.2 环境准备</h2><p>准备 <code>index</code> 和 <code>data</code> 两个目录，分别用于存放索引和文档<br><img src="http://oetw0yrii.bkt.clouddn.com/18-5-4/79601259.jpg" alt=""></p><ul><li><code>data</code> 随便从其他项目中复制了几个 <code>LICENSE</code></li><li><code>index</code> 保持为空，当 Lucene 运行的时候会自动进行创建</li></ul><h2 id="4-3-创建索引"><a href="#4-3-创建索引" class="headerlink" title="4.3 创建索引"></a>4.3 创建索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 索引目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_DIR = <span class="string">"/Users/destiny/IdeaProjects/lucene-demo/src/main/resources/index"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 文本目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_DIR = <span class="string">"/Users/destiny/IdeaProjects/lucene-demo/src/main/resources/data"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 目录对象，描述了索引的存放位置，需要由 Path 进行初始化</span></span><br><span class="line">        Directory directory = FSDirectory.open(Paths.get(INDEX_DIR));</span><br><span class="line">        <span class="comment">// 创建分词器</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">        <span class="comment">// 由分词器对 IndexWriterConfig 进行初始化</span></span><br><span class="line">        IndexWriterConfig indexWriterConfig = <span class="keyword">new</span> IndexWriterConfig(analyzer);</span><br><span class="line">        indexWriterConfig.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);</span><br><span class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, indexWriterConfig);</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(DATA_DIR);</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取并遍历文本路径下的所有文件，用于生成文档及其索引</span></span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">// 创建文档</span></span><br><span class="line">                Document document = <span class="keyword">new</span> Document();</span><br><span class="line">                <span class="comment">// 为文档设置 Field</span></span><br><span class="line">                document.add(<span class="keyword">new</span> StringField(<span class="string">"filename"</span>, f.getName(), Field.Store.YES));</span><br><span class="line">                document.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, FileUtils.readFileToString(f, Charset.defaultCharset()), Field.Store.YES));</span><br><span class="line">                document.add(<span class="keyword">new</span> LongField(<span class="string">"lastModify"</span>, f.lastModified(), Field.Store.YES));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写入索引</span></span><br><span class="line">                indexWriter.addDocument(document);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        indexWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        CreateIndex createIndex = <span class="keyword">new</span> CreateIndex();</span><br><span class="line">        createIndex.createIndex();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行完毕之后，发现 <code>index</code> 路径下多了一些文件，即为文档的索引。  </p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-4/71134605.jpg" alt=""></p><h2 id="4-4-查询索引"><a href="#4-4-查询索引" class="headerlink" title="4.4 查询索引"></a>4.4 查询索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开索引所在路径</span></span><br><span class="line">        Directory directory = FSDirectory.open(Paths.get(CreateIndex.INDEX_DIR));</span><br><span class="line">        IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line"></span><br><span class="line">        QueryParser queryParser = <span class="keyword">new</span> QueryParser(<span class="string">"content"</span>, <span class="keyword">new</span> StandardAnalyzer());</span><br><span class="line">        Query query = queryParser.parse(<span class="string">"from"</span>);</span><br><span class="line">        <span class="comment">// 找到符合条件的前 10 条 Document 的索引的集合</span></span><br><span class="line">        TopDocs search = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历集合并打印文件名称</span></span><br><span class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : search.scoreDocs) &#123;</span><br><span class="line">            <span class="keyword">int</span> docId = scoreDoc.doc;</span><br><span class="line">            Document document = indexReader.document(docId);</span><br><span class="line">            String filename = document.get(<span class="string">"filename"</span>);</span><br><span class="line">            System.out.println(<span class="string">"filename: "</span> + filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">        SearchIndex searchIndex = <span class="keyword">new</span> SearchIndex();</span><br><span class="line">        searchIndex.search();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询结果：</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-4/42921719.jpg" alt=""></p><h1 id="5-理解索引过程核心类"><a href="#5-理解索引过程核心类" class="headerlink" title="5. 理解索引过程核心类"></a>5. 理解索引过程核心类</h1><p>执行简单的索引过程需要用到以下几个类：</p><ul><li>IndexWriter</li><li>Directory</li><li>Analyzer</li><li>Document</li><li>Field</li></ul><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-5/99307359.jpg" alt=""></p><h2 id="5-1-IndexWriter"><a href="#5-1-IndexWriter" class="headerlink" title="5.1 IndexWriter"></a>5.1 IndexWriter</h2><p>IndexWriter(写索引)是索引过程的核心组件，这个类负责创建新索引或者打开已有索引，以及向索引中添加、删除或者是更新被索引文档的信息。为开发者提供针对索引文件的写入操作，但不能用于读取或者搜索索引。IndexWriter 需要开辟一定的空间用来存储索引，该功能可以由 Directory 完成。</p><h2 id="5-2-Directory"><a href="#5-2-Directory" class="headerlink" title="5.2 Directory"></a>5.2 Directory</h2><p>Directory 描述了 Lucene 索引存放的位置。它是一个抽象类，其实现类负责具体指定索引的存储路径。在上面的例子中，我们使用 <code>FSDirectory.open()</code> 方法来获取真实文件在文件系统中的存储路径，然后将她们依次传递给 <code>IndexWriter</code> 类的构造方法。</p><p>IndexWriter 不能直接索引文本，需要先由 <code>Analyzer</code> 将文本分割成独立的单词才行。</p><h2 id="5-3-Analyzer"><a href="#5-3-Analyzer" class="headerlink" title="5.3 Analyzer"></a>5.3 Analyzer</h2><p>文本文件在被索引之前，需要经过 Analyzer 处理，Analyzer 由 IndexWriter 的构造方法来指定，负责从被索引文本文件中提取词汇单元，并剔除剩下的无用信息。如果被索引的内容不是纯文本文件，那就需要先将其转换成文本文档。</p><p>Analyzer 是一个抽象类，其实现类中：</p><ul><li>有的用于跳过停用词（指一些常用且不能帮助区分文档的词，如a、an、the、in 和 on 等）</li><li>有的用于把词汇转换成小写，以使得搜索过程不区分大小写</li><li>等等</li></ul><p>分析器的分析对象为文档。</p><h2 id="5-4-Document"><a href="#5-4-Document" class="headerlink" title="5.4 Document"></a>5.4 Document</h2><p>Document 代表一些 <code>域(Field)</code> 的集合，可以将 Document 理解为虚拟文档，如 Web页面、邮件信息等。文档的域代表文档或者文档相关的一些元数据。</p><p>Lucene 只处理文本和数字，Lucene 的内核本身只处理 <code>java.lang.String</code> 和 <code>java.io.Reader</code> 对象和本地数字类型</p><p>Document 对象的结构比较简单，为一个多个 Field 对象的容器， Field 是指包含能被索引的文本内容的类。</p><h2 id="5-5-Field"><a href="#5-5-Field" class="headerlink" title="5.5 Field"></a>5.5 Field</h2><p>索引中，每个文档都包含一个或者多个不同命名的域，这些域包含在 Field 类中。</p><p>每个域都有一个域名和对应的值，以及一组选项来精确控制 Lucene 索引操作各个域值。</p><h1 id="6-理解搜索过程核心类"><a href="#6-理解搜索过程核心类" class="headerlink" title="6. 理解搜索过程核心类"></a>6. 理解搜索过程核心类</h1><p>核心类：</p><ul><li>IndexSearcher</li><li>Term</li><li>Query</li><li>TermQuery</li><li>TocDocs</li></ul><h2 id="6-1-IndexSearcher"><a href="#6-1-IndexSearcher" class="headerlink" title="6.1 IndexSearcher"></a>6.1 IndexSearcher</h2><p>用于搜索 IndexWriter 所创建的索引，可以将它看做一个以只读方式打开索引的类。</p><p>它需要利用 Directory 实例来掌握前期创建的索引，然后才能提供大量的搜索方法，最简单的搜索方法是将单个 <code>Query</code> 对象和 <code>int topN</code> 所谓该方法的参数，返回一个 <code>TopDocs</code> 对象。</p><h2 id="6-2-Term"><a href="#6-2-Term" class="headerlink" title="6.2 Term"></a>6.2 Term</h2><p>Term 是搜索功能的基本单元，与 Field 对象类似，Term 对象包含一对字符串元素：域名和单词，注意 Term 对象还与索引操作有关。</p><h2 id="6-3-Query"><a href="#6-3-Query" class="headerlink" title="6.3 Query"></a>6.3 Query</h2><p>Lucene 含有许多具体的 Query 子类</p><h2 id="6-4-TermQuery"><a href="#6-4-TermQuery" class="headerlink" title="6.4 TermQuery"></a>6.4 TermQuery</h2><p>是 Lucene 提供的最基本的查询类型，也是简单的查询类型之一，它用来匹配指定域中包含特定值的文档。</p><h2 id="6-5-TopDocs"><a href="#6-5-TopDocs" class="headerlink" title="6.5 TopDocs"></a>6.5 TopDocs</h2><p>TopDocs 类是一个简单的容器指针，指针一般指向前 N 个排名的搜索结果，搜索结果即匹配查询条件的文档。TopDocs 会记录前 N 个结果中每个结果的 <code>int docID</code> 和浮点型分数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-搜索引擎组件&quot;&gt;&lt;a href=&quot;#1-搜索引擎组件&quot; class=&quot;headerlink&quot; title=&quot;1. 搜索引擎组件&quot;&gt;&lt;/a&gt;1. 搜索引擎组件&lt;/h1&gt;&lt;h2 id=&quot;1-1-索引组件&quot;&gt;&lt;a href=&quot;#1-1-索引组件&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Luence" scheme="https://destinywang.github.io/blog/categories/Luence/"/>
    
    
      <category term="Luence" scheme="https://destinywang.github.io/blog/tags/Luence/"/>
    
  </entry>
  
  <entry>
    <title>quartz 入门</title>
    <link href="https://destinywang.github.io/blog/2018/04/25/quartz-%E5%85%A5%E9%97%A8/"/>
    <id>https://destinywang.github.io/blog/2018/04/25/quartz-入门/</id>
    <published>2018-04-25T14:33:08.000Z</published>
    <updated>2018-05-02T13:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-任务调度概述"><a href="#1-任务调度概述" class="headerlink" title="1. 任务调度概述"></a>1. 任务调度概述</h1><pre><code>各种企业应用几乎都会碰到任务调度的需求。在特定的时间点执行指定的操作。任务调度本身涉及多线程并发、运行时间规则指定和解析、运行现场保持和恢复、线程池维护等诸多方面的问题。</code></pre><h1 id="2-Quartz"><a href="#2-Quartz" class="headerlink" title="2. Quartz"></a>2. Quartz</h1><ul><li>Quartz允许开发人员灵活地定义触发器的调度时间，并可对触发器和任务进行关联映射；</li><li>Quartz提供了调度运行环境的持久化和保存；</li><li>Quartz还提供了组件式的侦听器、插件、线程池等功能。</li></ul><h2 id="2-1-Quartz基础结构"><a href="#2-1-Quartz基础结构" class="headerlink" title="2.1 Quartz基础结构"></a>2.1 Quartz基础结构</h2><p>Quartz对任务调度领域的问题进行了高度的抽象，提出了<code>调度器</code>、<code>任务</code>、<code>触发器</code>这3个核心的概念。</p><p><img src="https://upload-images.jianshu.io/upload_images/9124849-f11aeb994ba4a26b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/459" alt="image"></p><h3 id="2-1-1-Job"><a href="#2-1-1-Job" class="headerlink" title="2.1.1 Job"></a>2.1.1 Job</h3><p>是一个接口，只有一个方法<code>void execute(JobExecutionContext context)</code>，开发者通过实现该接口来定义需要执行的任务，<code>JobExecutionContext</code> 类提供了调度上下文的各种信息。<code>Job</code> 运行时的信息保存在 <code>JobDataMap</code> 实例中。</p><h3 id="2-1-2-JobDetail"><a href="#2-1-2-JobDetail" class="headerlink" title="2.1.2 JobDetail"></a>2.1.2 JobDetail</h3><p>Quartz 在每次执行 Job 的时候，都重新创建一个 Job 实例，所以它不是直接接收一个 Job 实例，而是接收一个 Job 实现类，以便运行时通过 <code>newInstance()</code> 反射调用机制实例化 Job。因此需要通过一个类来描述 Job 的实现类及其他相关信息，如 Job 名称、描述、关联监听器等信息，而 JobDetail 承担了这一角色。通过该类的构造函数 <code>JobDetail(java.lang.String name, java.lang.String group, java.lang.Class jobClass)</code>，可以更具体地了解它的功能。该构造函数要求指定 Job 的实现类，以及任务在 Schedule 中的组名和 Job 名称。</p><h3 id="2-1-3-Trigger"><a href="#2-1-3-Trigger" class="headerlink" title="2.1.3 Trigger"></a>2.1.3 Trigger</h3><p>描述触发 Job 执行的时间触发规则。主要有 <code>SimpleTrigger</code> 和 <code>CronTrigger</code> 这两个子类。当仅需要触发一次或者以固定间隔周期性执行的时候， <code>SimpleTrigger</code> 是最佳选择；而 <code>CronTrigger</code> 则可以通过 Cron 表达式定义出各种复杂的调度方案，如每天早上 <code>9:00</code> 执行，每周一、周三下午 <code>5:00</code> 执行等。</p><h3 id="2-1-4-Calendar"><a href="#2-1-4-Calendar" class="headerlink" title="2.1.4 Calendar"></a>2.1.4 Calendar</h3><p><code>org.quartz.Calendar</code> 和 <code>java.util.Calendar</code> 不同，它是一些日历特定时间点的集合。一个 Trigger 可以和多个 Calendar 关联，以便排除或包含某些时间点。假设安排每周一早晨 <code>10:00</code> 执行任务，但是如果遇到法定节假日不执行任务，这时就需要在 Trigger 触发机制的基础上使用 Calendar 进行定点排除。针对不同的时间段类型，如 <code>AnnualCalendar</code>、<code>MonthlyCalendar</code>、<code>WeeklyCalendar</code> 分别针对每年、每月和每周进行定义。</p><h3 id="2-1-5-Scheduler"><a href="#2-1-5-Scheduler" class="headerlink" title="2.1.5 Scheduler"></a>2.1.5 Scheduler</h3><p>代表一个 Quartz 的独立运行容器，Trigger 和 JobDetail 可以注册到 Scheduler 中，二者在 Scheduler 中拥有各自的组及名称。组及名称是 Scheduler 查找定位容器中某个对象的依据， Trigger 的组及明恒的组合必须唯一， JobDetail 的组及名称的组合也必须唯一（但可以和 Trigger 的组及名称相同，因为二者处在不同的容器中）。Scheduler 定义了多个接口方法，允许外部通过组及名称访问和控制容器中的 Trigger 和 JobDetail。Scheduler 可以将 Trigger 绑定到某一个 JobDetail 中，这样当 Trigger 被触发时，对应的 Job 就会被执行。一个 Job 可以对应多个 Trigger，但一个 Trigger 只能对应一个 Job。可以通过 SchedulerFactory 创建一个 Scheduler 实例。Scheduler 拥有一个 SchedulerContext，保存着 Scheduler 上下文信息，可以对照 ServletContext 来理解 SchedulerContext。 Job 和 Trigger 都可以访问 SchedulerContext 内的信息。SchedulerContext 内部通过一个 Map，以键值对的方式维护这些上下文数据。SchedulerContext 为保存和获取数据提供了多个 <code>put()</code> 和 <code>getXxx()</code> 方法。可以通过 <code>Scheduler#getContext()</code> 方法获取 SchedulerContext 实例。</p><h3 id="2-1-6-ThreadPool"><a href="#2-1-6-ThreadPool" class="headerlink" title="2.1.6 ThreadPool"></a>2.1.6 ThreadPool</h3><p>Schedule 使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程来提高效率。</p><p>Job 有一个 <code>StatefulJob</code> 子接口，代表有状态的任务。该接口是一个没有方法的标签接口，其目的是让 Quartz 知道任务类型，以便采取不同的措施。无状态任务在执行时拥有自己的 JobDataMap 复制，对 JobDataMap 的更改不会影响下次执行。而有状态任务共享同一个 JobDataMap 实例，每次任务执行时对 JobDataMap 所做的更改会保存下来。后面的执行可以看到更改。</p><p>因此，无状态任务可以并发执行，而有状态任务的 <code>StatefulJob</code> 不能并发执行。如果上一次的 StatefulJob 还没有执行完成，则下次的任务将阻塞等待。<br>有状态任务比无状态任务需要考虑更多的因素，所以尽量避免使用无状态任务。</p><p>如果 Quartz 使用了数据库持久化任务调度信息，则无状态的 JobDataMap 仅会在 Scheduler 注册的任务时保存一次，而有状态任务对应的 JobDataMap 在每次执行任务后都会进行保存。</p><p>Trigger 自身也可以拥有一个 JobDataMap，其关联的 JobDataMap 可以通过 <code>JobExecutionContext#getTrigger().getJobDataMap()</code> 方法获取。不管是有状态还是无状态的任务，在任务执行期间对 Trigger 的 JobDataMap 所做的更改都不会进行持久化。</p><p>Quartz 拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、执行后事件、触发器触发前事件、触发器触发后事件、调度器开始事件、调度器关闭事件等。可以注册相应的监听器处理感兴趣的事件。</p><h2 id="2-2-SimpleTrigger"><a href="#2-2-SimpleTrigger" class="headerlink" title="2.2 SimpleTrigger"></a>2.2 SimpleTrigger</h2><p>SimpleTrigger 有多个重载的构造函数，用于在不同场合下构造出对应的实例。</p><ul><li><code>SimpleTrigger(String name, String group)</code>：指定所属组和名称；</li><li><code>SimpleTrigger(String name, String group, Date startTime)</code>：指定触发的开始时间；</li><li><code>SimpleTrigger(String name, String group, Date startTime, Date endTime, int repeatCount, long repeatInterval)</code>：指定开始时间、结束时间、重复执行次数、时间间隔；</li><li><code>SimpleTrigger(String name, String group, String jobName, String jobGroup, Date startTime, Date endTime, int repeatCount, long repeatInterval)</code>：最复杂的一个构造函数，通过 jobName 和 jobGroup，使该 Trigger 和 Scheduler 中的某个任务关联起来。</li></ul><h3 id="2-2-1-代码实例"><a href="#2-2-1-代码实例" class="headerlink" title="2.2.1 代码实例"></a>2.2.1 代码实例</h3><hr><h4 id="2-2-1-1-SimpleJob"><a href="#2-2-1-1-SimpleJob" class="headerlink" title="2.2.1.1 SimpleJob"></a>2.2.1.1 SimpleJob</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(jobExecutionContext.getTrigger().getName() + <span class="string">" triggered. time is:"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-2-SimpleTriggerRunner"><a href="#2-2-1-2-SimpleTriggerRunner" class="headerlink" title="2.2.1.2 SimpleTriggerRunner"></a>2.2.1.2 <span id="SimpleTriggerRunner">SimpleTriggerRunner</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTriggerRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个 JobDetail 实例，指定 SimpleJob</span></span><br><span class="line">            JobDetail jobDetail = JobBuilder.newJob(SimpleJob.class)</span><br><span class="line">                    .withIdentity(<span class="string">"jName"</span>, <span class="string">"jGroup"</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 SimpleTrigger 定义调度规则：【立即启动】、【每2秒运行一次】、【用运行10次】</span></span><br><span class="line">            SimpleTrigger simpleTrigger = TriggerBuilder.newTrigger()</span><br><span class="line">                    .withIdentity(<span class="string">"tName"</span>, <span class="string">"tGroup"</span>)</span><br><span class="line">                    .startNow()</span><br><span class="line">                    .withSchedule(</span><br><span class="line">                            SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                                    .withIntervalInSeconds(<span class="number">2</span>)           <span class="comment">// 调度间隔</span></span><br><span class="line">                                    .withRepeatCount(<span class="number">10</span>)                <span class="comment">// 调度次数</span></span><br><span class="line">                    ).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 SchedulerFactory 获取一个调度器实例</span></span><br><span class="line">            SchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">            Scheduler scheduler = factory.getScheduler();</span><br><span class="line"></span><br><span class="line">            scheduler.scheduleJob(jobDetail, simpleTrigger);</span><br><span class="line">            scheduler.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-3-运行结果"><a href="#2-2-1-3-运行结果" class="headerlink" title="2.2.1.3 运行结果"></a>2.2.1.3 运行结果</h4><pre><code>tName1 triggered. time is:1524563336613tName1 triggered. time is:1524563338522tName1 triggered. time is:1524563340522tName1 triggered. time is:1524563342524tName1 triggered. time is:1524563344523tName1 triggered. time is:1524563346523tName1 triggered. time is:1524563348523tName1 triggered. time is:1524563350524tName1 triggered. time is:1524563352524tName1 triggered. time is:1524563354524tName1 triggered. time is:1524563356523</code></pre><h2 id="2-3-使用-CronTrigger"><a href="#2-3-使用-CronTrigger" class="headerlink" title="2.3 使用 CronTrigger"></a>2.3 使用 CronTrigger</h2><p>CronTrigger 能够提供比 SimpleTrigger 更有实际意义的调度方案，调度规则基于 <code>Cron表达式</code>。 CronTrigger 支持日历相关的周期性时间间隔（比如每月第一个周一执行），而不是简单的周期时间间隔。</p><h3 id="2-3-1-Cron-表达式"><a href="#2-3-1-Cron-表达式" class="headerlink" title="2.3.1 Cron 表达式"></a>2.3.1 Cron 表达式</h3><pre><code>Quartz 使用类似 Linux 下的 Cron 表达式定义时间规则。Cron 表达式由 6 或 7 个空格分割的时间字段组成。</code></pre><table><thead><tr><th style="text-align:center">位置</th><th>时间域名</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>秒</td><td>[0, 60)</td><td><code>,-*/</code></td></tr><tr><td style="text-align:center">2</td><td>分钟</td><td>[0, 60)</td><td><code>,-*/</code></td></tr><tr><td style="text-align:center">3</td><td>小时</td><td>[1, 24)</td><td><code>,-*/</code></td></tr><tr><td style="text-align:center">4</td><td>日期</td><td>[1, 32)</td><td><code>,-*?/LWC</code></td></tr><tr><td style="text-align:center">5</td><td>月份</td><td>[1, 13)</td><td><code>,-*/</code></td></tr><tr><td style="text-align:center">6</td><td>星期</td><td>[1, 8)</td><td><code>,-*/LC?#</code></td></tr><tr><td style="text-align:center">7</td><td>年（可选）</td><td>空值 或 [1970, 2100)</td><td><code>,-*/</code></td></tr></tbody></table><p>特殊字符：</p><table><thead><tr><th>特殊字符</th><th>作用</th></tr></thead><tbody><tr><td>*</td><td>表示对应时间域的每一个时刻，如 <code>*</code> 在分钟时段就表示每分钟</td></tr><tr><td>?</td><td>只能在日期和星期中使用，占位符，无意义</td></tr><tr><td>-</td><td>表达范围，如在小时中使用 <code>10-12</code>，表示从 10 点到 12 点</td></tr><tr><td>,</td><td>列表纸，如在星期中使用 <code>MON,WED,FRI</code>，表示周一、周三、周五</td></tr><tr><td>/</td><td><code>x/y</code> 表示等步长序列，x 为起始值，y 为增量步长，如在分钟中使用 <code>0/15</code>，表示0、15、30、45秒</td></tr><tr><td>L</td><td>只能在日期和星期中使用，代表 <code>Last</code> 的意思，日期中表示当月最后一天，星期表示周六</td></tr><tr><td>W</td><td>只能出现在日期中，是对前导日期的修饰，表示里该日期最近的工作日</td></tr><tr><td>LW</td><td>只能出现在日期中，表示当月最后一个工作日</td></tr><tr><td>#</td><td>只能在星期字段中使用，表示当月的某个工作日，<code>6#3</code>表示当月第三个周五，<code>4#5</code> 表示当月第五个周三，如果不存在则不触发</td></tr><tr><td>C</td><td>只能在日期和星期中使用，<code>Calendar</code>，表示计划所关联的日期。<code>5C</code> 在日期中相当于 <code>5日之后的那一天</code>，<code>1C</code> 在星期中相当于 <code>周天后的那一天</code></td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td><code>0 0 12 * * ?</code></td><td>每天 12:00 运行</td></tr><tr><td><code>0 15 10 ? * *</code></td><td>每天 10:15 运行</td></tr><tr><td><code>0 15 10 * * ?</code></td><td>每天 10:15 运行</td></tr><tr><td><code>0 15 10 * * ? *</code></td><td>每天 10:15 运行</td></tr><tr><td><code>0 15 10 * * ? 2008</code></td><td>在 2008 年的每天 10:15 运行</td></tr><tr><td><code>0 * 14 * * ?</code></td><td>每天 14 点到 15 点每分钟运行一次，开始于 14:00，结束于 14:59</td></tr><tr><td><code>0 0/5 14 * * ?</code></td><td>每天 14 点到 15 点每 5 分钟运行一次，开始于 14:00，结束语 14:55</td></tr><tr><td><code>0 0/5 14,18 * * ?</code></td><td>每天 14 点到 15 点每 5 分钟运行一次，此外每天 18 点到 19 点每 5 分钟也运行一次</td></tr><tr><td><code>0 10,44 14 ? 3 WED</code></td><td>3 月的每周三的 14:10 到 14:44，每分钟运行一次</td></tr><tr><td><code>0 15 10 ? * MON-FRI</code></td><td>每个工作日的 10:15 运行一次</td></tr><tr><td><code>0 15 10 15 * ?</code></td><td>每月 15 日的 10:15 运行一次</td></tr><tr><td><code>0 15 10 L * ?</code></td><td>每月最后一天的 10:15 运行一次</td></tr><tr><td><code>0 15 10 ? * 6L</code></td><td>每月的最后一个周五的 10:15 运行一次</td></tr><tr><td><code>0 15 10 ? * 6L 2014-2016</code></td><td>2014、2015、2016 年每个月的最后一个周五的 10:15 运行</td></tr><tr><td><code>0 15 10 ? * 6#3</code></td><td>每月第三个周五的 10: 15 运行</td></tr></tbody></table><h3 id="2-3-2-示例"><a href="#2-3-2-示例" class="headerlink" title="2.3.2 示例"></a>2.3.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CronTriggerRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JobDetail jobDetail = <span class="keyword">new</span> JobDetail(<span class="string">"jName1"</span>, <span class="string">"jGroup1"</span>, SimpleJob.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 CronTrigger 指定组及名称</span></span><br><span class="line">            CronTrigger cronTrigger = <span class="keyword">new</span> CronTrigger(<span class="string">"tName1"</span>, <span class="string">"tGroup1"</span>);</span><br><span class="line">            <span class="comment">// 新建并设置 Cron 表达式：从每分钟的 0 秒开始，每隔5秒触发一次</span></span><br><span class="line">            CronExpression cronExpression = <span class="keyword">new</span> CronExpression(<span class="string">"0/5 * * * * ?"</span>);</span><br><span class="line">            cronTrigger.setCronExpression(cronExpression);</span><br><span class="line"></span><br><span class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, cronTrigger);</span><br><span class="line">            scheduler.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-运行结果"><a href="#2-3-3-运行结果" class="headerlink" title="2.3.3 运行结果"></a>2.3.3 运行结果</h3><pre><code>tName1 triggered. time is:1524645830011tName1 triggered. time is:1524645835006tName1 triggered. time is:1524645840006tName1 triggered. time is:1524645845002tName1 triggered. time is:1524645850003tName1 triggered. time is:1524645855004tName1 triggered. time is:1524645860003tName1 triggered. time is:1524645865003tName1 triggered. time is:1524645870005tName1 triggered. time is:1524645875006tName1 triggered. time is:1524645880000tName1 triggered. time is:1524645885000tName1 triggered. time is:1524645890007tName1 triggered. time is:1524645895005tName1 triggered. time is:1524645900005</code></pre><p>由于打印的时间是以毫秒作为单位的，因此可以看毫秒数的倒数第4位，都是以 5 作为步长的。</p><h2 id="2-4-Calendar"><a href="#2-4-Calendar" class="headerlink" title="2.4 Calendar"></a>2.4 Calendar</h2><pre><code>在实际任务调度中，不可能一成不变地按照某个特定周期调度任务，必须考虑到现实生活中日历上的特殊日期。下面的例子中，该任务每小时运行一次，并将 五一劳动节 和 国庆节 排除在外</code></pre><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">        Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 法定节日是以年作为周期的，所以使用 AnnualCalendar</span></span><br><span class="line">        AnnualCalendar holidays = <span class="keyword">new</span> AnnualCalendar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 五一劳动节</span></span><br><span class="line">        Calendar laborDay = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">        laborDay.add(Calendar.MONTH, <span class="number">5</span>);</span><br><span class="line">        laborDay.add(Calendar.DATE, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 国庆节</span></span><br><span class="line">        Calendar nationalDay = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">        nationalDay.add(Calendar.MONTH, <span class="number">10</span>);</span><br><span class="line">        nationalDay.add(Calendar.DATE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Calendar&gt; calendarList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        calendarList.add(laborDay);</span><br><span class="line">        calendarList.add(nationalDay);</span><br><span class="line">        <span class="comment">// 排除这两个日期</span></span><br><span class="line">        holidays.setDaysExcluded(calendarList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向 Scheduler 注册日历</span></span><br><span class="line">        scheduler.addCalendar(<span class="string">"holidays"</span>, holidays, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4月1日上午10点</span></span><br><span class="line">        Date runDate = TriggerUtils.getDateOf(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        JobDetail jobDetail = <span class="keyword">new</span> JobDetail(<span class="string">"jName1"</span>, <span class="string">"jGroup1"</span>, SimpleJob.class);</span><br><span class="line">        SimpleTrigger trigger = <span class="keyword">new</span> SimpleTrigger(</span><br><span class="line">                <span class="string">"tName1"</span>, <span class="string">"tGroup1"</span>, runDate, <span class="keyword">null</span>, SimpleTrigger.REPEAT_INDEFINITELY, <span class="number">60L</span> * <span class="number">60L</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 让 Trigger 应用指定的日历规则</span></span><br><span class="line">        trigger.setCalendarName(<span class="string">"holidays"</span>);</span><br><span class="line">        </span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-任务调度信息存储"><a href="#2-5-任务调度信息存储" class="headerlink" title="2.5 任务调度信息存储"></a>2.5 任务调度信息存储</h2><p>在默认情况下，Quartz 将任务调度的运行信息保存在内存中。这种方法提供了最佳的性能，但缺乏持久性。</p><p>如果需要持久化任务调度信息，则 Quartz 允许用户通过调整其属性文件，将这些信息保存到数据库中。</p><h3 id="2-5-1-通过配置文件调整任务调度信息"><a href="#2-5-1-通过配置文件调整任务调度信息" class="headerlink" title="2.5.1 通过配置文件调整任务调度信息"></a>2.5.1 通过配置文件调整任务调度信息</h3><p>Quartz JAR 文件的 <code>org.quartz</code> 包含了一个 <code>quartz.properties</code> 属性配置文件，并提供了默认属性。可以通过在类路径下新建一个 <code>quartz.properties</code> 文件来覆盖默认配置。</p><pre><code># 集群的配置，这里不使用集群org.quartz.scheduler.instanceName = DefaultQuartzSchedulerorg.quartz.scheduler.rmi.export= falseorg.quartz.scheduler.warpJobExecutionInUserTransaction = false# 配置调度器的线程池org.quartz.threadPool.class = org.quartz.simple.SimpleThreadPoolorg.quartz.threadPool.threadCount = 10org.quartz.threadPool.threadPriority = 5org.quartz.threadPool.threadInheritContextClassLoaderOfInitializingThread # 配置任务调度现场数据保存机制org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore</code></pre><p>如果任务数目很大，则可以通过增大线程池获得更好的性能。</p><p>默认情况下，Quartz 采用 org.quartz.simpl.RAMJobStore 保存任务的现场数据，而通过以下设置可以将任务调度现场数据保存到数据库中</p><pre><code>org.quartz.jobStore.class = org.quratz.impl.jdbcjobstore.JobStoreTX# 数据库表前缀org.quartz.jobStore.tablePrefix = QRTZ_# 数据源名称org.quartz.jobStore.dataSource = qzDS# 定义数据源的具体属性org.quartz.dataSource.qzDS.driver = com.mysql.jdbc.Driverorg.quartz.dataSource.qzDS.URL = jdbc:mysql://localhost:3306/quartzorg.quartz.dataSource.qzDS.user = rootorg.quartz.dataSource.qzDS.password = 123456org.quartz.dataSource.qzDS.maxConnections = 10</code></pre><p>要将任务调度数据保存到数据库中，就必须使用 <code>org.quratz.impl.jdbcjobstore.JobStoreTX</code>，并提供相应的数据库配置信息。</p><p>用户必须事先在相应的数据库中创建 Quartz 的数据表，在 Quartz 的完整发布包的 <code>docs/dbTables</code> 目录下拥有对应不同数据库的 SQL 脚本。</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-27/67697382.jpg" alt=""></p><p>选择自己使用的数据库对应的脚本执行即可。</p><p>执行结果：<br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-27/48452929.jpg" alt=""></p><h3 id="2-5-2-查询数据库中的运行信息"><a href="#2-5-2-查询数据库中的运行信息" class="headerlink" title="2.5.2 查询数据库中的运行信息"></a>2.5.2 查询数据库中的运行信息</h3><p>首先，引入依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.45<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>任务的现场保存对于上层的 Quartz 来说是完全透明的。<br>使用该配置文件后将之前的代码重新运行，就能在数据库中看到对应的数据。</p><p>当调度程序中途停止之后，任务调度的现场数据将记录在数据库表中，在系统重启时就可以在此基础上继续任务的调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCJobStoreRunner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line">            <span class="comment">// 获取调度器中所有的触发组</span></span><br><span class="line">            String[] triggerGroups = scheduler.getTriggerGroupNames();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新恢复在 tGroup1 组中名为 tName1 的触发器的运行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triggerGroups.length; ++ i) &#123;</span><br><span class="line">                String[] triggerNames = scheduler.getTriggerNames(triggerGroups[i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triggerNames.length; ++ j) &#123;</span><br><span class="line">                    Trigger trigger = scheduler.getTrigger(triggerGroups[i], triggerNames[j]);</span><br><span class="line">                    <span class="keyword">if</span> (trigger <span class="keyword">instanceof</span> SimpleTrigger &amp;&amp; trigger.getFullName().equals(<span class="string">"tGroup1.tName1"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 恢复运行</span></span><br><span class="line">                        scheduler.rescheduleJob(triggerNames[j], triggerGroups[i], trigger);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            scheduler.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调度程序执行后非正常退出，就可以通过 <code>JDBCJobStoreRunner</code> 根据记录在数据库中的现场数据恢复任务的调度。<br>Scheduler 中的所有 Trigger 及 JobDetail 的运行信息都会保存在数据库中，这里仅恢复 <code>tGroup1</code> 组中名为 <code>tName1</code> 的触发器。触发器采用 <code>GROUP.TRIGGER_NAME</code> 的全名格式，通过 <code>Scheduler#reschduleJob(String triggerName, String groupName, Trigger trigger)</code> 方法即可重新调度关联某个 Trigger 任务。</p><h3 id="2-5-3-不同时期-QRTZ-SIMPLE-TRIGGERS-表的数据"><a href="#2-5-3-不同时期-QRTZ-SIMPLE-TRIGGERS-表的数据" class="headerlink" title="2.5.3 不同时期 QRTZ_SIMPLE_TRIGGERS 表的数据"></a>2.5.3 不同时期 <code>QRTZ_SIMPLE_TRIGGERS</code> 表的数据</h3><ul><li>执行 <a href="#SimpleTriggerRunner">代码</a> 中的 <code>SimpleTriggerRunner</code> 一段时间后退出<br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-28/81612739.jpg" alt=""></li><li>quartz 数据库状态如下<br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-28/61021009.jpg" alt=""></li><li><p>这时 <code>QRTZ_SIMPLE_TRIGGERS</code> 表中的数据如下<br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-28/8830267.jpg" alt=""></p><ul><li>REPEAT_COUNT: 触发器器需要执行的总次数</li><li>REPEAT_INTERVAL: 调度间隔(单位：毫秒)</li><li>TIMES_TRIGGERED: 触发器已经调度的次数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCJobStoreRunner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">            JobKey jobKey = <span class="keyword">new</span> JobKey(<span class="string">"jName"</span>, <span class="string">"jGroup"</span>);</span><br><span class="line">            List&lt;? extends Trigger&gt; triggers = scheduler.getTriggersOfJob(jobKey);</span><br><span class="line">            <span class="comment">// SELECT TRIGGER_NAME, TRIGGER_GROUP FROM &#123;QRTZ_&#125;TRIGGERS WHERE SCHED_NAME = &#123;DefaultQuartzScheduler&#125; AND JOB_NAME = ? AND JOB_GROUP = ?</span></span><br><span class="line">            <span class="comment">// 其中 &#123;QRTZ_&#125; 和 &#123;DefaultQuartzScheduler&#125; 均来自 quartz.properties 的配置</span></span><br><span class="line">            <span class="comment">// 重新恢复在jGroup1组中，名为job1_1的 job的触发器运行</span></span><br><span class="line">            <span class="keyword">if</span>(triggers.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (Trigger tg : triggers) &#123;</span><br><span class="line">                    <span class="comment">// 根据类型判断</span></span><br><span class="line">                    <span class="keyword">if</span> ((tg <span class="keyword">instanceof</span> CronTrigger) || (tg <span class="keyword">instanceof</span> SimpleTrigger)) &#123;</span><br><span class="line">                        <span class="comment">// 恢复job运行</span></span><br><span class="line">                        scheduler.resumeJob(jobKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scheduler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时原先被中断的任务已经恢复。</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-28/42883536.jpg" alt=""><br>可以看到，将剩余12次全部执行完成。</p><p>再次查看 <code>QRTZ_SIMPLE_TRIGGER</code> 表，发现触发器已经完成调度并被清除。<br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-28/27877213.jpg" alt=""></p><h1 id="3-集成-Spring"><a href="#3-集成-Spring" class="headerlink" title="3. 集成 Spring"></a>3. 集成 Spring</h1><pre><code>Spring 为创建 Quartz 的 Scheduler、Trigger、JobDetail 提供了便利的 FactoryBean 类，以便能够在 Spring 容器中享受注入的好处。</code></pre><p>Spring 提供了两方面的支持：</p><ol><li>为 Quartz 的主要组件提供了更具 Bean 风格的扩展类</li><li>提供创造 Scheduler 的BeanFactory 类，方便在 Spring 环境下创建对应的组件对象，并结合 Spring 容器生命周期执行启动和停止的动作。</li></ol><h2 id="3-1-创建-JobDetail"><a href="#3-1-创建-JobDetail" class="headerlink" title="3.1 创建 JobDetail"></a>3.1 创建 JobDetail</h2><p>由于 JobDetail 使用带参构造函数，不方便通过 Spring 配置，因此 Spring 通过扩展 JobDetail 提供了更具 Bean 风格的 <code>JobDetailFactoryBean</code>，此外，Spring 还提供了 <code>MethodInvokingJobDetailFactoryBean</code>，用于将 Spring 容器中 Bean 的方法包装成 Quartz 任务，使开发者不必为 Job 创建对应的类。</p><h3 id="3-1-1-JobDetailFactoryBean"><a href="#3-1-1-JobDetailFactoryBean" class="headerlink" title="3.1.1 JobDetailFactoryBean"></a>3.1.1 JobDetailFactoryBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"example5"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetailFactoryBean <span class="title">jobDetailFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JobDetailFactoryBean jobDetailFactoryBean = <span class="keyword">new</span> JobDetailFactoryBean();</span><br><span class="line">        jobDetailFactoryBean.setJobClass(SimpleJob.class);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"size"</span>, <span class="number">10</span>);</span><br><span class="line">        jobDetailFactoryBean.setJobDataAsMap(map);</span><br><span class="line"></span><br><span class="line">        jobDetailFactoryBean.setApplicationContextJobDataKey(<span class="string">"applicationContext"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jobDetailFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JobDetailFactoryBean 封装了 SimpleJob 任务类，并为 Job 对应的 JobDataMap 设置了一个 key 为 <code>size</code>，value 为 10的数据。此外，通过指定 ApplicationContextJobDataKey，让 Job 的JobDataMap 持有 Spring ApplicationContext 的引用。</p></blockquote><ul><li>jobClass：实现 Job 接口的任务类；</li><li>beanName：默认为 bean 的id，显示指定 Bean 名称，对应任务的名称；</li><li>jobDataAsMap：类型为 Map，为任务所对应的 JobDataMap 提供值。提供这个数据是因为用户无法在 Spring 配置文件中为 JobDataMap 类型的属性提供信息；</li><li>applicationContextJobDataKey：用户可以将 Spring ApplicationContext 的引用保存到 JobDataMap 中，以便在 Job 的代码中访问 ApplicaitonContext。为了达到这个目的，用户需要指定一个 key 对应这个 ApplicationContext，如果不设置就不会将 ApplicationContext 放入 JobDataMap中；</li><li>jobListenerNames：类型为 <code>String[]</code>，指定注册在 Scheduler 中的 JobListener 名称。</li></ul><h2 id="3-2-创建-Trigger"><a href="#3-2-创建-Trigger" class="headerlink" title="3.2 创建 Trigger"></a>3.2 创建 Trigger</h2><pre><code>Spring 按照相似的思路分为 SimpleTrigger 和 CronTrigger 提供了更具 Bean 风格的 SimpleTriggerFactoryBean 和 CronTriggerFactoryBean 的扩展类，</code></pre><h3 id="3-2-1-SimpleTriggerFactoryBean"><a href="#3-2-1-SimpleTriggerFactoryBean" class="headerlink" title="3.2.1 SimpleTriggerFactoryBean"></a>3.2.1 SimpleTriggerFactoryBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"simpleTrigger"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleTriggerFactoryBean <span class="title">simpleTriggerFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleTriggerFactoryBean simpleTriggerFactoryBean = <span class="keyword">new</span> SimpleTriggerFactoryBean();</span><br><span class="line">    simpleTriggerFactoryBean.setJobDetail(jobDetailFactoryBean().getObject());</span><br><span class="line">    simpleTriggerFactoryBean.setStartDelay(<span class="number">1000</span>);</span><br><span class="line">    simpleTriggerFactoryBean.setRepeatInterval(<span class="number">2000</span>);</span><br><span class="line">    simpleTriggerFactoryBean.setRepeatCount(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"count"</span>, <span class="number">10</span>);</span><br><span class="line">    simpleTriggerFactoryBean.setJobDataAsMap(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> simpleTriggerFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义了一个 Trigger，该 Trigger 和 JobDetail 相关联，延迟 1 秒后启动，时间间隔为 2 秒，重复执行 20 次。</p></blockquote><p><strong>Trigger 中设置的 JobDataMap 在执行任务时必须通过以下方式获取</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJob</span> <span class="keyword">implements</span> <span class="title">StatefulJob</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        Map dataMap = context.getTrigger().getJobDataMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-2-CronTriggerFactoryBean"><a href="#3-2-2-CronTriggerFactoryBean" class="headerlink" title="3.2.2 CronTriggerFactoryBean"></a>3.2.2 CronTriggerFactoryBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"cronTriggerFactoryBean"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CronTriggerFactoryBean <span class="title">cronTriggerFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CronTriggerFactoryBean cronTriggerFactoryBean = <span class="keyword">new</span> CronTriggerFactoryBean();</span><br><span class="line">    cronTriggerFactoryBean.setJobDetail(jobDetailFactoryBean().getObject());</span><br><span class="line">    cronTriggerFactoryBean.setCronExpression(<span class="string">"0/5 * * * * ?"</span>);</span><br><span class="line">    <span class="keyword">return</span> cronTriggerFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Scheduler"><a href="#3-3-Scheduler" class="headerlink" title="3.3 Scheduler"></a>3.3 Scheduler</h2><pre><code>Quartz 的 SchedulerFactory 是标准的工厂类，不太适合在 Spring 环境下使用。此外，为了保证 Scheduler 能够感知到 Spring 的生命周期，Spring 提供了 SchedulerFactory。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SchedulerFactoryBean <span class="title">schedulerFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SchedulerFactoryBean schedulerFactoryBean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line">    <span class="comment">// 注册一个或多个 Trigger</span></span><br><span class="line">    schedulerFactoryBean.setTriggers(simpleTriggerFactoryBean().getObject());</span><br><span class="line">    <span class="comment">// 以 Map 类型设置 SchedulerContext</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"timeout"</span>, <span class="number">30</span>);</span><br><span class="line">    schedulerFactoryBean.setSchedulerContextAsMap(map);</span><br><span class="line">    <span class="comment">// 显示指定 Quartz 配置文件的路径</span></span><br><span class="line">    schedulerFactoryBean.setConfigLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">"quartz.properties"</span>));</span><br><span class="line">    <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>triggers：属性为 <code>trigger[]</code>，可以注册多个 Trigger</li><li>schedulerContextAsMap：Scheduler拥有类似 ServletContext 的 SchedulerContext，允许用户以 Map 的形式设置 SchedulerContext 的参数值</li><li>configLocation：指定配置文件路径</li><li>calendars：类型为 Map，通过该属性向 Scheduler 注册 JobDetail</li><li>jobDetails：类型为 <code>JobDetail[]</code>，通过该属性向 Scheduler 注册 JobDetail</li><li>autoStartup：SchedulerFactoryBean 初始化之后是否立即启动，默认为 true</li><li>startupDelay：SchedulerFactoryBean 启动后的延迟时间，默认为 0</li></ul><p><em>SchedulerFactoryBean 的一项重要功能是允许用户将 Quartz 配置文件中的信息转移到 Spring 配置文件中</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SchedulerFactoryBean <span class="title">schedulerFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SchedulerFactoryBean schedulerFactoryBean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line">    <span class="comment">// 注册一个或多个 Trigger</span></span><br><span class="line">    schedulerFactoryBean.setTriggers(simpleTriggerFactoryBean().getObject());</span><br><span class="line">    <span class="comment">// 以 Map 类型设置 SchedulerContext</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"timeout"</span>, <span class="number">30</span>);</span><br><span class="line">    schedulerFactoryBean.setSchedulerContextAsMap(map);</span><br><span class="line">    <span class="comment">// 显示指定 Quartz 配置文件的路径</span></span><br><span class="line">    schedulerFactoryBean.setConfigLocation(<span class="keyword">new</span> FileSystemResource(<span class="string">"classpath:quartz.properties"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------ 集成 Quartz 配置文件 ------------------//</span></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="string">"org.quartz.threadPool.class"</span>, <span class="string">"org.quartz.simpl.SimpleThreadPool"</span>);</span><br><span class="line">    properties.setProperty(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"10"</span>);</span><br><span class="line">    schedulerFactoryBean.setQuartzProperties(properties);</span><br><span class="line">    <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-测试代码"><a href="#3-4-测试代码" class="headerlink" title="3.4 测试代码"></a>3.4 测试代码</h2><p>此处有一个坑，就说从 Spring 容器中根据 beanName 获取的 schedulerFactoryBean 其实是 <code>org.quartz.impl.StdScheduler</code> 对象，如果使用 <code>org.springframework.scheduling.quartz.SchedulerFactoryBean</code> 会抛出以下异常</p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-5-2/64504859.jpg" alt=""></p><p>从 Spring 容器中直接获取 Scheduler 即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTriggerRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(QuartzConf.class);</span><br><span class="line">        <span class="comment">// 此处一定要取 Scheduler 而不是 SchedulerFactoryBean，因为它是一个工厂bean，得到的不是它本身，而是它负责创建的 org.quartz.impl.StdScheduler 对象</span></span><br><span class="line">        Scheduler scheduler = context.getBean(<span class="string">"schedulerFactoryBean"</span>, Scheduler.class);</span><br><span class="line"></span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-附录"><a href="#4-附录" class="headerlink" title="4. 附录"></a>4. 附录</h1><h2 id="4-1-tables-mysql-innodb-sql"><a href="#4-1-tables-mysql-innodb-sql" class="headerlink" title="4.1 tables_mysql_innodb.sql"></a>4.1 tables_mysql_innodb.sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- In your Quartz properties file, you'll need to set </span></span><br><span class="line"><span class="comment">-- org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span></span><br><span class="line"><span class="comment">-- By: Ron Cordell - roncordell</span></span><br><span class="line"><span class="comment">-- I didn't see this anywhere, so I thought I'd post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_JOB_LISTENERS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_TRIGGER_LISTENERS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_FIRED_TRIGGERS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_PAUSED_TRIGGER_GRPS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_SCHEDULER_STATE;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_LOCKS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_SIMPLE_TRIGGERS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_CRON_TRIGGERS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_BLOB_TRIGGERS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_TRIGGERS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_JOB_DETAILS;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_CALENDARS;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_JOB_DETAILS(</span><br><span class="line">JOB_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">DESCRIPTION <span class="built_in">VARCHAR</span>(<span class="number">250</span>) <span class="literal">NULL</span>,</span><br><span class="line">JOB_CLASS_NAME <span class="built_in">VARCHAR</span>(<span class="number">250</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">IS_DURABLE <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">IS_VOLATILE <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">IS_STATEFUL <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">REQUESTS_RECOVERY <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB_DATA <span class="built_in">BLOB</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (JOB_NAME,JOB_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_JOB_LISTENERS (</span><br><span class="line">JOB_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB_LISTENER <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (JOB_NAME,JOB_GROUP,JOB_LISTENER),</span><br><span class="line"><span class="keyword">INDEX</span> (JOB_NAME, JOB_GROUP),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (JOB_NAME,JOB_GROUP)</span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_JOB_DETAILS(JOB_NAME,JOB_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_TRIGGERS (</span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">IS_VOLATILE <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">DESCRIPTION <span class="built_in">VARCHAR</span>(<span class="number">250</span>) <span class="literal">NULL</span>,</span><br><span class="line">NEXT_FIRE_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="literal">NULL</span>,</span><br><span class="line">PREV_FIRE_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">PRIORITY</span> <span class="built_in">INTEGER</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_STATE <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_TYPE <span class="built_in">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">START_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">END_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="literal">NULL</span>,</span><br><span class="line">CALENDAR_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="literal">NULL</span>,</span><br><span class="line">MISFIRE_INSTR <span class="built_in">SMALLINT</span>(<span class="number">2</span>) <span class="literal">NULL</span>,</span><br><span class="line">JOB_DATA <span class="built_in">BLOB</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line"><span class="keyword">INDEX</span> (JOB_NAME, JOB_GROUP),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (JOB_NAME,JOB_GROUP)</span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_JOB_DETAILS(JOB_NAME,JOB_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_SIMPLE_TRIGGERS (</span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">REPEAT_COUNT <span class="built_in">BIGINT</span>(<span class="number">7</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">REPEAT_INTERVAL <span class="built_in">BIGINT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TIMES_TRIGGERED <span class="built_in">BIGINT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line"><span class="keyword">INDEX</span> (TRIGGER_NAME, TRIGGER_GROUP),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_CRON_TRIGGERS (</span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">CRON_EXPRESSION <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TIME_ZONE_ID <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line"><span class="keyword">INDEX</span> (TRIGGER_NAME, TRIGGER_GROUP),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_BLOB_TRIGGERS (</span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">BLOB_DATA <span class="built_in">BLOB</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class="line"><span class="keyword">INDEX</span> (TRIGGER_NAME, TRIGGER_GROUP),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_TRIGGER_LISTENERS (</span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_LISTENER <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_LISTENER),</span><br><span class="line"><span class="keyword">INDEX</span> (TRIGGER_NAME, TRIGGER_GROUP),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_CALENDARS (</span><br><span class="line">CALENDAR_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">CALENDAR <span class="built_in">BLOB</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (CALENDAR_NAME))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_PAUSED_TRIGGER_GRPS (</span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (TRIGGER_GROUP))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_FIRED_TRIGGERS (</span><br><span class="line">ENTRY_ID <span class="built_in">VARCHAR</span>(<span class="number">95</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">IS_VOLATILE <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">INSTANCE_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">FIRED_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">PRIORITY</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">STATE <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">JOB_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="literal">NULL</span>,</span><br><span class="line">JOB_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="literal">NULL</span>,</span><br><span class="line">IS_STATEFUL <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="literal">NULL</span>,</span><br><span class="line">REQUESTS_RECOVERY <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (ENTRY_ID))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_SCHEDULER_STATE (</span><br><span class="line">INSTANCE_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">LAST_CHECKIN_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">CHECKIN_INTERVAL <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (INSTANCE_NAME))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_LOCKS (</span><br><span class="line">LOCK_NAME <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (LOCK_NAME))</span><br><span class="line"><span class="keyword">TYPE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_LOCKS <span class="keyword">values</span>(<span class="string">'TRIGGER_ACCESS'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_LOCKS <span class="keyword">values</span>(<span class="string">'JOB_ACCESS'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_LOCKS <span class="keyword">values</span>(<span class="string">'CALENDAR_ACCESS'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_LOCKS <span class="keyword">values</span>(<span class="string">'STATE_ACCESS'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> QRTZ_LOCKS <span class="keyword">values</span>(<span class="string">'MISFIRE_ACCESS'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-任务调度概述&quot;&gt;&lt;a href=&quot;#1-任务调度概述&quot; class=&quot;headerlink&quot; title=&quot;1. 任务调度概述&quot;&gt;&lt;/a&gt;1. 任务调度概述&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;各种企业应用几乎都会碰到任务调度的需求。
在特定的时间点执行指定的操作。
      
    
    </summary>
    
      <category term="quartz" scheme="https://destinywang.github.io/blog/categories/quartz/"/>
    
    
      <category term="quartz" scheme="https://destinywang.github.io/blog/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Java文件下载</title>
    <link href="https://destinywang.github.io/blog/2018/04/16/Java%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <id>https://destinywang.github.io/blog/2018/04/16/Java文件下载/</id>
    <published>2018-04-16T15:46:42.000Z</published>
    <updated>2018-04-16T15:56:06.275Z</updated>
    
    <content type="html"><![CDATA[<pre><code>今天在开发中遇到了一个需求：在服务端保存一个Excel模板，用户通过浏览器传递不同的参数，解析参数并写入模板返回给用户以供下载。需求本身很简单，但在开发的过程中踩了几个坑，所以记录下来。</code></pre><h2 id="1-文件下载的原理"><a href="#1-文件下载的原理" class="headerlink" title="1. 文件下载的原理"></a>1. 文件下载的原理</h2><blockquote><ul><li>通过 <code>HttpServletResponse.setContentType()</code> 方法设置 <code>Content-Type</code> 字段的值，设置为 <code>application/octet-stream</code> 或 <code>application/x-msdownload</code> ，决定客户端服务器以那种方式来接受返回的信息</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">"application/vnd.ms-excel"</span>);</span><br></pre></td></tr></table></figure><blockquote><ul><li>通过 <code>HttpServletResponse.setHeader()</code> 方法设置 <code>Content-Disposition</code> 头的值为 <code>attachment;filename=文件名</code> ，浏览器通过附件的形式来获取到用户上传的文件</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename="</span> + fileName);</span><br></pre></td></tr></table></figure><blockquote><ul><li>读取下载文件，通过 <code>HttpServletResponse.getOutputStream()</code> 方法返回 <code>ServletOutputStream</code> 对象来向客户端写入附件文件的内容</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (OutputStream out = response.getOutputStream();</span><br><span class="line">     BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">     BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(out)) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">    <span class="keyword">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> (-<span class="number">1</span> != (bytesRead = bis.read(buff, <span class="number">0</span>, buff.length))) &#123;</span><br><span class="line">        bos.write(buff, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    logger.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Http-报头-Content-disposition-的作用"><a href="#2-Http-报头-Content-disposition-的作用" class="headerlink" title="2. Http 报头 Content-disposition 的作用"></a>2. <code>Http</code> 报头 <code>Content-disposition</code> 的作用</h2><pre><code>Content-Disposition 属性是作为对下载文件的一个标识字段。</code></pre><p>在 <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf" target="_blank" rel="noopener">rfc2616</a> 章节19.5 Additional Features中</p><p><code>Content-Disposition</code> 属性有两种类型：<code>inline</code> 和 <code>attachment</code></p><ul><li>inline ：将文件内容直接显示在页面</li><li>attachment：弹出对话框让用户下载</li></ul><h3 id="2-1-inline"><a href="#2-1-inline" class="headerlink" title="2.1 inline"></a>2.1 inline</h3><pre><code>inline 用于直接在页面中展示该文件，常用与图片等</code></pre><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"rfc1806.txt"</span>);</span><br><span class="line">String filename = file.getName();</span><br><span class="line">response.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Content-Disposition"</span>,<span class="string">"inline;filename="</span> + <span class="keyword">new</span> String(filename.getBytes(),<span class="string">"utf-8"</span>));</span><br><span class="line">response.addHeader(<span class="string">"Content-Length"</span>,<span class="string">""</span> + file.length());</span><br></pre></td></tr></table></figure><h3 id="2-2-attachment"><a href="#2-2-attachment" class="headerlink" title="2.2 attachment"></a>2.2 attachment</h3><pre><code>attachment 用于通知浏览器弹出对话框以供用户下载。</code></pre><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"rfc1806.txt"</span>);</span><br><span class="line">String filename = file.getName();</span><br><span class="line">response.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Content-Disposition"</span>,<span class="string">"attachment; filename="</span> + <span class="keyword">new</span> String(filename.getBytes(),<span class="string">"utf-8"</span>));</span><br><span class="line">response.addHeader(<span class="string">"Content-Length"</span>,<span class="string">""</span> + file.length());</span><br></pre></td></tr></table></figure><h2 id="3-filename-属性中文乱码"><a href="#3-filename-属性中文乱码" class="headerlink" title="3. filename 属性中文乱码"></a>3. <code>filename</code> 属性中文乱码</h2><p>如果在设置 <code>filename</code> 的时候直接使用中文，则会出现如下情况:</p><ul><li><p>在代码中直接使用中文进行设置<br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-16/99931223.jpg" alt=""></p></li><li><p>相应的 <code>HTTP Response</code><br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-16/35170323.jpg" alt=""></p></li><li><p>浏览器的弹窗<br><img src="http://oetw0yrii.bkt.clouddn.com/18-4-16/14163886.jpg" alt=""></p></li></ul><p>首先，产生乱码的根本问题是在 HTTP 协议中，HTTP Header要求其内容必须为 <code>ISO-8859-1</code> 编码。</p><p>所以，在开发中尽量使用如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Content-disposition"</span>, <span class="string">"attachment; filename="</span> + <span class="keyword">new</span> String(<span class="string">"中文文件名"</span>.getBytes(<span class="string">"utf-8"</span>), <span class="string">"ISO8859-1"</span>));</span><br></pre></td></tr></table></figure><p>得到文件名的字节数组，将字节数组转换成 <code>IOS-8859-1</code> 格式编码的字符串。</p><p>而不能通过如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"中文文件名"</span>.getBytes(<span class="string">"ISO8859-1"</span>);</span><br></pre></td></tr></table></figure><p>因为 <code>IOS-8859-1</code> 的编码表中没有汉字字符，因此无法通过以上的方式对中文字符串进行编码。</p><p>以先通过 <code>&quot;中文文件名&quot;.getBytes(&quot;utf-8&quot;)</code> 获取其 <code>byte[]</code>字节，让其按照字节来编码，即在使用 <code>new String(&quot;中文文件名&quot;.getBytes(&quot;utf-8&quot;), &quot;ISO8859-1&quot;)</code> 将其重新组成一个字符串，传送给浏览器。</p><h2 id="4-演示"><a href="#4-演示" class="headerlink" title="4. 演示"></a>4. 演示</h2><h3 id="4-1-代码及资源路径"><a href="#4-1-代码及资源路径" class="headerlink" title="4.1 代码及资源路径"></a>4.1 代码及资源路径</h3><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-16/86742792.jpg" alt=""></p><h3 id="4-2-HTTP-Response-详情"><a href="#4-2-HTTP-Response-详情" class="headerlink" title="4.2 HTTP Response 详情"></a>4.2 HTTP Response 详情</h3><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-16/68196612.jpg" alt=""></p><h3 id="4-3-浏览器能够正确识别"><a href="#4-3-浏览器能够正确识别" class="headerlink" title="4.3 浏览器能够正确识别"></a>4.3 浏览器能够正确识别</h3><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-16/88139961.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;今天在开发中遇到了一个需求：
在服务端保存一个Excel模板，用户通过浏览器传递不同的参数，解析参数并写入模板返回给用户以供下载。
需求本身很简单，但在开发的过程中踩了几个坑，所以记录下来。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-文件下载的原理&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="踩坑总结" scheme="https://destinywang.github.io/blog/categories/%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="踩坑总结" scheme="https://destinywang.github.io/blog/tags/%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>(翻译)In Search of an Understandable Consensus Algorithm —— Raft算法</title>
    <link href="https://destinywang.github.io/blog/2018/04/15/%E7%BF%BB%E8%AF%91-In-Search-of-an-Understandable-Consensus-Algorithm-%E2%80%94%E2%80%94-Raft%E7%AE%97%E6%B3%95/"/>
    <id>https://destinywang.github.io/blog/2018/04/15/翻译-In-Search-of-an-Understandable-Consensus-Algorithm-——-Raft算法/</id>
    <published>2018-04-15T07:40:55.000Z</published>
    <updated>2018-04-15T14:55:31.574Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客为著名的 RAFT 一致性算法论文的中文翻译，论文名为<a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">《In search of an Understandable Consensus Algorithm (Extended Version)》(寻找一种易于理解的一致性算法)</a></p><p><code>Raft</code> 是一种用来管理日志复制的一致性算法。它和 <code>Paxos</code> 的性能和功能是一样的，但是它和 <code>Paxos</code> 的结构不一样；这使得 <code>Raft</code> 更容易理解并且更易于建立实际的系统。为了提高理解性，Raft 将一致性算法分为了几个部分，例如<code>领导选取（leader selection）</code>，<code>日志复制（log replication）</code>和<code>安全性（safety）</code>，同时它使用了更强的一致性来减少了必须需要考虑的状态。从用户学习的结果来看，<code>Raft</code> 比 <code>Paxos</code> 更容易学会。<code>Raft</code> 还包括了一种新的机制来使得动态改变集群成员，它使用<code>重叠大多数（overlapping majorities）</code>来保证安全。</p><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器出了错误也能正常工作。正因为此，他们扮演着建立大规模可靠的软件系统的关键角色。在过去的十年中 <code>Paxos</code> 一直都主导着有关一致性算法的讨论：大多数一致性算法的实现都基于它或者受它影响，并且 Paxos 也成为了教学生关于一致性知识的主要工具。</p><p>不幸的是，尽管在降低它的复杂性方面做了许多努力，<code>Paxos</code> 依旧很难理解。并且，<code>Paxos</code> 需要经过复杂的修改才能应用于实际中。这些导致了系统构构建者和学生都十分头疼。</p><p>在被 <code>Paxos</code> 折磨之后，我们开始寻找一种在系统构建和教学上更好的新的一致性算法。我们的首要目标是让它易于理解：我们能不能定义一种面向实际系统的一致性算法并且比 <code>Paxos</code> 更容易学习呢？并且，我们希望这种算法能凭直觉就能明白，这对于一个系统构建者来说是十分必要的。对于一个算法，不仅仅是让它工作起来很重要，知道它是如何工作的更重要。</p><p>我们工作的结果是一种新的一致性算法，叫做 <code>Raft</code>。在设计 <code>Raft</code> 的过程中我们应用了许多专门的技巧来提升理解性，包括<code>算法分解（分为领导选取（leader selection），日志复制（log replication）和安全性（safety））</code> 和 <code>减少状态（state space reduction）（相对于 Paxos，Raft 减少了非确定性的程度和服务器互相不一致的方式）</code>。在两所学校的43个学生的研究中发现，<code>Raft</code> 比 <code>Paxos</code> 要更容易理解：在学习了两种算法之后，其中的33个学生回答 <code>Raft</code> 的问题要比回答 <code>Paxos</code> 的问题要好。</p><p>在许多方面，<code>Raft</code>与现有的协商一致意见相似(最值得注意的是，Oki和Liskov的Viewstamped复制)，但它有几个新的特点:</p><ul><li>强领导者<code>（Strong Leader）</code> : <code>Raft</code>使用一种比其他共识算法更强的领导方式。例如，日志条目只从<code>Leader</code>流向其他服务器。这样就简化了复制日志的管理，使<code>Raft</code>更容易理解。</li><li>领导选取<code>（Leader Selection）</code>: <code>Raft</code> 使用<code>随机定时器</code>选举领导人。这只增加了对任何协商一致算法所需的心跳的一小部分机制，同时快速地解决冲突。</li><li>成员变化<code>（Membership Change）</code>: <code>Raft</code> 为了调整集群中成员关系使用了新的<code>联合一致性（joint consensus）</code>的方法，这种方法中大多数不同配置的机器在转换关系的时候会<code>交迭（overlap）</code>。这使得在配置改变的时候，集群能够继续操作。</li></ul><p>我们认为，Raft 在教学方面和实际实现方面比 <code>Paxos</code> 和其他算法更出众。</p><ul><li>它比其他算法更简单、更容易理解；</li><li>它能满足一个实际系统的需求；</li><li>它拥有许多开源的实现并且被许多公司所使用；</li><li>它的安全特性已经被证明；</li><li>并且它的效率和其他算法相比也具有竞争力。</li></ul><p>这篇论文剩下的部分会讲如下内容：</p><ul><li><code>复制状态机（replicated state machine）</code>问题（第2节）;</li><li>讨论 <code>Paxos</code> 的优缺点（第3节）;</li><li>讨论我们用的为了达到提升理解性的方法（第4节）;</li><li>陈述 Raft 一致性算法（第5~8节）;</li><li>评价 <code>Raft</code> 算法（第9节）;</li><li>对相关工作的讨论（第10节）。</li></ul><h1 id="2-复制状态机（Replicated-State-Machine）"><a href="#2-复制状态机（Replicated-State-Machine）" class="headerlink" title="2. 复制状态机（Replicated State Machine）"></a>2. 复制状态机（Replicated State Machine）</h1><pre><code>复制状态机在分布式领域是一个常用且重要的技术。通过复制服务副本，并和副本一起来协调客户端的交互，来实现容错服务。这个方法同样提供了一个框架，来理解和设计复制管理协议。</code></pre><p>一致性算法是在<code>复制状态机</code>的背景下提出来的。在这个方法中，在一组服务器的状态机产生同样的状态的副本因此即使有一些服务器崩溃了这组服务器也还能继续执行。复制状态机在分布式系统中被用于解决许多有关容错的问题。例如，<code>GFS</code>，<code>HDFS</code>还有 <code>RAMCloud</code> 这些大规模的系统都是用一个单独的集群领导者，使用一个单独的复制状态机来进行领导选取和存储配置信息来应对领导者的崩溃。使用复制状态机的例子有 <code>Chubby</code> 和 <code>ZooKeeper</code>。</p><blockquote><p>复制状态机的架构。一致性算法管理来自客户端状态命令的复制日志。状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p></blockquote><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-15/55312592.jpg" alt=""></p><p>复制状态机是通过复制日志来实现的。每一台服务器保存着一份日志，日志中包含一系列的命令，状态机会按顺序执行这些命令。因为每一台计算机的状态机都是确定的，所以每个状态机的状态都是相同的，执行的命令是相同的，最后的执行结果也就是一样的了。</p><p>如何保证复制日志一致就是一致性算法的工作了。在一台服务器上，一致性模块接受客户端的命令并且把命令加入到它的日志中。它和其他服务器上的一致性模块进行通信来确保每一个日志最终包含相同序列的请求，即使有一些服务器宕机了。一旦这些命令被正确的复制了，每一个服务器的状态机都会按同样的顺序去执行它们，然后将结果返回给客户端。最终，这些服务器看起来就像一台可靠的状态机。</p><p>应用于实际系统的一致性算法一般有以下特性：</p><ul><li>确保安全性（从来不会返回一个错误的结果），即使在所有的非拜占庭（Non-Byzantine）情况下，包括网络延迟、分区、丢包、冗余和乱序的情况下。</li><li>高可用性，只要集群中的大部分机器都能运行，可以互相通信并且可以和客户端通信，这个集群就可用。因此，一般来说，一个拥有 5 台机器的集群可以容忍其中的 2 台的失败（fail）。服务器停止工作了我们就认为它失败（fail）了，没准一会当它们拥有稳定的存储时就能从中恢复过来，重新加入到集群中。</li><li>不依赖时序保证一致性，时钟错误和极端情况下的消息延迟在最坏的情况下才会引起可用性问题。</li><li>通常情况下，一条命令能够尽可能快的在大多数节点对一轮远程调用作出相应时完成，一少部分慢的机器不会影响系统的整体性能。</li></ul><h1 id="3-Paxos算法的不足"><a href="#3-Paxos算法的不足" class="headerlink" title="3. Paxos算法的不足"></a>3. Paxos算法的不足</h1><p>在过去的10年中，<code>Leslie Lamport</code> 的 <code>Paxos</code> 算法几乎已经成为了一致性算法的代名词：它是授课中最常见的算法，同时也是许多一致性算法实现的起点。<code>Paxos</code> 首先定义了一个<strong>能够达成单一决策一致的协议</strong>，例如一个<code>单一复制日志条目（single replicated log entry）</code>。我们把这个子集叫做单一决策 Paxos（single-decree Paxos）。之后 Paxos通过组合多个这种协议来完成一系列的决策，例如一个日志（multi-Paxos）。Paxos 确保安全性和活跃性（liveness），并且它支持集群成员的变更。它的正确性已经被证明，通常情况下也很高效。</p><p>不幸的是，Paxos 有两个致命的缺点。</p><ol><li><code>Paxos</code> 太难以理解。它的完整的解释晦涩难懂；很少有人能完全理解，只有少数人成功的读懂了它。并且大家做了许多努力来用一些简单的术语来描述它。尽管这些解释都关注于单一决策子集问题，但仍具有挑战性。在 NSDI 2012 会议上的一次非正式调查显示，我们发现大家对 <code>Paxos</code> 都感到不满意，其中甚至包括一些有经验的研究员。我们自己也曾深陷其中，我们在读过几篇简化它的文章并且设计了我们自己的算法之后才完全理解了 <code>Paxos</code>，而整个过程花费了将近一年的时间。<br>我们假定 Paxos 的晦涩来源于它将单决策子集作为它的基础。单决策（Single-decree）Paxos 是晦涩且微妙的：它被划分为两个没有简单直观解释的阶段，并且难以独立理解。正因为如此，它不能很直观的让我们知道为什么单一决策协议能够工作。为多决策 Paxos 设计的规则又添加了额外的复杂性和精巧性。我们相信多决策问题能够分解为其它更直观的方式。</li><li>它难以在实际环境中实现。其中一个原因是，对于多决策 <code>Paxos （multi-Paxos）</code> ，大家还没有一个一致同意的算法。Lamport 的描述大部分都是有关于<code>单决策 Paxos （single-decree Paxos）</code>；他仅仅描述了实现多决策的可能的方法，缺少许多细节。有许多实现 Paxos 和优化 Paxos 的尝试，但是他们都和 Lamport 的描述有些出入。例如，<code>Chubby</code> 实现的是一个类似 <code>Paxos</code> 的算法，但是在许多情况下的细节没有公开。</li></ol><p>另外，<code>Paxos</code> 的结构也是不容易在一个实际系统中进行实现的，这是单决策问题分解带来的又一个问题。例如，从许多日志条目中选出条目然后把它们融合到一个序列化的日志中并没有带来什么好处，它仅仅增加了复杂性。围绕着日志来设计一个系统是更简单、更高效的：新日志按照严格的顺序添加到日志中去。另一个问题是，<code>Paxos</code> 使用对等的点对点的实现作为它的核心（尽管它最终提出了一种弱领导者的形式来优化性能）。这种方法在只有一个决策被制定的情况下才显得有效，但是很少有现实中的系统使用它。如果要做许多的决策，选择一个领导人，由领带人来协调是更简单有效的方法。</p><p>因此，在实际的系统应用中和 <code>Paxos</code> 算法都相差很大。所有开始于 <code>Paxos</code> 的实现都会遇到很多问题，然后由此衍生出了许多与 <code>Paxos</code> 有很大不同的架构。这是既费时又容易出错的，并且理解 <code>Paxos</code> 的难度又非常大。<code>Paxos</code> 算法在它正确性的理论证明上是很好的，但是在实现上的价值就远远不足了。来自 <code>Chubby</code> 的实现的一条评论就能够说明：</p><pre><code>There are signiﬁcant gaps between the description of the Paxos algorithm and the needs of a real-world system...the ﬁnal system will be based on an unproven protocol翻译：Paxos 算法的描述与实际实现之间存在巨大的鸿沟...最终的系统往往建立在一个没有被证明的算法之上。</code></pre><p>正因为存在这些问题，我们认为 <code>Paxos</code> 不仅对于系统的构建者来说不友好，同时也不利于教学。鉴于一致性算法对于大规模软件系统的重要性，我们决定试着来设计一种另外的比 <code>Paxos</code> 更好的一致性算法。<code>Raft</code> 就是这样的一个算法。</p><h1 id="4-易于理解的设计"><a href="#4-易于理解的设计" class="headerlink" title="4. 易于理解的设计"></a>4. 易于理解的设计</h1><p>设计 Raft 的目标有如下几个：</p><ul><li>它必须提供一个完整的、实际的基础来进行系统构建，为的是减少开发者的工作；</li><li>它必须在所有情况下都能保证安全可用；</li><li>它对于常规操作必须高效；</li><li>最重要的目标是：易于理解，它必须使得大多数人能够很容易的理解；</li><li>另外，它必须能让开发者有一个直观的认识，这样才能使系统构建者们去对它进行扩展。</li></ul><p>在设计 <code>Raft</code> 的过程中，我们不得不在许多种方法中做出选择。当面临这种情况时，我们通常会权衡可理解性：每种方法的可理解性是如何的？（例如，它的状态空间有多复杂？它是不是有很细微的含义？）它的可读性如何？读者能不能轻易地理解这个方法和它的含义？</p><p>我们意识到对这种可理解性的分析具有高度的主观性；尽管如此，我们使用了两种适用的方式。</p><ol><li>第一种是众所周知的问题分解：我们尽可能将问题分解成为若干个可解决的、可被理解的小问题。例如，在 <code>Raft</code> 中，我们把问题分解成为了<strong>领导选取（leader election）、日志复制（log replication）、安全（safety）和成员变化（membership changes）</strong>。</li><li>我们采用的第二个方法是<strong>通过减少需要考虑的状态的数量将状态空间简化</strong>，这能够使得整个系统更加一致并且尽可能消除不确定性。特别地，日志之间不允许出现空洞，并且 Raft 限制了限制了日志不一致的可能性。尽管在大多数情况下，我们都都在试图消除不确定性，但是有时候有些情况下，不确定性使得算法更易理解。尤其是，随机化方法使得不确定性增加，但是它减少了状态空间。我们使用随机化来简化了 <code>Raft</code> 中的领导选取算法。</li></ol><h1 id="5-Raft-一致性算法"><a href="#5-Raft-一致性算法" class="headerlink" title="5. Raft 一致性算法"></a>5. Raft 一致性算法</h1><p>Raft是一种用于管理第2节中描述的表单的复制日志的算法。表2总结了压缩格式的算法，表3列出了算法的关键属性;这些数字的组成部分是分段讨论的。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><blockquote><p><center>表-2-1</center></p></blockquote><ul><li>在所有服务器上持久存在的</li></ul><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器最后知道的任期号（从0开始递增）</td></tr><tr><td>votedFor</td><td>当前任期内收到选票的 <code>候选人</code> id（如果没有就为<code>null</code>）</td></tr><tr><td>log[]</td><td>日志条目；，诶个条目包含状态机的要执行命令和从 `领导者  出收到的任期号</td></tr></tbody></table><ul><li>在所有服务器上不稳定存在的</li></ul><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知的被提交的最大日志条目的索引值（从0开始递增）</td></tr><tr><td>lastApplied</td><td>被状态机执行的额最大日志条目的索引值（从0开始递增）</td></tr></tbody></table><ul><li>在领导人服务器上不稳定存在的（在选举之后初始化的）</li></ul><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>对于每个服务器，记录需要发给它的下一个日志条目的索引（初始化为<code>Leader</code>上一条日志索引+1）</td></tr><tr><td>natchIndex[]</td><td>对于每一个服务器，记录已经复制到该拂去其的日志的最高索引值（从0开始递增）</td></tr></tbody></table><h2 id="附加日志远程调用（AppendEntries-RPC）"><a href="#附加日志远程调用（AppendEntries-RPC）" class="headerlink" title="附加日志远程调用（AppendEntries RPC）"></a>附加日志远程调用（AppendEntries RPC）</h2><p>由领导人来调用复制日志</p><blockquote><p><center>表-2-2</center></p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的id，为了其他服务器能重定向到<code>Leader</code></td></tr><tr><td>prevLogIndex</td><td>最新日志之前的日志的索引值</td></tr><tr><td>prevLogTerm</td><td>最新日志之前的日志的领导人任期号</td></tr><tr><td>entries[]</td><td>要存储的日志条目（表示<code>heartbeat</code>时为空，有时会为了效率发送多条）</td></tr><tr><td>leaderCommit</td><td>领导人提交的日志条目索引值</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>当前的任期号，用于 <code>Leader</code> 更新自己的任期号</td></tr><tr><td>success</td><td>如果其他服务器包含能够匹配上 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 的日志时为真</td></tr></tbody></table><p><code>Follower</code>需要实现：</p><ol><li>如果 <code>term</code> &lt; <code>currentTerm</code> 返回<code>false</code></li><li>如果在 <code>prevLogIndex</code> 处的日志的任期号与 <code>prevLogTerm</code> 不匹配时，返回<code>false</code></li><li>如果一条已经存在的日志与新的冲突（<code>index</code> 相同但任期号 <code>term</code> 不同），则删除已经存在的日志和它之后的所有日志</li><li>添加任何在以后日志中不存在的条目</li><li>如果 <code>leaderCommit</code> &gt; <code>commitIndex</code>，将 <code>commitIndex</code> 设置为 <code>leaderCommit</code> 和最新日志条目索引号中较小的一个 </li></ol><h2 id="投票请求RPC（RequestVote-RPC）"><a href="#投票请求RPC（RequestVote-RPC）" class="headerlink" title="投票请求RPC（RequestVote RPC）"></a>投票请求RPC（RequestVote RPC）</h2><p>由候选人发起收集选票</p><blockquote><p><center>表-2-3</center></p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>candidateId</td><td>请求投票的候选人id</td></tr><tr><td>lastLogIndex</td><td>候选人最新日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最新日志条目对应的任期号</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>当前的任期号，用于 候选人 更新自己的任期号</td></tr><tr><td>voteGranted</td><td>如果候选人收到选票为true</td></tr></tbody></table><p>接受者需要实现</p><ol><li>如果 <code>term</code> &lt; <code>currentTerm</code> 返回false</li><li>如果 <code>votedFor</code> 为空或者与 <code>candidateId</code> 相同，并且候选人的日志和自己的日志一样新，则给候选人投票。</li></ol><hr><h2 id="服务器需要遵守的规则"><a href="#服务器需要遵守的规则" class="headerlink" title="服务器需要遵守的规则"></a>服务器需要遵守的规则</h2><h3 id="所有服务器"><a href="#所有服务器" class="headerlink" title="所有服务器"></a><em>所有服务器</em></h3><ul><li>如果 <code>commitIndex</code> &gt; <code>lastApplied</code>，<code>lastApplied</code> 自增，将 <code>log[lastApplied]</code> 应用到状态机；</li><li>如果RPC的请求或者响应中包含一个 <code>Term</code> &gt; <code>currentTerm</code>，则 <code>currentTerm</code> 赋值为 <code>Term</code>，并切换状态为<code>Follower</code>；</li></ul><h3 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a><em>Follower</em></h3><ul><li>响应来自候选人和领导人的RPC请求</li><li>如果在超过选取 <code>Leader</code> 时间之前没有收到来自领导人的 <code>AppendEntries RPC</code> 或者没有收到候选人的投票请求，则自己转换状态为候选人</li></ul><h3 id="Candidate"><a href="#Candidate" class="headerlink" title="Candidate"></a><em>Candidate</em></h3><ul><li>转变为 <code>Candidate</code> 之后开始选举<ul><li><code>currentTerm</code> 自增</li><li>给自己投票</li><li>重置选举计时器</li><li>向其他服务器发送 <code>RequestVote RPC</code></li></ul></li><li>如果收到了来自大多数服务器的投票，则成为领导人</li><li>如果收到了来自新 <code>Leader</code> 的 <code>AppendEntries RPC(heartbeat)</code>，则成为 <code>Follower</code></li><li>如果选举超时，开始新一轮选举</li></ul><h3 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a><em>Leader</em></h3><ul><li>一旦成为领导人：想起他所有服务器发送空的 <code>AppendEntries PRC(heartbeat)</code>；在空闲时间重复发送以防止选举超时</li><li>如果收到来自客户端的请求，向本地日子增加条目，在该条目应用到状态机后响应客户端</li><li>对于一个 <code>Followed</code> 来说，如果上一次收到的日志索引大于将要收到的日志索引<code>(nextIndex)</code>：通过 <code>AppendEntries RPC</code> 将 <code>nextIndex</code> 之后的所有日志条目发送出去<ul><li>如果发送成功：将该 <code>Follower</code> 的 <code>nextIndex</code> 和 <code>matchIndex</code> 更新</li><li>如果由于日志不一致导致 <code>AppendEntries RPC</code> 失败：<code>nextIndex</code> 递减并且重新发送</li></ul></li><li>如果存在一个满足 <code>N &gt; commitIndex</code> 和 <code>matchIndex[i] &gt;= N</code> 并且 <code>log[N].term == currentTerm</code>的 N，则将 <code>commitIndex</code> 赋值为N</li></ul><h2 id="Raft-一致性算法的总结（不包括成员变化和日志压缩）"><a href="#Raft-一致性算法的总结（不包括成员变化和日志压缩）" class="headerlink" title="Raft 一致性算法的总结（不包括成员变化和日志压缩）"></a>Raft 一致性算法的总结（不包括成员变化和日志压缩）</h2><blockquote><p><center>表-3 Raft 算法保证这些特性任何时刻都能成立</center></p></blockquote><table><thead><tr><th>性质</th><th>描述</th></tr></thead><tbody><tr><td>选举安全原则(Election Safety)</td><td>一个任期 <code>(Term)</code> 内最多允许有一个 <code>Leader</code> 被选上</td></tr><tr><td>领导者只增加原则(Leader Append-Only)</td><td><code>Leader</code> 永远不会覆盖或删除自己的日志，只会增加条目</td></tr><tr><td>日志匹配原则(Log Matching)</td><td>如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置的条目完全相同。</td></tr><tr><td>领导者完全原则(Leader Completeness)</td><td>如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期更大的 <code>Leader</code> 中</td></tr><tr><td>状态机安全原则(State Machine Safely)</td><td>如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目</td></tr></tbody></table><p><code>Raft</code> 通过首先选出一个领导人来实现一致性，然后给予领导人完全管理<code>复制日志（replicated log）</code>的责任。领导人接收来自客户端的日志条目，并把它们复制到其他的服务器上，领带人还要告诉服务器们什么时候将日志条目应用到它们的状态机是安全的。通过选出领导人能够简化复制日志的管理工作。例如，领导人能够决定将新的日志条目放到哪，而并不需要和其他的服务器商议，数据流被简化成从领导人流向其他服务器。如果领导人宕机或者和其他服务器失去连接，就可以选取下一个领导人。</p><p>通过选出 <code>Leader</code> 的方法，<code>Raft</code> 将共识问题分解为三个相对独立的子问题，这些子问题在下面的子部分中讨论:</p><ul><li><code>Leader</code> 选举: 当现有 <code>Leader</code> 失败时，必须选出新的 <code>Leader</code>。</li><li>日志复制（Log replication）： 领导人必须从客户端接收日志然后复制到集群中的其他服务器，并且强制要求其他服务器的日志保持和自己相同</li><li>安全性（Safety）： Raft 的关键的安全特性是 表-3 中提到的状态机安全原则（State Machine Safety）:如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目。5.4节阐述了 Raft 是如何保证这条原则的，解决方案涉及到一个对于选举机制另外的限制，这一部分会在 5.2节 中说明。</li></ul><p>在说明了一致性算法之后，本章会讨论有关可用性（availability）的问题和系统中时序（timing）的问题。</p><h2 id="5-1-Raft基础"><a href="#5-1-Raft基础" class="headerlink" title="5.1. Raft基础"></a>5.1. Raft基础</h2><p>一个 <code>Raft</code> 集群包括若干服务器；对于一个典型的 5 服务器集群，该集群能够容忍 2 台机器不能正常工作，而整个系统保持正常。在任意的时间，每一个服务器一定会处于以下三种状态中的一个：领导人、候选人、追随者。在正常情况下，只有一个服务器是领导人，剩下的服务器是追随者。追随者们是被动的：他们不会发送任何请求，只是响应来自领导人和候选人的请求。领导人来处理所有来自客户端的请求（如果一个客户端与追随者进行通信，追随者会将信息发送给领导人）。候选人是用来选取一个新的领导人的，这一部分会在 5.2节 进行阐释。图-4 阐述了这些状态，和它们之间的转换；它们的转换会在下边进行讨论。</p><blockquote><p>服务器的状态。追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。</p></blockquote><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fc9uv9fx6wj20hn07xt9z.jpg" alt="image"></p><blockquote><p>时间被分为一个个的任期（term），每一个任期的开始都是领导人选举。在成功选举之后，一个领导人会在任期内管理整个集群。如果选举失败，该任期就会因为没有领带人而结束。这个转变会在不同的时间的不同服务器上观察到。</p></blockquote><p><img src="http://wx3.sinaimg.cn/mw690/4858d6a8ly1fc9vx0s6l6j20ef05odg9.jpg" alt="image"></p><p>如 <code>图-5</code> 所示，<code>Raft</code> 算法将时间划分成为任意不同长度的 <code>任期（term）</code>。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），就像 <code>5.2</code> 节 所描述的那样，一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最少要有一个领导人。</p><p>不同的服务器可能会在任期内观察到多次不同的状态转换，在某些情况下，一台服务器可能看不到一次选举或者一个完整的任期。任期在 <code>Raft</code> 中充当逻辑时钟的角色，并且它们允许服务器检测过期的信息，比如过时的领导人。每一台服务器都存储着一个当前任期的数字，这个数字会单调的增加。当服务器之间进行通信时，会互相交换当前任期号；如果一台服务器的当前任期号比其它服务器的小，则更新为较大的任期号。如果一个候选人或者领导人意识到它的任期号过时了，它会立刻转换为追随者状态。如果一台服务器收到的请求的任期号是过时的，那么它会拒绝此次请求。</p><p><code>Raft</code> 中的服务器通过远程过程调用（RPC）来通信，基本的 <code>Raft</code> 一致性算法仅需要 2 种 RPC。<code>RequestVote RPC</code> 是候选人在选举过程中触发的（5.2节），<code>AppendEntries RPC</code> 是领导人触发的，为的是复制日志条目和提供一种 <code>心跳（heartbeat）</code> 机制（5.3节）。第7章加入了第三种 <code>RPC</code> 来在各个服务器之间传输 <code>快照（snapshot）</code>。如果服务器没有及时收到 RPC 的响应，它们会重试，并且它们能够并行的发出 RPC 来获得最好的性能。</p><h2 id="5-2-领导人选举"><a href="#5-2-领导人选举" class="headerlink" title="5.2. 领导人选举"></a>5.2. 领导人选举</h2><p><code>Raft</code> 使用一种 <code>心跳机制（heartbeat）</code> 来触发领导人的选取。当服务器启动时，它们会初始化为追随者。一太服务器会一直保持追随者的状态只要它们能够收到来自领导人或者候选人的有效 RPC。领导人会向所有追随者周期性发送 <code>心跳（heartbeat，不带有任何日志条目的 AppendEntries RPC）</code> 来保证它们的领导人地位。如果一个追随者在一个周期内没有收到心跳信息，就叫做 <code>选举超时（election timeout）</code> ,然后它就会假定没有可用的领导人并且开始一次选举来选出一个新的领导人。</p><p>为了开始选举，一个追随者会自增它的当前任期并且转换状态为候选人。然后，它会给自己投票并且给集群中的其他服务器发送 <code>RequestVote RPC</code> 。一个候选人会一直处于该状态，直到下列三种情形之一发生：</p><ul><li>它赢得了选举；</li><li>另一台服务器赢得了选举；</li><li>一段时间后没有任何一台服务器赢得了选举</li></ul><p>一个候选人如果在一个任期内收到了来自集群中大多数服务器的投票就会赢得选举。在一个任期内，一台服务器最多能给一个候选人投票，按照 <code>先到先服务原则（first-come-first-served）</code> （注意：在 5.4节 针对投票添加了一个额外的限制）。大多数原则使得在一个任期内最多有一个候选人能赢得选举 <code>（表-3   中提到的选举安全原则）</code> 。一旦有一个候选人赢得了选举，它就会成为 <code>领导人</code> 。然后它会像其他服务器发送心跳信息来建立自己的领导地位并且组织新的选举。</p><p>当一个 <code>候选人</code> 等待别人的选票时，它有可能会收到来自其他服务器发来的声明其为领导人的 <code>AppendEntries RPC</code> 。如果这个领导人的 <code>任期（包含在它的 RPC 中）</code> 比当前候选人的当前任期要大，则候选人认为该领导人合法，并且转换自己的状态为 <code>追随者</code> 。如果在这个 <code>RPC</code> 中的任期小于候选人的当前任期，则候选人会拒绝此次 <code>RPC</code>， 继续保持<code>候选人</code> 状态。</p><p>第三种情形是一个 <code>候选人</code> 既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 <code>RequestVote RPC</code>  来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。</p><p><code>Raft</code> 使用 <code>随机的选举超时时间</code> 来确保第三种情形很少发生，并且能够快速解决。为了防止在一开始是选票就被瓜分，选举超时时间是在一个固定的间隔内随机选出来的（例如，150~300ms）。这种机制使得在大多数情况下只有一个服务器会率先超时，它会在其它服务器超时之前赢得选举并且向其它服务器发送心跳信息。同样的机制被用于选票一开始被瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，在超时进行下一次选举之前一直等待。这能够减小在新的选举中一开始选票就被瓜分的可能性。9.3节 展示了这种方法能够快速的选出一个领导人。</p><p>选举是一个理解性引导我们设计替代算法的一个例子。最开始时，我们计划使用一种排名系统：给每一个候选人分配一个唯一的排名，用于在竞争的候选人之中选择领导人。如果一个候选人发现了另一个比它排名高的候选人，那么它会回到追随者的状态，这样排名高的候选人会很容易地赢得选举。但是我们发现这种方法在可用性方面有一点问题（一个低排名的服务器在高排名的服务器宕机后，需要等待超时才能再次成为候选人，但是如果它这么做的太快，它能重置选举领带人的过程）。我们对这个算法做了多次调整，但是每次调整后都会出现一些新的问题。最终我们认为随机重试的方法是更明确并且更易于理解的。</p><h2 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3.日志复制"></a>5.3.日志复制</h2><p>一旦选出了领导人，它就开始接收客户端的请求。每一个客户端请求都包含一条需要被 <code>复制状态机（replicated state machine）</code> 执行的命令。领导人把这条命令作为新的日志条目加入到它的日志中去，然后并行的向其他服务器发起 <code>AppendEntries RPC</code> ，要求其它服务器复制这个条目。当这个条目被安全的复制之后（下面的部分会详细阐述），领导人会将这个条目应用到它的状态机中并且会向客户端返回执行结果。如果追随者崩溃了或者运行缓慢或者是网络丢包了，领导人会无限的重试  <code>AppendEntries RPC</code> （甚至在它向客户端响应之后）知道所有的追随者最终存储了所有的日志条目。</p><blockquote><p>图-6：日志由有序编号的日志条目组成。每个日志条目包含它被创建时的任期号（每个方块中的数字），并且包含用于状态机执行的命令。如果一个条目能够被状态机安全执行，就被认为可以提交了。</p></blockquote><p><img src="http://wx1.sinaimg.cn/mw690/4858d6a8ly1fc9zgzzchkj20hl0d7wg4.jpg" alt="image"></p><p>日志就像 <code>图-6</code> 所示那样组织的。每个日志条目存储着一条被状态机执行的命令和当这条日志条目被领导人接收时的任期号。日志条目中的任期号用来检测在不同服务器上日志的不一致性，并且能确保 <code>图-3</code> 中的一些特性。每个日志条目也包含一个整数索引来表示它在日志中的位置。</p><p><code>领导人</code> 决定什么时候将日志条目应用到状态机是安全的；这种条目被称为 <code>可被提交（commited）</code> 。 <code>Raft</code>  保证 <code>可被提交（commited）的日志条目</code> 是持久化的并且最终会被所有可用的状态机执行。一旦被领导人创建的条目已经复制到了大多数的服务器上，这个条目就称为可被提交的（例如，图-6中的7号条目）。领导人日志中之前的条目都是可被提交的（commited），包括由之前的领导人创建的条目。5.4节将会讨论当领导人更替之后这条规则的应用问题的细节，并且也讨论了这种提交方式是安全的。领导人跟踪记录它所知道的被提交条目的最大索引值，并且这个索引值会包含在之后的 <code>AppendEntries RPC</code> 中（包括心跳 heartbeat 中），为的是让其他服务器都知道这条条目已经提交。一旦一个追随者知道了一个日志条目已经被提交，它会将该条目应用至本地的状态机（按照日志顺序）。</p><p>我们设计了 Raft 日志机制来保证不同服务器上日志的一致性。这样做不仅简化了系统的行为使得它更可预测，并且也是保证安全性不可或缺的一部分。Raft 保证以下特性，并且也保证了 <code>表-3</code> 中的日志匹配原则 <code>（Log Matching Property）</code> :</p><ul><li>如果在不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li><li>如果在不同日志中的两个条目有着相同的索引和任期号，则它们之间的所有条目都是完全一样的。</li></ul><p>第一条特性源于 <code>领导人</code> 在一个任期里在给定的一个日志索引位置最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，领导人会把新日志条目紧接着之前的条目的索引位置和任期号都包含在里面。如果追随者没有在它的日志中找到相同索引和任期号的日志，它就会拒绝新的日志条目。这个一致性检查就像一个归纳步骤：一开始空的日志的状态一定是满足日志匹配原则的，一致性检查保证了当日志添加时的日志匹配原则。因此，只要 AppendEntries 返回成功的时候，领导人就知道追随者们的日志和它的是一致的了。</p><blockquote><p>图-7：当最上边的领导人掌权之后，追随者日志可能有以下情况（a~f）。一个格子表示一个日志条目；格子中的数字是它的任期。一个追随者可能会丢失一些条目（a, b）；可能多出来一些未提交的条目（c, d）；或者两种情况都有（e, f）。例如，场景 f 在如下情况下就会发生：如果一台服务器在任期2时是领导人并且往它的日志中添加了一些条目，然后在将它们提交之前就宕机了，之后它很快重启了，成为了任期3的领导人，又往它的日志中添加了一些条目，然后在任期2和任期3中的条目提交之前它又宕机了并且几个任期内都一直处于宕机状态。</p></blockquote><p><img src="http://wx2.sinaimg.cn/mw690/4858d6a8ly1fca1aw93cnj20gf0baabf.jpg" alt="image"></p><p>在一般情况下， <code>领导人</code> 和 <code>追随者们</code> 的日志保持一致，因此 <code>AppendEntries</code> 一致性检查通常不会失败。然而， <code>领导人</code> 的崩溃会导致日志不一致（旧的领导人可能没有完全复制完日志中的所有条目）。这些不一致会导致一系列领导人和追随者崩溃。 <code>图-7</code>  阐述了一些 <code>追随者</code> 可能和 <code>新的领导人</code> 日志不同的情况。一个 <code>追随者</code> 可能会丢失掉领导人上的一些条目，也有可能包含一些 <code>领导人</code> 没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。</p><p>在 <code>Raft</code> 算法中， <code>领导人</code> 通过 <code>强制追随者们复制它的日志</code> 来处理日志的不一致。这就意味着，在追随者上的冲突日志会被领导者的日志覆盖。5.4节会说明当添加了一个额外的限制之后这是安全的。</p><p>为了使得追随者的日志同自己的一致， <code>领导人</code> 需要找到追随者同它的日志一致的地方，然后删除追随者在该位置之后的条目，然后将自己在该位置之后的条目发送给追随者。这些操作都在 <code>AppendEntries RPC</code> 进行一致性检查时完成。领导人给每一个追随者维护了一个 <code>nextIndex</code> ，它表示领导人将要发送给该追随者的下一条日志条目的索引。当一个领导人开始掌权时，它会将 <code>nextIndex</code> 初始化为 <code>它的最新的日志条目索引数+1（图-7 中的 11）</code> 。如果一个追随者的日志和领导者的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，领导人会将 <code>nextIndex</code> 递减然后重试  <code>AppendEntries RPC</code> 。最终 <code>nextIndex</code> 会达到一个领导人和追随者日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，追随者中冲突的日志条目都被移除了，并且添加所缺少的上了领导人的日志条目。一旦 <code>AppendEntries</code> 返回成功，追随者和领导人的日志就一致了，这样的状态会保持到该任期结束。</p><p>如果需要的话，算法还可以进行优化来减少 <code>AppendEntries RPC</code> 失败的次数。例如，当拒绝了一个 <code>AppendEntries</code> 请求，追随者可以记录下冲突日志条目的任期号和自己存储那个任期的最早的索引。通过这些信息，领导人能够直接递减nextIndex跨过那个任期内所有的冲突条目；这样的话，一个冲突的任期需要一次 <code>AppendEntries RPC</code>，而不是每一个冲突条目需要一次 <code>AppendEntries RPC</code>。在实践中，我们怀疑这种优化是否是必要的，因为 <code>AppendEntries</code> 一致性检查很少失败并且也不太可能出现大量的日志条目不一致的情况。</p><p>通过这种机制，一个领导人在掌权时不需要采取另外特殊的方式来恢复日志的一致性。它只需要使用一些常规的操作，通过响应 <code>AppendEntries</code> 一致性检查的失败能使得日志自动的趋于一致。一个领导人从来不会覆盖或者删除自己的日志（表-3 中的领导人只增加原则）。</p><p>这个日志复制机制展示了在第2章中阐述的所希望的一致性特性：<code>Raft</code> 能够接受，复制并且应用新的日志条目只要大部分的服务器是正常的。在通常情况下，一条新的日志条目可以在一轮 <code>RPC</code> 内完成在集群的大多数服务器上的复制；并且一个速度很慢的追随者并不会影响整体的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客为著名的 RAFT 一致性算法论文的中文翻译，论文名为&lt;a href=&quot;https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="Raft" scheme="https://destinywang.github.io/blog/categories/Raft/"/>
    
    
      <category term="Raft" scheme="https://destinywang.github.io/blog/tags/Raft/"/>
    
      <category term="文献翻译" scheme="https://destinywang.github.io/blog/tags/%E6%96%87%E7%8C%AE%E7%BF%BB%E8%AF%91/"/>
    
      <category term="分布式" scheme="https://destinywang.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Raft协议(1)——一致性原理分析</title>
    <link href="https://destinywang.github.io/blog/2018/04/14/Raft%E5%8D%8F%E8%AE%AE-1-%E2%80%94%E2%80%94%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://destinywang.github.io/blog/2018/04/14/Raft协议-1-——一致性原理分析/</id>
    <published>2018-04-14T13:47:19.000Z</published>
    <updated>2018-04-14T13:48:29.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在一个由 Raft 协议组织的集群中有三类角色：</p><ul><li>Leader（领袖）</li><li>Follower（群众）</li><li>Candidate（候选人）</li></ul><p>就像一个民主社会，领袖由民众投票选出。刚开始没有领袖，所有集群中的参与者都是群众，那么首先开启一轮大选，在大选期间所有群众都能参与竞选，这时所有群众的角色就变成了候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除领袖的候选人又变回群众角色服从领袖领导。这里提到一个概念「任期」，用术语 <code>Term</code> 表达。关于 Raft 协议的核心概念和术语就这么多而且和现实民主制度非常匹配，所以很容易理解。三类角色的变迁图如下，结合后面的选举过程来看很容易理解。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175331861-266461745.png" alt="image"></p><h1 id="Raft-集群中节点状态转化"><a href="#Raft-集群中节点状态转化" class="headerlink" title="Raft 集群中节点状态转化"></a>Raft 集群中节点状态转化</h1><p><img src="http://on-img.com/chart_image/5aca2824e4b0cfe274897f04.png" alt="image"></p><h1 id="Leader-选举过程"><a href="#Leader-选举过程" class="headerlink" title="Leader 选举过程"></a>Leader 选举过程</h1><p>在极简的思维下，一个最小的 Raft 民主集群需要三个参与者（如下图：A、B、C），这样才可能投出多数票。初始状态 ABC 都是 Follower，然后发起选举这时有三种可能情形发生。下图中前二种都能选出 Leader，第三种则表明本轮投票无效（Split Votes），每方都投给了自己，结果没有任何一方获得多数票。之后每个参与方随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。这里的关键就是随机 timeout，最先从 timeout 中恢复发起投票的一方向还在 timeout 中的另外两方请求投票，这时它们就只能投给对方了，很快达成一致。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175349689-522400583.png" alt="image"></p><p>选出 Leader 后，Leader 通过定期向所有 Follower 发送心跳信息维持其统治。若 Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了再次发起选主过程。</p><h1 id="Leader-节点对一致性的影响"><a href="#Leader-节点对一致性的影响" class="headerlink" title="Leader 节点对一致性的影响"></a>Leader 节点对一致性的影响</h1><p>Raft 协议强依赖 Leader 节点的可用性来确保集群数据的一致性。数据的流向只能从 Leader 节点向 Follower 节点转移。当 Client 向集群 Leader 节点提交数据后，Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，确保至少集群中超过半数节点已接收到数据后再向 Client 确认数据已接收。一旦向 Client 发出数据接收 Ack 响应后，表明此时数据状态进入已提交（Committed），Leader 节点再向 Follower 节点发通知告知该数据状态已提交。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175358173-526445555.png" alt="image"></p><p>在这个过程中，主节点可能在任意阶段挂掉，看下 Raft 协议如何针对不同阶段保障数据一致性的。</p><h2 id="数据到达-Leader-节点前"><a href="#数据到达-Leader-节点前" class="headerlink" title="数据到达 Leader 节点前"></a>数据到达 Leader 节点前</h2><p>这个阶段 Leader 挂掉不影响一致性，不多说。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175405705-1452838896.png" alt="image"></p><h2 id="数据到达-Leader-节点，但未复制到-Follower-节点"><a href="#数据到达-Leader-节点，但未复制到-Follower-节点" class="headerlink" title="数据到达 Leader 节点，但未复制到 Follower 节点"></a>数据到达 Leader 节点，但未复制到 Follower 节点</h2><p>这个阶段 Leader 挂掉，数据属于未提交状态，Client 不会收到 Ack 会认为超时失败可安全发起重试。Follower 节点上没有该数据，重新选主后 Client 重试重新提交可成功。原来的 Leader 节点恢复后作为 Follower 加入集群重新从当前任期的新 Leader 处同步数据，强制保持和 Leader 数据一致。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175412580-649716029.png" alt="image"></p><h2 id="数据到达-Leader-节点，成功复制到-Follower-所有节点，但还未向-Leader响应"><a href="#数据到达-Leader-节点，成功复制到-Follower-所有节点，但还未向-Leader响应" class="headerlink" title="数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader响应"></a>数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader响应</h2><p>这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态（Uncommitted）但保持一致，重新选出 Leader 后可完成数据提交，此时 Client 由于不知到底提交成功没有，可重试提交。针对这种情况 Raft 要求 RPC 请求实现幂等性，也就是要实现内部去重机制。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175419501-326023047.png" alt="image"></p><h2 id="数据到达-Leader-节点，成功复制到-Follower-部分节点，但还未向-Leader-响应接受"><a href="#数据到达-Leader-节点，成功复制到-Follower-部分节点，但还未向-Leader-响应接受" class="headerlink" title="数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接受"></a>数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接受</h2><p>这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态（Uncommitted）且不一致，Raft 协议要求投票只能投给拥有最新数据的节点。所以拥有最新数据的节点会被选为 Leader 再强制同步数据到 Follower，数据不会丢失并最终一致。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175427314-1771762822.png" alt="image"></p><h2 id="数据到达-Leader-节点，成功复制到-Follower-所有或多数节点，数据在所有节点都处于已提交状态，但还未响应-Client"><a href="#数据到达-Leader-节点，成功复制到-Follower-所有或多数节点，数据在所有节点都处于已提交状态，但还未响应-Client" class="headerlink" title="数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client"></a>数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client</h2><p>这个阶段 Leader 挂掉，Cluster 内部数据其实已经是一致的，Client 重复重试基于幂等策略对一致性无影响。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175628111-980324469.png" alt="image"></p><h2 id="网络分区导致的脑裂情况，出现双-Leader"><a href="#网络分区导致的脑裂情况，出现双-Leader" class="headerlink" title="网络分区导致的脑裂情况，出现双 Leader"></a>网络分区导致的脑裂情况，出现双 Leader</h2><p>网络分区将原先的 Leader 节点和 Follower 节点分隔开，Follower 收不到 Leader 的心跳将发起选举产生新的 Leader。这时就产生了双 Leader，原先的 Leader 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 Leader 提交数据可以提交成功，网络恢复后旧的 Leader 发现集群中有更新任期（Term）的新 Leader 则自动降级为 Follower 并从新 Leader 处同步数据达成集群数据一致。</p><p><img src="http://images2015.cnblogs.com/blog/815275/201603/815275-20160301175637220-1693295968.png" alt="image"></p><blockquote><p>算法以正确性、高效性、简洁性作为主要设计目标。<br>虽然这些都是很有价值的目标，但这些目标都不会达成直到开发者写出一个可用的实现。<br>所以我们相信可理解性同样重要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在一个由 Raft 协议组织的集群中有三类角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader（领袖）&lt;/li&gt;
&lt;li&gt;Follower（群众）
      
    
    </summary>
    
      <category term="Raft" scheme="https://destinywang.github.io/blog/categories/Raft/"/>
    
    
      <category term="Raft" scheme="https://destinywang.github.io/blog/tags/Raft/"/>
    
      <category term="一致性算法" scheme="https://destinywang.github.io/blog/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="https://destinywang.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ-(5)——ActiveMQ结合Spring开发</title>
    <link href="https://destinywang.github.io/blog/2018/04/14/ActiveMQ-5-%E2%80%94%E2%80%94ActiveMQ%E7%BB%93%E5%90%88Spring%E5%BC%80%E5%8F%91/"/>
    <id>https://destinywang.github.io/blog/2018/04/14/ActiveMQ-5-——ActiveMQ结合Spring开发/</id>
    <published>2018-04-14T10:45:00.000Z</published>
    <updated>2018-04-14T10:46:00.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在Spring中配置jmsTemplate"><a href="#在Spring中配置jmsTemplate" class="headerlink" title="在Spring中配置jmsTemplate"></a>在Spring中配置<code>jmsTemplate</code></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JMS连接池工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.pool.PooledConnectionFactory"</span> <span class="attr">destroy-method</span>=<span class="string">"stop"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://localhost:61616"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxConnections"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--目的地--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"destination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"spring-queue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jmsFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.support.converter.SimpleMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="如果是topic"><a href="#如果是topic" class="headerlink" title="如果是topic"></a>如果是topic</h2><ol><li>添加<code>topic</code>的配置</li><li><p>修改<code>jmsTemplate</code>配置中的<code>defaultDestination</code></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JMS连接池工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsFactory"</span>     <span class="attr">class</span>=<span class="string">"org.apache.activemq.pool.PooledConnectionFactory"</span>     <span class="attr">destroy-method</span>=<span class="string">"stop"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://localhost:61616"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxConnections"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--目的地--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"destination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"spring-topic"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jmsFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.support.converter.SimpleMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="如果在Spring中配置消费者的话，就不需要启动消费者"><a href="#如果在Spring中配置消费者的话，就不需要启动消费者" class="headerlink" title="如果在Spring中配置消费者的话，就不需要启动消费者"></a>如果在Spring中配置消费者的话，就不需要启动消费者</h2><p>相当于注册了一个默认消息监听器</p><p>当JMS Provider接受到消息之后就会触发<code>listener</code>的<code>onMessage()</code>方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsContainer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jmsFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"messageListener"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span><span class="attr">class</span>=<span class="string">"org.destiny.activemq.spring.MyMessageListener"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.destiny.activemq.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"receive: "</span> + textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>Camel框架支持大量的企业集成模式，可以大大简化集成组件间的大量服务和复杂的消息流。而Spring更注重简单性。</li><li>Spring消息发送的核心架构是<code>JmsTemplate</code>，隔离了像打开、关闭<code>Session</code>和<code>Producer</code>等操作。因此应用开发人员仅仅需要关注实际的业务逻辑。但<code>JmsTemplate</code>损害了ActiveMQ的<code>PooledConnectionFactory</code>对<code>Session</code>和消息<code>Producer</code>的缓存机制带来的性能提升。</li><li>新的Spring中，可以设置<code>org.springframework.jms.connection.CachingConnectionFactory</code>的<code>sessionCacheSize</code>，或者直接使用ActiveMQ的<code>PooledConnectionFactory</code>。</li><li>不建议使用<code>JmsTemplate</code>的<code>receive()</code>，因为<code>JmsTemplate</code>上的所有调用都是同步的，这意味着调用的线程会阻塞，直到方法返回，性能影响较大。</li><li>尽量使用<code>DefaultMessageListenerContainer</code>，它允许异步接受消息并缓存session和消息<code>Consuer</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h1&gt;&lt;h2 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h2&gt;&lt;figur
      
    
    </summary>
    
      <category term="ActiveMQ" scheme="https://destinywang.github.io/blog/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="https://destinywang.github.io/blog/tags/ActiveMQ/"/>
    
      <category term="JMS" scheme="https://destinywang.github.io/blog/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ(4)——Broker的启动方式</title>
    <link href="https://destinywang.github.io/blog/2018/04/12/ActiveMQ-4-%E2%80%94%E2%80%94Broker%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://destinywang.github.io/blog/2018/04/12/ActiveMQ-4-——Broker的启动方式/</id>
    <published>2018-04-11T16:22:37.000Z</published>
    <updated>2018-04-11T16:23:25.354Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Broker：相当于一个ActiveMQ服务器实例。</li><li>命令行启动参数示例<ul><li><code>activemq start</code>：默认使用<code>acitvemq.xml来启动</code></li><li><code>activemq start xbean:file:../conf/activemq.xml</code>：使用指定的配置文件来启动。</li></ul></li><li>用ActiveMQ来构建Java应用<br>用ActiveMQ Broker作为独立的消息服务器来构建JAVA应用。ActiveMQ也支持在VM中通信基于嵌入式的Broker，能够无缝集成其他Java应用。</li></ul><h1 id="嵌入式Broker"><a href="#嵌入式Broker" class="headerlink" title="嵌入式Broker"></a>嵌入式Broker</h1><h2 id="BrokerService启动Broker"><a href="#BrokerService启动Broker" class="headerlink" title="BrokerService启动Broker"></a>BrokerService启动Broker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 开启ActiveMQ Broker</span></span><br><span class="line">    BrokerService brokerService = <span class="keyword">new</span> BrokerService();</span><br><span class="line">    brokerService.setUseJmx(<span class="keyword">true</span>);</span><br><span class="line">    brokerService.addConnector(<span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line">    brokerService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-11/6804604.jpg" alt=""></p><h2 id="BrokerFactory启动Broker"><a href="#BrokerFactory启动Broker" class="headerlink" title="BrokerFactory启动Broker"></a>BrokerFactory启动Broker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 开启ActiveMQ Broker</span></span><br><span class="line">    String uri = <span class="string">"properties:broker.properties"</span>;</span><br><span class="line">    BrokerService brokerService = BrokerFactory.createBroker(<span class="keyword">new</span> URI(uri));</span><br><span class="line">    brokerService.addConnector(<span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line">    brokerService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件<code>broker.properties</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useJmx=true</span><br><span class="line">persistent=false</span><br><span class="line">brokerName=Cheese</span><br></pre></td></tr></table></figure></p><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-11/11567085.jpg" alt=""></p><h1 id="利用Spring集成Broker"><a href="#利用Spring集成Broker" class="headerlink" title="利用Spring集成Broker"></a>利用Spring集成Broker</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"broker"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.broker.BrokerService"</span> <span class="attr">init-method</span>=<span class="string">"start"</span> <span class="attr">destroy-method</span>=<span class="string">"stop"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerName"</span> <span class="attr">value</span>=<span class="string">"myBroker"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"persistent"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transportConnectorURIs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>tcp://localhost:61616<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://oetw0yrii.bkt.clouddn.com/18-4-11/54820003.jpg" alt=""></p><h1 id="启动多个Broker"><a href="#启动多个Broker" class="headerlink" title="启动多个Broker"></a>启动多个Broker</h1><p>如果需要启动多个Broker，那么需要为每个Broker设置一个名字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Broker：相当于一个ActiveMQ服务器实例。&lt;/li&gt;
&lt;li&gt;命令行启动参数示例&lt;ul&gt;
&lt;li&gt;&lt;code&gt;activemq start&lt;/code&gt;：默认使用&lt;code&gt;acitvemq.xml来启动&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a
      
    
    </summary>
    
      <category term="ActiveMQ" scheme="https://destinywang.github.io/blog/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="https://destinywang.github.io/blog/tags/ActiveMQ/"/>
    
      <category term="JMS" scheme="https://destinywang.github.io/blog/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ(3)——JMS可靠性机制</title>
    <link href="https://destinywang.github.io/blog/2018/04/12/ActiveMQ-3-%E2%80%94%E2%80%94JMS%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6/"/>
    <id>https://destinywang.github.io/blog/2018/04/12/ActiveMQ-3-——JMS可靠性机制/</id>
    <published>2018-04-11T16:20:25.000Z</published>
    <updated>2018-04-11T16:24:44.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息接受确认"><a href="#消息接受确认" class="headerlink" title="消息接受确认"></a>消息接受确认</h1><p>JMS消息只有在被确认之后，才认为已经被成功地消费了。<br>消费的成功通常包含三个阶段：客户端接受消息、客户端处理消息和消息被确认。<br>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。该参数有三个可选方案：</p><h2 id="Session-AUTO-ACKNOWLEDGE"><a href="#Session-AUTO-ACKNOWLEDGE" class="headerlink" title="Session.AUTO_ACKNOWLEDGE"></a><code>Session.AUTO_ACKNOWLEDGE</code></h2><p>当客户成功的从<code>receive()</code>方法返回的时候，或者从<code>MessageListener.onMessage()</code>方法成功返回的时候，会话自动确认客户端收到的消息。</p><h2 id="Session-CLIENT-ACKNOWLEDGE"><a href="#Session-CLIENT-ACKNOWLEDGE" class="headerlink" title="Session.CLIENT_ACKNOWLEDGE"></a><code>Session.CLIENT_ACKNOWLEDGE</code></h2><p>客户端通过调用消息的<code>acknowledge()</code>方法确认消息。在这种模式中，确认是在会话层上进行，确认一个被消费的消息将自动确认所有已被会话消费的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.CLIENT_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><h2 id="Session-DUPS-ACKNOWLEDGE"><a href="#Session-DUPS-ACKNOWLEDGE" class="headerlink" title="Session.DUPS_ACKNOWLEDGE"></a><code>Session.DUPS_ACKNOWLEDGE</code></h2><p>只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS Provider必须把消息头的JMSRedelivered字段设置为true</p><h1 id="消息的持久性，JMS支持两种消息提交模式"><a href="#消息的持久性，JMS支持两种消息提交模式" class="headerlink" title="消息的持久性，JMS支持两种消息提交模式"></a>消息的持久性，JMS支持两种消息提交模式</h1><h2 id="PERSISTENT"><a href="#PERSISTENT" class="headerlink" title="PERSISTENT"></a>PERSISTENT</h2><p>JMS Provider永久保存消息，以保证消息不会因为JMS Provider的失败而丢失。</p><h2 id="NON-PERSISTENT"><a href="#NON-PERSISTENT" class="headerlink" title="NON_PERSISTENT"></a>NON_PERSISTENT</h2><p>不要求JMS Provider持久保存消息</p><h1 id="消息的临时目的地"><a href="#消息的临时目的地" class="headerlink" title="消息的临时目的地"></a>消息的临时目的地</h1><p>可以通过Session的<code>createTemporaryQueue()</code>和<code>createTemporaryTopic()</code>方法来创建临时目的地。他们的存在时间只限于创建他们的连接所保持的时间，只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。</p><h1 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h1><p>在一个JMS客户端，可以使用本地事务来组合消息的发送和签收。Session接口提供了<code>commit()</code>和<code>rollback()</code>方法。</p><ul><li>事务提交意味着生产的所有消息被发送，消费的所有消息被确认。</li><li>事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非他们已过期。</li></ul><h1 id="PTP模型"><a href="#PTP模型" class="headerlink" title="PTP模型"></a>PTP模型</h1><pre><code>该模型定义了客户端如何向队列发送消息，从队列接受消息。</code></pre><p>PTP模型是基于队列的，生产者发消息到队列，消费者从队列接受消息，队列使得消息的异步传输成为可能。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>Session在关闭时，如果有消息已经被接受，但还没有确认，那么当消费者下次连接到相同的队列时，这些消息还会被再次接受。</li><li>如果用户在<code>receive()</code>方法中设定了消息选择条件，那么不符合条件的消息会留在队列中。</li><li>队列可以长久地保存消息直到消费者收到消息，消费者不需要因为担心消息丢失而时刻与队列保持激活的连接状态。</li></ol><h1 id="Pub-Sub模型"><a href="#Pub-Sub模型" class="headerlink" title="Pub/Sub模型"></a>Pub/Sub模型</h1><pre><code>该模型定义了如何向一个内容节点发布和订阅消息。</code></pre><p>主题可以被认为是消息的传输中介，发布者发布消息到主题，订阅者从主题订阅消息，二者相互独立，不需要接触。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>消息订阅分为非持久订阅和持久订阅<ol><li>非持久订阅时，只有当客户端处于激活状态才能收到某个主题的消息；离线时发布到主题的消息将会丢失。</li><li>持久订阅时，客户端向JMS Provider注册一个自己身份的ID，当客户端处于离线状态时，Provider会为这个ID保存所有发送到主题的消息。</li></ol></li><li>如果用户在<code>receive()</code>方法中设定了消息选择条件，那么不符合条件的消息不会被接收。</li><li>非持久订阅状态下，不能恢复或重新派送一个未签收的消息。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息接受确认&quot;&gt;&lt;a href=&quot;#消息接受确认&quot; class=&quot;headerlink&quot; title=&quot;消息接受确认&quot;&gt;&lt;/a&gt;消息接受确认&lt;/h1&gt;&lt;p&gt;JMS消息只有在被确认之后，才认为已经被成功地消费了。&lt;br&gt;消费的成功通常包含三个阶段：客户端接受消息、客
      
    
    </summary>
    
      <category term="ActiveMQ" scheme="https://destinywang.github.io/blog/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="https://destinywang.github.io/blog/tags/ActiveMQ/"/>
    
      <category term="JMS" scheme="https://destinywang.github.io/blog/tags/JMS/"/>
    
  </entry>
  
</feed>
