<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://destinywang.github.io/blog/"/>
  <updated>2021-01-05T14:06:55.226Z</updated>
  <id>https://destinywang.github.io/blog/</id>
  
  <author>
    <name>destiny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 实现 DevOps</title>
    <link href="https://destinywang.github.io/blog/2020/12/20/Docker-%E5%AE%9E%E7%8E%B0-DevOps/"/>
    <id>https://destinywang.github.io/blog/2020/12/20/Docker-实现-DevOps/</id>
    <published>2020-12-20T03:38:49.000Z</published>
    <updated>2021-01-05T14:06:55.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-容器技术和-Docker-简介"><a href="#1-容器技术和-Docker-简介" class="headerlink" title="1. 容器技术和 Docker 简介"></a>1. 容器技术和 Docker 简介</h2><h3 id="1-1-什么是-Docker"><a href="#1-1-什么是-Docker" class="headerlink" title="1.1 什么是 Docker"></a>1.1 什么是 Docker</h3><h3 id="1-2-Docker-的作用"><a href="#1-2-Docker-的作用" class="headerlink" title="1.2 Docker 的作用"></a>1.2 Docker 的作用</h3><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">简化配置</td><td style="text-align:left">容器最重要的功能, 能够实现将源代码, 运行环境和配置一起打包到容器中, 容器可以运行在不同的环境中</td></tr><tr><td style="text-align:center">代码流水线管理</td></tr><tr><td style="text-align:center">提高开发效率</td><td style="text-align:left">除了简化配置, 还可以最大限度保持本地环境, 测试环境和开发环境一致</td></tr><tr><td style="text-align:center">隔离应用</td></tr><tr><td style="text-align:center">整合服务器</td></tr><tr><td style="text-align:center">调试能力</td></tr><tr><td style="text-align:center">多租户</td></tr><tr><td style="text-align:center">快速部署</td></tr></tbody></table><h3 id="1-3-Docker-和-Kubernetes-的关系"><a href="#1-3-Docker-和-Kubernetes-的关系" class="headerlink" title="1.3 Docker 和 Kubernetes 的关系"></a>1.3 Docker 和 Kubernetes 的关系</h3><blockquote><p>Kubernetes 是一个容器编排工具, 用于管理容器的生命周期, 包括容器的创建, 管理, 调度, 运维等</p></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/103655448-3bb5d280-4fa2-11eb-9209-e2506eed3952.png" alt="image"></p><h3 id="1-4-DevOps-简介"><a href="#1-4-DevOps-简介" class="headerlink" title="1.4 DevOps 简介"></a>1.4 DevOps 简介</h3><blockquote><p>DevOps = 文化 + 过程 + 工具</p></blockquote><table><thead><tr><th style="text-align:center">文化</th><th style="text-align:center">过程</th><th style="text-align:center">工具</th></tr></thead><tbody><tr><td style="text-align:center">信任和尊敬<br>敏捷的目标<br>开发的沟通</td><td style="text-align:center">发布计划<br>持续集成<br>持续发布<br>持续测试<br>持续监控<br>持续改进</td><td style="text-align:center">版本管理<br>自动化<br>部署<br>监控</td></tr></tbody></table><h2 id="2-Docker-环境的各种搭建方法"><a href="#2-Docker-环境的各种搭建方法" class="headerlink" title="2. Docker 环境的各种搭建方法"></a>2. Docker 环境的各种搭建方法</h2><h2 id="3-Docker-的镜像和容器"><a href="#3-Docker-的镜像和容器" class="headerlink" title="3. Docker 的镜像和容器"></a>3. Docker 的镜像和容器</h2><h2 id="4-Docker-的网络"><a href="#4-Docker-的网络" class="headerlink" title="4. Docker 的网络"></a>4. Docker 的网络</h2><h2 id="5-Docker-的持久化存储和数据共享"><a href="#5-Docker-的持久化存储和数据共享" class="headerlink" title="5. Docker 的持久化存储和数据共享"></a>5. Docker 的持久化存储和数据共享</h2><h2 id="6-Docker-Compose-多容器部署"><a href="#6-Docker-Compose-多容器部署" class="headerlink" title="6. Docker Compose 多容器部署"></a>6. Docker Compose 多容器部署</h2><h2 id="7-容器编排工具-Docker-Swarm"><a href="#7-容器编排工具-Docker-Swarm" class="headerlink" title="7. 容器编排工具 Docker Swarm"></a>7. 容器编排工具 Docker Swarm</h2><h2 id="8-Docker-Cloud-和-Docker-企业版"><a href="#8-Docker-Cloud-和-Docker-企业版" class="headerlink" title="8. Docker Cloud 和 Docker 企业版"></a>8. Docker Cloud 和 Docker 企业版</h2><h2 id="9-容器编排工具-Kubernetes"><a href="#9-容器编排工具-Kubernetes" class="headerlink" title="9. 容器编排工具 Kubernetes"></a>9. 容器编排工具 Kubernetes</h2><h2 id="10-容器的运维和监控"><a href="#10-容器的运维和监控" class="headerlink" title="10.容器的运维和监控"></a>10.容器的运维和监控</h2><h2 id="11-Docker-DevOps-实战"><a href="#11-Docker-DevOps-实战" class="headerlink" title="11. Docker+DevOps 实战"></a>11. Docker+DevOps 实战</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-容器技术和-Docker-简介&quot;&gt;&lt;a href=&quot;#1-容器技术和-Docker-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 容器技术和 Docker 简介&quot;&gt;&lt;/a&gt;1. 容器技术和 Docker 简介&lt;/h2&gt;&lt;h3 id=&quot;1-1
      
    
    </summary>
    
      <category term="Docker" scheme="https://destinywang.github.io/blog/categories/Docker/"/>
    
      <category term="DevOps" scheme="https://destinywang.github.io/blog/categories/Docker/DevOps/"/>
    
    
      <category term="Docker" scheme="https://destinywang.github.io/blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>GRPC实战</title>
    <link href="https://destinywang.github.io/blog/2020/12/02/GRPC%E5%AE%9E%E6%88%98/"/>
    <id>https://destinywang.github.io/blog/2020/12/02/GRPC实战/</id>
    <published>2020-12-02T13:08:55.000Z</published>
    <updated>2020-12-20T03:37:33.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>GRPC 是一个语言中立, 平台中立的 RPC 框架, 支持 Java, C++, Golang, php 等多个语言版本, 使用 ProtoBuf 作为传输协议 .</p><p><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">GRPC golang 版本</a></p><h3 id="1-1-Protobuf"><a href="#1-1-Protobuf" class="headerlink" title="1.1 Protobuf"></a>1.1 Protobuf</h3><p><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">Github 地址</a></p><p><a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">Golang 库地址</a></p><p>Google Protocol Buffer, 是 google 的一种语言中立和平台中立的数据交换格式, google 提供了多种语言的实现, 包括 Java, C#, C++, go 和 Python, 每一种都实现了包含对应语言的编译器及库文件, 由于它是一种二进制格式, 因此相比 XML, JSON 等在传输时占用带宽更小, 是一种效率和兼容性都比较优秀的二进制数据传输格式, 可以用于网络传输, 数据存储等多个领域.</p><p><a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.14.0" target="_blank" rel="noopener">proto release 包下载</a></p><p>再将 protoc 文件路径 (如 <code>/usr/local/bin/protoc</code>) 添加的环境变量中, protoc 是 protobuf 文件的编译器, 可以把 <code>.proto</code> 文件转译成各种编程语言对应的源码, 包含数据类型定义, 调用接口等.</p><p>安装编译出 go 文件的插件: <a href="https://github.com/golang/protobuf/protoc-gen-go" target="_blank" rel="noopener">proto-gen-go</a>, 执行 go get 后会在 <code>$GOPAHT/bin</code> 目录下生成可执行文件 <code>.protobuf</code> 的编译器插件 <code>protoc-gen-go</code>, 当我们使用命令 <code>protoc --go_out=$output_dir $input_dir/target.proto</code> 转译 proto 文件时, 其中 <code>--go_out=</code> 表示生成 go 文件, protoc 会自动寻找 GOPATH 下的 proto-gen-go 执行文件.</p><p><img src="https://user-images.githubusercontent.com/17758731/101018218-2534e980-35a6-11eb-90bf-4457c5e3e137.png" alt="image"></p><h2 id="2-QuickStart"><a href="#2-QuickStart" class="headerlink" title="2. QuickStart"></a>2. QuickStart</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="2-1-创建中间文件"><a href="#2-1-创建中间文件" class="headerlink" title="2.1 创建中间文件"></a>2.1 创建中间文件</h3><figure class="highlight pb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span><span class="comment">;</span></span><br><span class="line">package services<span class="comment">;</span></span><br><span class="line">message ProdRequest &#123;</span><br><span class="line">  int32 prod_id = 1<span class="comment">; // 商品 id</span></span><br><span class="line">&#125;</span><br><span class="line">message ProdResponse &#123;</span><br><span class="line">  int32 prod_stock = 1<span class="comment">; // 商品库存</span></span><br><span class="line">&#125;</span><br><span class="line">service ProdService &#123;</span><br><span class="line">  rpc GetProdStock(ProdRequest) returns (ProdResponse)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后执行 <code>protoc --go_out=${target_dir} target.proto</code>, 则可以将当前路径下的 target.proto 转译成 go 源代码并保存在 <code>target_dir</code> 路径下</p><h3 id="2-2-服务端代码"><a href="#2-2-服务端代码" class="headerlink" title="2.2 服务端代码"></a>2.2 服务端代码</h3><p>服务端需要实现 pb 已生成的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProdServiceServer is the server API for ProdService service.</span></span><br><span class="line"><span class="keyword">type</span> ProdServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetProdStock(context.Context, *ProdRequest) (*ProdResponse, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是实现代码</span></span><br><span class="line"><span class="keyword">type</span> ProdService <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ProdService)</span> <span class="title">GetProdStock</span><span class="params">(ctx context.Context, req *ProdRequest)</span> <span class="params">(*ProdResponse, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ProdResponse&#123;</span><br><span class="line">        state:         protoimpl.MessageState&#123;&#125;,</span><br><span class="line">        sizeCache:     <span class="number">0</span>,</span><br><span class="line">        unknownFields: <span class="literal">nil</span>,</span><br><span class="line">        ProdStock:     rand.Int31n(<span class="number">1000</span>),</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端启动函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rpcServer := grpc.NewServer()</span><br><span class="line">    services.RegisterProdServiceServer(rpcServer, <span class="built_in">new</span>(services.ProdService))</span><br><span class="line">    <span class="comment">// 监听地址</span></span><br><span class="line">    listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8081"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.Error(<span class="string">"listen fail"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    logrus.Info(<span class="string">"listen"</span>)</span><br><span class="line">    <span class="keyword">if</span> err = rpcServer.Serve(listen); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         logrus.Error(<span class="string">"grpc serve fail"</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    logrus.Info(<span class="string">"serve"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-客户端代码"><a href="#2-3-客户端代码" class="headerlink" title="2.3 客户端代码"></a>2.3 客户端代码</h3><p>客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    conn, err := grpc.Dial(<span class="string">":8081"</span>, grpc.WithInsecure()) <span class="comment">// WithInsecure 表示不使用证书</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.WithError(err).Error(<span class="string">"dial fail"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> conn != <span class="literal">nil</span> &#123;</span><br><span class="line">            _ = conn.Close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    prodServiceClient := services.NewProdServiceClient(conn)</span><br><span class="line">    prodResponse, err := prodServiceClient.GetProdStock(context.Background(), &amp;services.ProdRequest&#123;ProdId: <span class="number">10</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.WithError(err).Error(<span class="string">"rpc fail"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    logrus.Infof(<span class="string">"prodResp=[%+v]"</span>, prodResponse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-自签证书"><a href="#2-4-自签证书" class="headerlink" title="2.4 自签证书"></a>2.4 自签证书</h3><p>在生产环境中, 一般都会通过 SSL 证书来保证 RPC 通信的安全性, GRPC 也默认实现开启了字签证书认证, 本地调试下可以显式关闭:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">":8081"</span>, grpc.WithInsecure())</span><br></pre></td></tr></table></figure><p>本章我们尝试在 MacOS 环境下申请自签名的 SSL 证书</p><h4 id="2-4-1-进入管理员"><a href="#2-4-1-进入管理员" class="headerlink" title="2.4.1 进入管理员"></a>2.4.1 进入管理员</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><h4 id="2-4-2-创建-rootCA-key"><a href="#2-4-2-创建-rootCA-key" class="headerlink" title="2.4.2 创建 rootCA.key"></a>2.4.2 创建 rootCA.key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -des3 -out rootCA.key 2048</span><br><span class="line"></span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">....................+++</span><br><span class="line">.............................+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> rootCA.key:</span><br><span class="line">Verifying - Enter pass phrase <span class="keyword">for</span> rootCA.key:</span><br></pre></td></tr></table></figure><p>此时需要输入密码, 密码需要记住, 后面还会用到.</p><h4 id="2-4-3-创建-rootCA-pem"><a href="#2-4-3-创建-rootCA-pem" class="headerlink" title="2.4.3 创建 rootCA.pem"></a>2.4.3 创建 rootCA.pem</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 -out rootCA.pem</span><br><span class="line"></span><br><span class="line">Enter pass phrase <span class="keyword">for</span> rootCA.key:</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">'.'</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) []:CN</span><br><span class="line">State or Province Name (full name) []:shanxi</span><br><span class="line">Locality Name (eg, city) []:xian</span><br><span class="line">Organization Name (eg, company) []:wk</span><br><span class="line">Organizational Unit Name (eg, section) []:wk</span><br><span class="line">Common Name (eg, fully qualified host name) []:destiny.com</span><br><span class="line">Email Address []:destinywk@163.com</span><br></pre></td></tr></table></figure><p>省市公司名称等信息都可以随便填写, 此外这里需要输入 rootCA.key 的密码</p><h4 id="2-4-4-创建-v3-ext-文件"><a href="#2-4-4-创建-v3-ext-文件" class="headerlink" title="2.4.4 创建 v3.ext 文件"></a>2.4.4 创建 v3.ext 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage=digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName=@alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = 192.168.2.10 # 本机 ip</span><br></pre></td></tr></table></figure><h4 id="2-4-5-创建-server-csr-和-server-key"><a href="#2-4-5-创建-server-csr-和-server-key" class="headerlink" title="2.4.5 创建 server.csr 和 server.key"></a>2.4.5 创建 server.csr 和 server.key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key</span><br><span class="line"></span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">..............................+++</span><br><span class="line">................................................................+++</span><br><span class="line">writing new private key to <span class="string">'server.key'</span></span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">'.'</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) []:CN</span><br><span class="line">State or Province Name (full name) []:shanxi</span><br><span class="line">Locality Name (eg, city) []:xian</span><br><span class="line">Organization Name (eg, company) []:wk</span><br><span class="line">Organizational Unit Name (eg, section) []:wk</span><br><span class="line">Common Name (eg, fully qualified host name) []:destiny.com</span><br><span class="line">Email Address []:destinywk@163.com</span><br><span class="line"></span><br><span class="line">Please enter the following <span class="string">'extra'</span> attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br></pre></td></tr></table></figure><h4 id="2-4-6-创建-server-crt"><a href="#2-4-6-创建-server-crt" class="headerlink" title="2.4.6 创建 server.crt"></a>2.4.6 创建 server.crt</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -req -<span class="keyword">in</span> ./server.csr -signkey ./server.key -out ./server.crt</span><br><span class="line"></span><br><span class="line">Signature ok</span><br><span class="line">subject=/C=CN/ST=shanxi/L=xian/O=wk/OU=wk/CN=192.168.2.10/emailAddress=destinywk@163.com</span><br><span class="line">Getting Private key</span><br></pre></td></tr></table></figure><h4 id="2-4-7-查看证书"><a href="#2-4-7-查看证书" class="headerlink" title="2.4.7 查看证书"></a>2.4.7 查看证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ll ~/dev/ssl</span><br><span class="line">total 48</span><br><span class="line">-rw-r--r--  1 destiny  staff     8B 12  1 19:49 password</span><br><span class="line">-rw-r--r--  1 root     staff   1.2K 12  1 22:28 server.crt</span><br><span class="line">-rw-r--r--  1 root     staff   1.0K 12  1 20:47 server.csr</span><br><span class="line">-rw-r--r--  1 root     staff   1.7K 12  1 20:47 server.key</span><br><span class="line">-rw-r--r--  1 root     staff   1.6K 12  1 22:28 server_no_passwd.key</span><br><span class="line">-rw-r--r--  1 root     staff   199B 12  1 20:45 v3.ext</span><br></pre></td></tr></table></figure><p>生成 server.crt 即是所需的证书</p><h3 id="2-5-GRPC-整合证书"><a href="#2-5-GRPC-整合证书" class="headerlink" title="2.5 GRPC 整合证书"></a>2.5 GRPC 整合证书</h3><h4 id="2-5-1-服务端代码"><a href="#2-5-1-服务端代码" class="headerlink" title="2.5.1 服务端代码"></a>2.5.1 服务端代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 添加证书验证</span></span><br><span class="line">    transportCredentials, err := credentials.NewServerTLSFromFile(<span class="string">"grpc_test/keys/server.crt"</span>, <span class="string">"grpc_test/keys/server_no_passwd.key"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.WithError(err).Error(<span class="string">"load server tls fail"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    rpcServer := grpc.NewServer(grpc.Creds(transportCredentials))</span><br><span class="line">    services.RegisterProdServiceServer(rpcServer, <span class="built_in">new</span>(services.ProdService))</span><br><span class="line">    listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8081"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.Error(<span class="string">"listen fail"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    logrus.Info(<span class="string">"listen"</span>)</span><br><span class="line">    <span class="keyword">if</span> err = rpcServer.Serve(listen); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logrus.Error(<span class="string">"grpc serve fail"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    logrus.Info(<span class="string">"serve"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果用当前的客户端代码, 启动时会报错:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRO[<span class="number">0000</span>] rpc fail                                      error=<span class="string">"rpc error: code = Unavailable desc = connection closed"</span></span><br></pre></td></tr></table></figure><h4 id="2-5-2-客户端代码"><a href="#2-5-2-客户端代码" class="headerlink" title="2.5.2 客户端代码"></a>2.5.2 客户端代码</h4><h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3. 语法"></a>3. 语法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;GRPC 是一个语言中立, 平台中立的 RPC 框架, 支持 Java, C++, Golang, php 等多个语言版
      
    
    </summary>
    
      <category term="实战" scheme="https://destinywang.github.io/blog/categories/%E5%AE%9E%E6%88%98/"/>
    
      <category term="RPC" scheme="https://destinywang.github.io/blog/categories/%E5%AE%9E%E6%88%98/RPC/"/>
    
    
      <category term="GRPC" scheme="https://destinywang.github.io/blog/tags/GRPC/"/>
    
  </entry>
  
  <entry>
    <title>Go-kit解析</title>
    <link href="https://destinywang.github.io/blog/2020/08/01/Go-kit%E8%A7%A3%E6%9E%90/"/>
    <id>https://destinywang.github.io/blog/2020/08/01/Go-kit解析/</id>
    <published>2020-08-01T07:05:21.000Z</published>
    <updated>2020-12-01T07:23:27.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Gokit-入门"><a href="#1-Gokit-入门" class="headerlink" title="1. Gokit 入门"></a>1. Gokit 入门</h1><p>Gokit 的三层架构:</p><ol><li>Transport: 主要负责与 Http, GRPC, Thrift 等相关的逻辑</li><li>Endpoint: 定义 Request, Response 格式, 并可以使用装饰器包装函数, 以此来实现各种中间件嵌套</li><li>Server: 业务类</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── endpoint</span><br><span class="line">│   └── user_endpoint.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── services</span><br><span class="line">│   └── user_service.go</span><br><span class="line">└── transport</span><br><span class="line">    └── user_transport.go</span><br></pre></td></tr></table></figure><h1 id="2-注册中心"><a href="#2-注册中心" class="headerlink" title="2. 注册中心"></a>2. 注册中心</h1><p>docker 启动:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载官方镜像</span></span><br><span class="line">$ docker pull consul</span><br><span class="line"><span class="comment"># 启动:</span></span><br><span class="line"><span class="comment"># -server 代表以服务端方式启动</span></span><br><span class="line"><span class="comment"># -bootstrap 指定自己为 leader, 不需要选举</span></span><br><span class="line"><span class="comment"># -ui 启动一个内置的管理界面</span></span><br><span class="line"><span class="comment"># -client 指定客户端可以访问的 IP, 0.0.0.0 代表任意访问</span></span><br><span class="line">$ docker run -d --name=cs -p 8500:8500 consul agent -server -bootstrap -ui -client 0.0.0.0</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ~/p.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"ID"</span>: <span class="string">"userservice"</span>,</span><br><span class="line"><span class="attr">"Name"</span>: <span class="string">"userservice"</span>,</span><br><span class="line"><span class="attr">"Tags"</span>: [</span><br><span class="line"><span class="string">"primary"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"Address"</span>: <span class="string">"192.168.0.108"</span>,</span><br><span class="line"><span class="attr">"Port"</span>: <span class="number">8000</span>,</span><br><span class="line"><span class="attr">"Check"</span>: &#123;</span><br><span class="line"><span class="attr">"HTTP"</span>: <span class="string">"http://192.168.0.108:8000/health"</span>,</span><br><span class="line"><span class="attr">"Interval"</span>: <span class="string">"5s"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册</span></span><br><span class="line">$ curl --request PUT --data @p.json localhost:8500/v1/agent/service/register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注销</span></span><br><span class="line">$ curl --reqeust PUT http://localhost:8500/v1/agent/service/deregister/userservice</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/89105324-b6f2e580-d452-11ea-8d02-8240ac66b946.png" alt="image"></p><h1 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3. 实现细节"></a>3. 实现细节</h1><h2 id="3-1-注册中心集成"><a href="#3-1-注册中心集成" class="headerlink" title="3.1 注册中心集成"></a>3.1 注册中心集成</h2><h2 id="3-2-负载均衡"><a href="#3-2-负载均衡" class="headerlink" title="3.2 负载均衡"></a>3.2 负载均衡</h2><h2 id="3-3-限流"><a href="#3-3-限流" class="headerlink" title="3.3 限流"></a>3.3 限流</h2><h3 id="3-3-1-rate-包使用"><a href="#3-3-1-rate-包使用" class="headerlink" title="3.3.1 rate 包使用"></a>3.3.1 rate 包使用</h3><p>Go 提供了一个内置限流包 <code>golang.org/x/time.rate</code>, 可以非常方便的实现限流功能, 常见的限流方案有漏桶和令牌通两种</p><ul><li>Wait/WaitN: 一次取出 N 个令牌, 如果没有足够令牌, 协程被阻塞</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = rate.NewLimiter(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 每秒添加 1 个 token, 初始值为 5</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.WaitN(context.Background(), <span class="number">2</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><pre><code>INFO[0000] 2020-08-02 18:38:06INFO[0001] 2020-08-02 18:38:07INFO[0002] 2020-08-02 18:38:08INFO[0003] 2020-08-02 18:38:09INFO[0004] 2020-08-02 18:38:11INFO[0005] 2020-08-02 18:38:13INFO[0006] 2020-08-02 18:38:15INFO[0007] 2020-08-02 18:38:17</code></pre><ul><li>Allow/AllowN: 一次消耗 N 个 token, 如果不足返回 false</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = rate.NewLimiter(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 每秒添加 1 个 token, 初始值为 5</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.AllowN(time.Now(), <span class="number">2</span>) &#123;</span><br><span class="line">logrus.Info(time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logrus.Error(<span class="string">"too many request"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><pre><code>INFO[0000] 2020-08-02 18:42:11                          INFO[0001] 2020-08-02 18:42:12                          INFO[0002] 2020-08-02 18:42:13                          INFO[0003] 2020-08-02 18:42:14                          ERRO[0004] too many request                             INFO[0005] 2020-08-02 18:42:16                          ERRO[0006] too many request                             INFO[0007] 2020-08-02 18:42:18                          ERRO[0008] too many request                             INFO[0009] 2020-08-02 18:42:20                          ERRO[0010] too many request</code></pre><h1 id="4-熔断"><a href="#4-熔断" class="headerlink" title="4. 熔断"></a>4. 熔断</h1><p>隔离 RPC 请求, 防止级联调用故障</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Gokit-入门&quot;&gt;&lt;a href=&quot;#1-Gokit-入门&quot; class=&quot;headerlink&quot; title=&quot;1. Gokit 入门&quot;&gt;&lt;/a&gt;1. Gokit 入门&lt;/h1&gt;&lt;p&gt;Gokit 的三层架构:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Transport:
      
    
    </summary>
    
      <category term="分布式" scheme="https://destinywang.github.io/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="微服务" scheme="https://destinywang.github.io/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Go" scheme="https://destinywang.github.io/blog/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从源码实现解读Raft协议</title>
    <link href="https://destinywang.github.io/blog/2020/05/17/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%AF%BBRaft%E5%8D%8F%E8%AE%AE/"/>
    <id>https://destinywang.github.io/blog/2020/05/17/从源码实现解读Raft协议/</id>
    <published>2020-05-17T08:17:34.000Z</published>
    <updated>2020-12-20T03:36:57.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Raft-简介"><a href="#1-Raft-简介" class="headerlink" title="1. Raft 简介"></a>1. Raft 简介</h1><h1 id="2-Raft-的基本原理"><a href="#2-Raft-的基本原理" class="headerlink" title="2. Raft 的基本原理"></a>2. Raft 的基本原理</h1><h1 id="3-源码介绍"><a href="#3-源码介绍" class="headerlink" title="3. 源码介绍"></a>3. 源码介绍</h1><p><a href="https://github.com/hashicorp/raft" target="_blank" rel="noopener">HashicorpRaft</a> 是目前比较流行, 使用 go 语言实现的 Raft 算法, 代码相对简洁, 能够比较清晰的理解 Raft 运行时的基本原理. 下面通过两个最主要的场景对代码实现进行分析</p><h2 id="3-1-Leader-选举流程"><a href="#3-1-Leader-选举流程" class="headerlink" title="3.1 Leader 选举流程"></a>3.1 Leader 选举流程</h2><h3 id="3-1-1-节点状态切换"><a href="#3-1-1-节点状态切换" class="headerlink" title="3.1.1 节点状态切换"></a>3.1.1 节点状态切换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RaftState captures the state of a Raft node: Follower, Candidate, Leader, or Shutdown.</span></span><br><span class="line"><span class="keyword">type</span> RaftState <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// Follower is the initial state of a Raft node.</span></span><br><span class="line">    Follower RaftState = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Candidate is one of the valid states of a Raft node.</span></span><br><span class="line">    Candidate</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Leader is one of the valid states of a Raft node.</span></span><br><span class="line">    Leader</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shutdown is the terminal state of a Raft node.</span></span><br><span class="line">    Shutdown</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Leader 选举的本质是节点状态的变更, HashicorpRaft 中 Leader 选举的入口函数是 <code>run</code>, 在 <code>raft.go</code> 中以一个单独的协程来运行, 实现运行时节点状态的变更:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run is a long running goroutine that runs the Raft FSM.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 收到 shutdown 命令时关闭节点</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">            r.setLeader(<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enter into a sub-FSM</span></span><br><span class="line">        <span class="keyword">switch</span> r.getState() &#123;</span><br><span class="line">        <span class="keyword">case</span> Follower:</span><br><span class="line">            <span class="comment">// 跟随者</span></span><br><span class="line">            r.runFollower()</span><br><span class="line">        <span class="keyword">case</span> Candidate:</span><br><span class="line">            <span class="comment">// 候选人</span></span><br><span class="line">            r.runCandidate()</span><br><span class="line">        <span class="keyword">case</span> Leader:</span><br><span class="line">            <span class="comment">// 领导者</span></span><br><span class="line">            r.runLeader()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将节点在运行期间跟随者, 候选人, 领导者三种身份所做的工作抽象成三个函数, 比如节点刚加入集群时默认是 Follower, 会执行 <code>(r *Raft) runFollower()</code> 中的逻辑, 当发生 Leader 心跳超时时, 自身状态会变成候选人, 因此会执行 <code>(r *Raft) runCandidate()</code> 中的逻辑</p><h3 id="3-1-2-节点信息维护"><a href="#3-1-2-节点信息维护" class="headerlink" title="3.1.2 节点信息维护"></a>3.1.2 节点信息维护</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// raftState is used to maintain various state variables</span></span><br><span class="line"><span class="comment">// and provides an interface to set/get the variables in a</span></span><br><span class="line"><span class="comment">// thread safe manner.</span></span><br><span class="line"><span class="keyword">type</span> raftState <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// currentTerm commitIndex, lastApplied,  must be kept at the top of</span></span><br><span class="line">    <span class="comment">// the struct so they're 64 bit aligned which is a requirement for</span></span><br><span class="line">    <span class="comment">// atomic ops on 32 bit platforms.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The current term, cache of StableStore</span></span><br><span class="line">    <span class="comment">// 当前任期编号</span></span><br><span class="line">    currentTerm <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Highest committed log entry</span></span><br><span class="line">    <span class="comment">// 最大被提交的日志项的索引值</span></span><br><span class="line">    commitIndex <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last applied log to the FSM</span></span><br><span class="line">    <span class="comment">// 最新被应用到状态机的日志项索引值</span></span><br><span class="line">    lastApplied <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// protects 4 next fields</span></span><br><span class="line">    lastLock sync.Mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the latest snapshot index/term</span></span><br><span class="line">    <span class="comment">// 存储中最新的日志项的索引值和任期编号</span></span><br><span class="line">    lastSnapshotIndex <span class="keyword">uint64</span></span><br><span class="line">    lastSnapshotTerm  <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the latest log from LogStore</span></span><br><span class="line">    lastLogIndex <span class="keyword">uint64</span></span><br><span class="line">    lastLogTerm  <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracks running goroutines</span></span><br><span class="line">    routinesGroup sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The current state</span></span><br><span class="line">    <span class="comment">// 当前节点状态</span></span><br><span class="line">    state RaftState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体中包含了当前节点的元信息</p><h3 id="3-1-3-加入集群"><a href="#3-1-3-加入集群" class="headerlink" title="3.1.3 加入集群"></a>3.1.3 加入集群</h3><p>在初始状态下, 集群中所有节点都处于 Follower 状态, 函数 <code>(r *Raft) runFollower()</code> 运行</p><blockquote><p>省去非必要细节<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">runFollower</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    heartbeatTimer := randomTimeout(r.conf.HeartbeatTimeout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r.getState() == Follower &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> rpc := &lt;-r.rpcCh:</span><br><span class="line">            r.processRPC(rpc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> c := &lt;-r.configurationChangeCh:</span><br><span class="line">            <span class="comment">// Reject any operations since we are not the leader</span></span><br><span class="line">            c.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> a := &lt;-r.applyCh:</span><br><span class="line">            <span class="comment">// Reject any operations since we are not the leader</span></span><br><span class="line">            a.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> v := &lt;-r.verifyCh:</span><br><span class="line">            <span class="comment">// Reject any operations since we are not the leader</span></span><br><span class="line">            v.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> r := &lt;-r.userRestoreCh:</span><br><span class="line">            <span class="comment">// Reject any restores since we are not the leader</span></span><br><span class="line">            r.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> r := &lt;-r.leadershipTransferCh:</span><br><span class="line">            <span class="comment">// Reject any operations since we are not the leader</span></span><br><span class="line">            r.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> c := &lt;-r.configurationsCh:</span><br><span class="line">            c.configurations = r.configurations.Clone()</span><br><span class="line">            c.respond(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> b := &lt;-r.bootstrapCh:</span><br><span class="line">            b.respond(r.liveBootstrap(b.configuration))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-heartbeatTimer:</span><br><span class="line">            <span class="comment">// Restart the heartbeat timer</span></span><br><span class="line">            heartbeatTimer = randomTimeout(r.conf.HeartbeatTimeout)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if we have had a successful contact</span></span><br><span class="line">            lastContact := r.LastContact()</span><br><span class="line">            <span class="keyword">if</span> time.Now().Sub(lastContact) &lt; r.conf.HeartbeatTimeout &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Heartbeat failed! Transition to the candidate state</span></span><br><span class="line">            lastLeader := r.Leader()</span><br><span class="line">            r.setLeader(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r.configurations.latestIndex == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> !didWarn &#123;</span><br><span class="line">                    r.logger.Warn(<span class="string">"no known peers, aborting election"</span>)</span><br><span class="line">                    didWarn = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> r.configurations.latestIndex == r.configurations.committedIndex &amp;&amp;</span><br><span class="line">                !hasVote(r.configurations.latest, r.localID) &#123;</span><br><span class="line">                <span class="keyword">if</span> !didWarn &#123;</span><br><span class="line">                    didWarn = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.setState(Candidate)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/82140553-010bf800-9862-11ea-96b9-29920556d2c0.png" alt="image"></p><ul><li>根据配置的心跳超时时长, 调用 <code>randomTimeout()</code> 函数来获取一个随机值, 用以设置心跳超时间隔</li><li>进入 for 循环中, 通过 select 实现多路 IO 复用<ul><li>如果期间收到了 RPC 请求就完成处理</li><li>如果到达超时周期:<ul><li>再次生成一个随机超时时间</li><li>如果在等待周期内收到了 Leader 的心跳消息, 执行 continue, 开始新的 for 循环</li><li>如果超过之前随机的超时间隔没有收到 Leader 的心跳消息, 就会将自己的状态设置为候选人, 退出并执行 <code>(r *Raft) runCandidate()</code></li></ul></li><li>如果收到 shutdown 命令, 退出</li></ul></li></ul><h3 id="3-1-4-候选人发起选举"><a href="#3-1-4-候选人发起选举" class="headerlink" title="3.1.4 候选人发起选举"></a>3.1.4 候选人发起选举</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">runCandidate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Start vote for us, and set a timeout</span></span><br><span class="line">    voteCh := r.electSelf()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the leadership transfer flag is reset after each run. Having this</span></span><br><span class="line">    <span class="comment">// flag will set the field LeadershipTransfer in a RequestVoteRequst to true,</span></span><br><span class="line">    <span class="comment">// which will make other servers vote even though they have a leader already.</span></span><br><span class="line">    <span class="comment">// It is important to reset that flag, because this priviledge could be abused</span></span><br><span class="line">    <span class="comment">// otherwise.</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; r.candidateFromLeadershipTransfer = <span class="literal">false</span> &#125;()</span><br><span class="line"></span><br><span class="line">    electionTimer := randomTimeout(r.conf.ElectionTimeout)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tally the votes, need a simple majority</span></span><br><span class="line">    grantedVotes := <span class="number">0</span></span><br><span class="line">    votesNeeded := r.quorumSize()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r.getState() == Candidate &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> rpc := &lt;-r.rpcCh:</span><br><span class="line">            r.processRPC(rpc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> vote := &lt;-voteCh:</span><br><span class="line">            <span class="comment">// Check if the term is greater than ours, bail</span></span><br><span class="line">            <span class="keyword">if</span> vote.Term &gt; r.getCurrentTerm() &#123;</span><br><span class="line">                r.setState(Follower)</span><br><span class="line">                r.setCurrentTerm(vote.Term)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if the vote is granted</span></span><br><span class="line">            <span class="keyword">if</span> vote.Granted &#123;</span><br><span class="line">                grantedVotes++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if we've become the leader</span></span><br><span class="line">            <span class="keyword">if</span> grantedVotes &gt;= votesNeeded &#123;</span><br><span class="line">                r.setState(Leader)</span><br><span class="line">                r.setLeader(r.localAddr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> c := &lt;-r.configurationsCh:</span><br><span class="line">            c.configurations = r.configurations.Clone()</span><br><span class="line">            c.respond(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> b := &lt;-r.bootstrapCh:</span><br><span class="line">            b.respond(ErrCantBootstrap)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-electionTimer:</span><br><span class="line">            <span class="comment">// Election failed! Restart the election. We simply return,</span></span><br><span class="line">            <span class="comment">// which will kick us back into runCandidate</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 <code>func (r *Raft) electSelf() &lt;-chan *voteResult</code> 发起投票, 给自己投一张选票, 并向其他节点发送请求投票的 RPC 消息, 请求他们选举自己为 Leader, 然后调用 randomTimeout() 函数, 获取一个随机值, 设置选举超时时间</li><li>进入 for 循环, 通过 select 实现多路复用<ul><li>如果期间收到了 RPC 请求就完成处理</li><li>如果在选举超时前赢得到大多数选票, 那么候选人将当选为领导者, 调用 <code>setState()</code> 函数将自己状态变更为 Leader, 并退出 <code>runCandidate()</code> 函数</li><li>如果选举超时, 退出当前 <code>runCandidate()</code> 函数, 回到调用点重新发起新一轮选举</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/17758731/82223832-c7b4b480-9955-11ea-8fd3-dea63b579d3a.png" alt="image"></p><h3 id="3-1-5-领导人"><a href="#3-1-5-领导人" class="headerlink" title="3.1.5 领导人"></a>3.1.5 领导人</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span> <span class="title">runLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Notify that we are the leader</span></span><br><span class="line">    overrideNotifyBool(r.leaderCh, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push to the notify channel if given</span></span><br><span class="line">    <span class="keyword">if</span> notify := r.conf.NotifyCh; notify != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> notify &lt;- <span class="literal">true</span>:</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup leader state. This is only supposed to be accessed within the leaderloop.</span></span><br><span class="line">    r.setupLeaderState()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup state on step down</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Since we were the leader previously, we update our</span></span><br><span class="line">        <span class="comment">// last contact time when we step down, so that we are not</span></span><br><span class="line">        <span class="comment">// reporting a last contact time from before we were the</span></span><br><span class="line">        <span class="comment">// leader. Otherwise, to a client it would seem our data</span></span><br><span class="line">        <span class="comment">// is extremely stale.</span></span><br><span class="line">        r.setLastContact()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stop replication</span></span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> r.leaderState.replState &#123;</span><br><span class="line">            <span class="built_in">close</span>(p.stopCh)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Respond to all inflight operations</span></span><br><span class="line">        <span class="keyword">for</span> e := r.leaderState.inflight.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">            e.Value.(*logFuture).respond(ErrLeadershipLost)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Respond to any pending verify requests</span></span><br><span class="line">        <span class="keyword">for</span> future := <span class="keyword">range</span> r.leaderState.notify &#123;</span><br><span class="line">            future.respond(ErrLeadershipLost)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear all the state</span></span><br><span class="line">        r.leaderState.commitCh = <span class="literal">nil</span></span><br><span class="line">        r.leaderState.commitment = <span class="literal">nil</span></span><br><span class="line">        r.leaderState.inflight = <span class="literal">nil</span></span><br><span class="line">        r.leaderState.replState = <span class="literal">nil</span></span><br><span class="line">        r.leaderState.notify = <span class="literal">nil</span></span><br><span class="line">        r.leaderState.stepDown = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are stepping down for some reason, no known leader.</span></span><br><span class="line">        <span class="comment">// We may have stepped down due to an RPC call, which would</span></span><br><span class="line">        <span class="comment">// provide the leader, so we cannot always blank this out.</span></span><br><span class="line">        r.leaderLock.Lock()</span><br><span class="line">        <span class="keyword">if</span> r.leader == r.localAddr &#123;</span><br><span class="line">            r.leader = <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        r.leaderLock.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify that we are not the leader</span></span><br><span class="line">        overrideNotifyBool(r.leaderCh, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push to the notify channel if given</span></span><br><span class="line">        <span class="keyword">if</span> notify := r.conf.NotifyCh; notify != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> notify &lt;- <span class="literal">false</span>:</span><br><span class="line">            <span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">            <span class="comment">// On shutdown, make a best effort but do not block</span></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> notify &lt;- <span class="literal">false</span>:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a replication routine for each peer</span></span><br><span class="line">    r.startStopReplication()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch a no-op log entry first. This gets this leader up to the latest</span></span><br><span class="line">    <span class="comment">// possible commit index, even in the absence of client commands. This used</span></span><br><span class="line">    <span class="comment">// to append a configuration entry instead of a noop. However, that permits</span></span><br><span class="line">    <span class="comment">// an unbounded number of uncommitted configurations in the log. We now</span></span><br><span class="line">    <span class="comment">// maintain that there exists at most one uncommitted configuration entry in</span></span><br><span class="line">    <span class="comment">// any log, so we have to do proper no-ops here.</span></span><br><span class="line">    noop := &amp;logFuture&#123;</span><br><span class="line">        log: Log&#123;</span><br><span class="line">            Type: LogNoop,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    r.dispatchLogs([]*logFuture&#123;noop&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sit in the leader loop until we step down</span></span><br><span class="line">    r.leaderLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 <code>func (r *Raft) startStopReplication()</code>, 执行日志复制功能<ul><li>启动新协程, 调用 <code>func (r *Raft) replicate(s *followerReplication)</code>, 执行日志复制功能<ul><li>再启动一个新协程, 调用 <code>func (r *Raft) heartbeat(s *followerReplication, stopCh chan struct{})</code> 函数, 执行心跳功能</li><li>周期性的发送心跳信息, 通知其他节点不需要发起新的选举</li></ul></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/17758731/82221844-17de4780-9953-11ea-9ca6-662641f868f2.png" alt="image"></p><h2 id="3-2-复制日志流程"><a href="#3-2-复制日志流程" class="headerlink" title="3.2 复制日志流程"></a>3.2 复制日志流程</h2><p>Raft 是基于强领导者模型的日志复制, 最终实现强一致.</p><p>日志的复制是由 Leader 发起, Follower 接收, 因此两部分代码的入口分别在 <code>runLeader()</code> 和 <code>runFollower</code> 中.</p><h3 id="3-2-1-日志结构"><a href="#3-2-1-日志结构" class="headerlink" title="3.2.1 日志结构"></a>3.2.1 日志结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Index holds the index of the log entry.</span></span><br><span class="line">    <span class="comment">// 索引值</span></span><br><span class="line">    Index <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Term holds the election term of the log entry.</span></span><br><span class="line">    <span class="comment">// 任期编号</span></span><br><span class="line">    Term <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type holds the type of the log entry.</span></span><br><span class="line">    <span class="comment">// 日志项类别, LogCommand 指令对应日志项, LogConfiguration 表示成员变更对应的日志项</span></span><br><span class="line">    Type LogType</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Data holds the log entry's type-specific data.</span></span><br><span class="line">    <span class="comment">// 指令</span></span><br><span class="line">    Data []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展信息</span></span><br><span class="line">    Extensions []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-Leader-复制日志"><a href="#3-2-2-Leader-复制日志" class="headerlink" title="3.2.2 Leader 复制日志"></a>3.2.2 Leader 复制日志</h3><ul><li>在 <code>runLeader()</code> 函数中, 调用 <code>func (r *Raft) startStopReplication()</code>, 执行复制功能</li><li>启动一个新的协程调用 <code>func (r *Raft) replicate(s *followerReplication)</code>, 执行日志复制相关的功能<ul><li>调用 <code>func (r *Raft) replicateTo(s *followerReplication, lastIndex uint64) (shouldStop bool)</code><ul><li>进行日志复制和一致性检测, 如果复制成功, 则开启流水线复制模式(在不需要进行日志检测, 复制功能已经正常运行的时候开启流水线复制模式)</li><li>如果开启了流水线模式, 执行 <code>func (r *Raft) pipelineReplicate(s *followerReplication) error</code></li></ul></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/17758731/82228798-3268ee80-995c-11ea-8b2b-3e434f029d29.png" alt="image"></p><h3 id="3-2-3-Follower-接收日志"><a href="#3-2-3-Follower-接收日志" class="headerlink" title="3.2.3 Follower 接收日志"></a>3.2.3 Follower 接收日志</h3><ul><li>在 <code>runFollower()</code> 中, 调用 <code>func (r *Raft) processRPC(rpc RPC)</code>, 处理接收到的 RPC 消息<ul><li>调用 <code>func (r *Raft) appendEntries(rpc RPC, a *AppendEntriesRequest)</code>, 处理接收到的日志复制 RPC 请求<ul><li>比较日志一致性</li><li>将新日志持久化到本地</li><li>根据领导者最新提交的日志项索引值, 来计算当前需要被应用的日志项, 并应用到本地状态机</li></ul></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/17758731/82230160-f040ac80-995d-11ea-8c34-f496c6c1e6c6.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Raft-简介&quot;&gt;&lt;a href=&quot;#1-Raft-简介&quot; class=&quot;headerlink&quot; title=&quot;1. Raft 简介&quot;&gt;&lt;/a&gt;1. Raft 简介&lt;/h1&gt;&lt;h1 id=&quot;2-Raft-的基本原理&quot;&gt;&lt;a href=&quot;#2-Raft-的基本原
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch 原理与实践</title>
    <link href="https://destinywang.github.io/blog/2020/04/06/ElasticSearch-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://destinywang.github.io/blog/2020/04/06/ElasticSearch-原理与实践/</id>
    <published>2020-04-06T05:54:11.000Z</published>
    <updated>2020-07-18T07:16:53.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-生态圈"><a href="#1-1-生态圈" class="headerlink" title="1.1 生态圈"></a>1.1 生态圈</h2><p>ElasticSearch 是一款开源的分布式搜索引擎和近实时大数据分析平台.</p><p><img src="https://user-images.githubusercontent.com/17758731/78526882-fba4a200-780d-11ea-8451-2c74d3c5103c.png" alt="image"></p><table><thead><tr><th>组件</th><th>功能</th></tr></thead><tbody><tr><td>Logstash</td><td>开源的服务端数据处理通道, 支持从不同数据源进行采集和转换, 并将数据发送到不同的存储中.</td></tr><tr><td>Kibana</td><td>数据可视化工具</td></tr><tr><td>Beats</td><td>轻量的数据采集器, ElasticSearch 提供了大量的 Beats 套件以针对不同的数据源, 如 Filebeat, Metricbeat, Functionbeat 等</td></tr><tr><td>X-Pack</td><td>ElasticSearch 提供的商业化套件</td></tr></tbody></table><p>应用场景:</p><ul><li>页面搜索, 垂直搜索, 代码搜索</li><li>日志管理与分析, 安全指标监控, 应用性能监控, Web 住区舆情分析.</li></ul><h2 id="1-2-搜索场景下与数据库集成"><a href="#1-2-搜索场景下与数据库集成" class="headerlink" title="1.2 搜索场景下与数据库集成"></a>1.2 搜索场景下与数据库集成</h2><p><img src="https://user-images.githubusercontent.com/17758731/78528025-fb59d600-7810-11ea-82fc-c69cf4a0e3e5.png" alt="image"></p><ul><li>搜索场景下 ElasticSearch 可以作为单独的存储, 优点是架构会变得比较简单</li><li>但如何数据更新比较频繁, 并且有事务场景的时候, 还是需要与 RDS 配合, 先将数据写入 RDS, 再通过同步机制(如 BinLog) 写入 ElasticSearch</li></ul><h2 id="1-3-指标分析与日志分析"><a href="#1-3-指标分析与日志分析" class="headerlink" title="1.3 指标分析与日志分析"></a>1.3 指标分析与日志分析</h2><p><img src="https://user-images.githubusercontent.com/17758731/78528881-06ae0100-7813-11ea-9557-248e135d04c3.png" alt="image"></p><ul><li>Beats 可以从不同的数据源完成数据采集</li><li>在实际场景中如果数据量比较大, 需要引入 MQ 来完成数据缓冲层</li><li>缓冲层将数据发送给 Logstash</li><li>Logstash 对数据完成转化和聚合后发送给 ElasticSearch</li><li>基于 ElasticSearch 可以搭建 Kibana 分析平台, 或选择 Grafana 图形化工具去分析时序性数据.</li></ul><h1 id="2-安装-ElasticSearch"><a href="#2-安装-ElasticSearch" class="headerlink" title="2. 安装 ElasticSearch"></a>2. 安装 ElasticSearch</h1><h2 id="2-1-ElasticSearch-的文件目录结构"><a href="#2-1-ElasticSearch-的文件目录结构" class="headerlink" title="2.1 ElasticSearch 的文件目录结构"></a>2.1 ElasticSearch 的文件目录结构</h2><p><img src="https://user-images.githubusercontent.com/17758731/78550976-92d21f80-7837-11ea-97ce-c9015434a704.png" alt="image"></p><table><thead><tr><th>目录</th><th>配置文件</th><th>描述</th></tr></thead><tbody><tr><td>bin</td><td></td><td>脚本文件, 包括启动 ElasticSearch, 安装插件, 运行统计数据等.</td></tr><tr><td>config</td><td>elasticsearch.yml</td><td>集群配置文件, user, role based 相关配置</td></tr><tr><td>JDK</td><td></td><td>Java 运行环境</td></tr><tr><td>data</td><td>path.data</td><td>数据文件</td></tr><tr><td>lib</td><td></td><td>Java 类库</td></tr><tr><td>logs</td><td>path.log</td><td>日志文件</td></tr><tr><td>modules</td><td></td><td>包含所有 ES 模块</td></tr><tr><td>plugins</td><td></td><td>包含所有已安装插件</td></tr></tbody></table><h2 id="2-2-JVM-配置"><a href="#2-2-JVM-配置" class="headerlink" title="2.2 JVM 配置"></a>2.2 JVM 配置</h2><ul><li>JVM 相关配置在 <code>config/jvm.options</code>, ElasticSearch 默认设置是 1GB</li><li>配置建议:<ul><li>Xms 和 Xmx 设置成一样</li><li>Xmx 不要超所机器内存的 50%</li><li>Xmx 不要超过 30GB</li></ul></li></ul><h2 id="2-3-启动-ElasticSearch"><a href="#2-3-启动-ElasticSearch" class="headerlink" title="2.3 启动 ElasticSearch"></a>2.3 启动 ElasticSearch</h2><p>执行 <code>bin/elasticsearch</code></p><p><img src="https://user-images.githubusercontent.com/17758731/78551826-f446be00-7838-11ea-8630-591b1ac55581.png" alt="image"></p><p>看到对应的启动日志后在浏览器打开 <code>localhost:9200</code>, 即可返回对应 JSON:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"destiny"</span>,</span><br><span class="line">    <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">    <span class="attr">"cluster_uuid"</span>: <span class="string">"qAoe9AV4SG-NBgIR2j3bpw"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: &#123;</span><br><span class="line">        <span class="attr">"number"</span>: <span class="string">"7.6.2"</span>,</span><br><span class="line">        <span class="attr">"build_flavor"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"build_type"</span>: <span class="string">"tar"</span>,</span><br><span class="line">        <span class="attr">"build_hash"</span>: <span class="string">"ef48eb35cf30adf4db14086e8aabd07ef6fb113f"</span>,</span><br><span class="line">        <span class="attr">"build_date"</span>: <span class="string">"2020-03-26T06:34:37.794943Z"</span>,</span><br><span class="line">        <span class="attr">"build_snapshot"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"lucene_version"</span>: <span class="string">"8.4.0"</span>,</span><br><span class="line">        <span class="attr">"minimum_wire_compatibility_version"</span>: <span class="string">"6.8.0"</span>,</span><br><span class="line">        <span class="attr">"minimum_index_compatibility_version"</span>: <span class="string">"6.0.0-beta1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tagline"</span>: <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-安装插件"><a href="#2-4-安装插件" class="headerlink" title="2.4 安装插件"></a>2.4 安装插件</h2><ul><li>查看 ElasticSearch 插件列表</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/elasticsearch-plugin list</span><br></pre></td></tr></table></figure><ul><li>安装插件: (国际化分词插件 analysis-icu)</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/elasticsearch-plugin install analysis-icu</span><br><span class="line">-&gt; Installing analysis-icu</span><br><span class="line">-&gt; Downloading analysis-icu from elastic</span><br><span class="line">[=================================================] 100%</span><br><span class="line">-&gt; Installed analysis-icu</span><br></pre></td></tr></table></figure><h2 id="2-5-本机运行多个-ElasticSearch-实例"><a href="#2-5-本机运行多个-ElasticSearch-实例" class="headerlink" title="2.5 本机运行多个 ElasticSearch 实例"></a>2.5 本机运行多个 ElasticSearch 实例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/elasticsearch -E node.name=name0 -E cluster.name=destiny -E path.data=node0_data -d</span><br><span class="line">$ ./bin/elasticsearch -E node.name=name1 -E cluster.name=destiny -E path.data=node1_data -d</span><br><span class="line">$ ./bin/elasticsearch -E node.name=name2 -E cluster.name=destiny -E path.data=node2_data -d</span><br><span class="line">$ ./bin/elasticsearch -E node.name=name3 -E cluster.name=destiny -E path.data=node3_data -d</span><br></pre></td></tr></table></figure><p>使用浏览器打开 <code>http://localhost:9200/_cat/nodes</code></p><pre><code>127.0.0.1 31 99 61 21.49   dilm * name0127.0.0.1 22 99 58 21.49   dilm - name2127.0.0.1 21 99 58 21.49   dilm - name1127.0.0.1 17 99 56 21.49   dilm - name3</code></pre><p>可以看到此时集群中有 4 个节点运行.</p><h2 id="2-6-安装-Kibana"><a href="#2-6-安装-Kibana" class="headerlink" title="2.6 安装 Kibana"></a>2.6 安装 Kibana</h2><ol><li>下载并解压缩 Kibaba</li><li>在编辑器打开 <code>config/kibana.yml</code>, 并将 <code>elasticsearch.url</code> 设置为本机的 ElasticSearch 实例</li><li>运行 <code>bin/kinana</code></li><li>在浏览器中打开 <code>http://localhost:5601</code></li></ol><p><img src="https://user-images.githubusercontent.com/17758731/78680973-bf149b80-791e-11ea-8887-4fec79518d9a.png" alt="image"></p><p>此时 Kibana 在开箱即用中准备好了三种版本样例数据, 分别是电商网站订单, 航空公司飞行记录以及交通网站日志三份样例数据. 在 Kibana 的 Dashboard 界面可以根据样例数据生成报表.</p><p>此外 Kibana 还提供了 <code>DevTools</code> 功能, 可以很方便的帮助用户在 Kibana 上执行 ElasticSearch 的 API:</p><p><img src="https://user-images.githubusercontent.com/17758731/78682078-2121d080-7920-11ea-9a3d-dffa50bc634d.png" alt="image"></p><p>dev tool 的一部分快捷键:</p><ul><li><code>cmd + /</code> (查看帮助文档)</li><li><code>cmd + option + I</code></li><li><code>cmd + option + O</code></li><li><code>cmd + option + shift + O</code></li></ul><h2 id="2-7-在-docker-容器中运行-ElasticSearch"><a href="#2-7-在-docker-容器中运行-ElasticSearch" class="headerlink" title="2.7 在 docker 容器中运行 ElasticSearch"></a>2.7 在 docker 容器中运行 ElasticSearch</h2><p>docker-compose 相关命令:</p><ul><li>docker-compose up</li><li>docker compose down</li><li>docker compose down -v</li><li>docker stop / rm ${comtaionerID}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2.2&apos;</span><br><span class="line">services:</span><br><span class="line">  cerebro:</span><br><span class="line">    image: lmenezes/cerebro:0.8.3</span><br><span class="line">    container_name: cerebro</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9000:9000&quot;</span><br><span class="line">    command:</span><br><span class="line">      - -Dhosts.0.host=http://elasticsearch:9200</span><br><span class="line">    networks:</span><br><span class="line">      - es7net</span><br><span class="line">  kibana:</span><br><span class="line">    image: docker.elastic.co/kibana/kibana:7.1.0</span><br><span class="line">    container_name: kibana7</span><br><span class="line">    environment:</span><br><span class="line">      - I18N_LOCALE=zh-CN</span><br><span class="line">      - XPACK_GRAPH_ENABLED=true</span><br><span class="line">      - TIMELION_ENABLED=true</span><br><span class="line">      - XPACK_MONITORING_COLLECTION_ENABLED=&quot;true&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5601:5601&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - es7net</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0</span><br><span class="line">    container_name: es7_01</span><br><span class="line">    environment:</span><br><span class="line">      - cluster.name=destiny</span><br><span class="line">      - node.name=es7_01</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">      - discovery.seed_hosts=es7_01,es7_02</span><br><span class="line">      - cluster.initial_master_nodes=es7_01,es7_02</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - es7data1:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">    networks:</span><br><span class="line">      - es7net</span><br><span class="line">  elasticsearch2:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0</span><br><span class="line">    container_name: es7_02</span><br><span class="line">    environment:</span><br><span class="line">      - cluster.name=destiny</span><br><span class="line">      - node.name=es7_02</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">      - discovery.seed_hosts=es7_01,es7_02</span><br><span class="line">      - cluster.initial_master_nodes=es7_01,es7_02</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - es7data2:/usr/share/elasticsearch/data</span><br><span class="line">    networks:</span><br><span class="line">      - es7net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  es7data1:</span><br><span class="line">    driver: local</span><br><span class="line">  es7data2:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  es7net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/78691662-74e5e700-792b-11ea-8298-8c7e1616818c.png" alt="image"></p><p>通过 cerebro 可以比较直观的展现 ElasticSearch 集群的名称, 节点数量, 索引树, 分片数, 文档数量以及文件总大小, 以及每个节点的健康情况.</p><h2 id="2-8-Logstash-安装与导入数据"><a href="#2-8-Logstash-安装与导入数据" class="headerlink" title="2.8 Logstash 安装与导入数据"></a>2.8 Logstash 安装与导入数据</h2><p>Logstash 是一个灵活的数据传输和处理系统, 在beats出来之前, 还负责进行数据收集.Logstash的任务是将各种各样的数据, 经过配置转化规则, 统一化存入Elasticsearch. 使用Ruby 开发的 Logstash 在灵活性上非常出色, 不过性能一直是被诟病的问题.</p><p>由于 Logstash 在数据收集上并不出色, 而且作为 agent, 性能并不达标. elastic 发布了 <code>beats</code> 系列轻量级采集组件. 至此, elastic 形成了一个完整的生态链和技术栈, 成为大数据市场的佼佼者.</p><ol><li>下载并解压缩 <code>logstash</code></li><li>准备 <code>logstash.conf</code> 配置文件</li><li>执行 <code>bin/logstash -f logstash.conf</code></li></ol><p>下载需要导入的数据集(movies.csv):</p><p><a href="https://grouplens.org/datasets/movielens/" target="_blank" rel="noopener">MovieLens</a></p><p><img src="https://user-images.githubusercontent.com/17758731/78797005-b341db80-79e9-11ea-9d89-f976c796bf1b.png" alt="image"></p><blockquote><p>logstash.conf</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; &quot;/Users/destiny/dev/logstash-7.6.2/bin/movies.csv&quot; # movies 数据所在路径</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  csv &#123;</span><br><span class="line">    separator =&gt; &quot;,&quot;</span><br><span class="line">    columns =&gt; [&quot;id&quot;,&quot;content&quot;,&quot;genre&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123; &quot;genre&quot; =&gt; &quot;|&quot; &#125;</span><br><span class="line">    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line"></span><br><span class="line">    split =&gt; [&quot;content&quot;, &quot;(&quot;]</span><br><span class="line">    add_field =&gt; &#123; &quot;title&quot; =&gt; &quot;%&#123;[content][0]&#125;&quot;&#125;</span><br><span class="line">    add_field =&gt; &#123; &quot;year&quot; =&gt; &quot;%&#123;[content][1]&#125;&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    convert =&gt; &#123;</span><br><span class="line">      &quot;year&quot; =&gt; &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    strip =&gt; [&quot;title&quot;]</span><br><span class="line">    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;,&quot;content&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch &#123;</span><br><span class="line">     hosts =&gt; &quot;http://localhost:9200&quot; # 写入 9200 端口, 即 ElasticSearch</span><br><span class="line">     index =&gt; &quot;movies&quot;</span><br><span class="line">     document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logstash 的进程会一直阻塞去读取指定路径的文件, 因此看到最后一条记录被导入成功后就可以手动停止.</p><h1 id="3-ElasticSearch-基本概念"><a href="#3-ElasticSearch-基本概念" class="headerlink" title="3. ElasticSearch 基本概念"></a>3. ElasticSearch 基本概念</h1><h2 id="3-1-文档"><a href="#3-1-文档" class="headerlink" title="3.1 文档"></a>3.1 文档</h2><p>ElasticSearch 是面向文档的存储, 文档是所有可搜索数据的最小单位, 如日志文件中的日志项, 一部电影的详细信息等, 都可以被映射成 ElasticSearch 中的文档.</p><p>文档会被序列化成 json, 保存在 ElasticSearch 中, 每个 json 对象都由固定字段组成, 每个字段的值都有对应的类型.</p><p>每个文档都有一个 UniqueId, 可以由业务指定, 也可以通过 ElasticSearch 自动生成.</p><p>一篇文档包含了一系列的字段, 类似数据库表中的记录, 字段类型可以指定也可以通过 ElasticSearch 自动推算, 支持数组和嵌套结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movieId,title,genres</span><br><span class="line">1,Toy Story (1995),Adventure|Animation|Children|Comdy|Fantasy</span><br></pre></td></tr></table></figure><p>转换成文档存入 ElasticSearch 中的格式:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "_index": "movies",       // 文档所属的索引名</span><br><span class="line">    "_type": "_doc",          // 文档所属的类型名</span><br><span class="line">    "_id": "1",               // 文档唯一 id</span><br><span class="line">    "_score": 14.69302,       // 相关性打分</span><br><span class="line">    "_source": &#123;              // 原始文档的 json 数据</span><br><span class="line">        "year": 1995,</span><br><span class="line">        "@version": "1",      // 版本信息</span><br><span class="line">        "genre": [</span><br><span class="line">            "Adventure",</span><br><span class="line">            "Animation",</span><br><span class="line">            "Children",</span><br><span class="line">            "Comedy",</span><br><span class="line">            "Fantasy",</span><br><span class="line">        ],</span><br><span class="line">        "id": 1,</span><br><span class="line">        "title": "Toy Story"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-索引"><a href="#3-2-索引" class="headerlink" title="3.2 索引"></a>3.2 索引</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"movies"</span>: &#123;</span><br><span class="line">    <span class="attr">"setting"</span>: &#123;</span><br><span class="line">      <span class="attr">"index"</span>: &#123;</span><br><span class="line">        <span class="attr">"creation_date"</span>: <span class="string">"155273758543"</span>,</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"number_of_replicas"</span>: <span class="string">"0"</span>,</span><br><span class="line">        <span class="attr">"uuid"</span>: <span class="string">"Qnd7lmrNQPGdaeJ0oR0tfQ"</span>,</span><br><span class="line">        <span class="attr">"version"</span>: &#123;</span><br><span class="line">          <span class="attr">"created"</span>: <span class="string">"6060299"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"provided_name"</span>: <span class="string">"movies"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引是文档的容器, 是一类文档的集合, mapping 定义文档字段的类型, setting 定义不同的数据分布:</p><ul><li>index 体现了逻辑空间的概念, 每个索引都有自己的 mapping 定义, 用于定义包含的文档的字段名和字段类型</li><li>shard 体现了物理空间的概念, 索引中的数据分散在 shard 上</li></ul><p>与 RDS 的类比</p><table><thead><tr><th>ElasticSearch</th><th>RDS</th></tr></thead><tbody><tr><td>Index</td><td>Table</td></tr><tr><td>Document</td><td>Row</td></tr><tr><td>Field</td><td>Column</td></tr><tr><td>Mapping</td><td>Schema</td></tr><tr><td>DSL</td><td>SQL</td></tr></tbody></table><h2 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h2><p>不同的集群通过不同的名字来区分, 默认为 <code>elasticsearch</code>, 通过配置文件修改, 或者在命令行中通过 <code>-E cluster.name=${cluster_name}</code> 来设置, 一个集群可以包含多个节点.</p><h2 id="3-4-节点"><a href="#3-4-节点" class="headerlink" title="3.4 节点"></a>3.4 节点</h2><p>节点时一个 ElasticSearch 进程实例, 每个节点都有 name, 可以通过配置文件或命令行中的 <code>-E node.name=${node_name}</code> 指定, 每个节点启动后会分配一个 UID, 保存在 data 目录下.</p><h3 id="3-4-1-Master-eligible-节点和-Master-节点"><a href="#3-4-1-Master-eligible-节点和-Master-节点" class="headerlink" title="3.4.1 Master-eligible 节点和 Master 节点"></a>3.4.1 Master-eligible 节点和 Master 节点</h3><p>每个节点启动后, 默认就是一个 <code>Master-eligible</code> 节点, 可以通过配置 <code>node.master: false</code> 禁用. 每个 <code>Master-eligible</code> 节点都可以通过参与选主流程成为主节点, 当第一个 <code>Master-eligible</code> 节点启动时, 会将自己选举为主节点.</p><p>每个节点上都保存了集群的状态, 只有 Master 才能修改集群的状态信息, 集群状态信息包括:</p><ul><li>所有的节点信息</li><li>所有的索引和对应的 mapping 和 setting 信息</li><li>分片的路由信息</li></ul><h3 id="3-4-2-Data-节点和-Coordinating-Node"><a href="#3-4-2-Data-节点和-Coordinating-Node" class="headerlink" title="3.4.2 Data 节点和 Coordinating Node"></a>3.4.2 Data 节点和 Coordinating Node</h3><ul><li>DataNode: 保存数据的节点, 负责保存分片数据</li><li>CoordinationNode: 负责接收 client 请求, 将请求分发到对应节点, 最终把结果汇聚到一起, 每个节点默认都起到了 <code>Coordinating Node</code> 的职责</li></ul><h3 id="3-4-3-其他节点类型"><a href="#3-4-3-其他节点类型" class="headerlink" title="3.4.3 其他节点类型"></a>3.4.3 其他节点类型</h3><ul><li>Hot &amp; Warm Node: 不同硬件配置的 DataNode, 用来实现冷热分离架构, 降低部署陈本</li><li>MachineLearningNode: 负责跑机器学习 Job, 实现异常检测的节点</li><li>TribeNode: 连接到不同的 ElasticSearch 集群, 并支持将这些集群当成一个单独的集群</li></ul><h2 id="3-5-分片"><a href="#3-5-分片" class="headerlink" title="3.5 分片"></a>3.5 分片</h2><ul><li>主分片: 用于解决数据水平扩展问题, 通过主分片可以将数据分布到集群内的所有节点上, 每个分片都是一个 Lucene 的实例, 分片数在创建索引时指定, 后续不允许修改, 除非 Reindex</li><li>副本: 用以解决数据高可用的问题, 分片是主分片的拷贝, 分片树龄可以动态调整, 副本可以完成读写分离.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"number_of_reolicas"</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的请求, 会创建一个拥有 3 个分片, 1 个副本的 ElasticSearch 集群</p><p><img src="https://user-images.githubusercontent.com/17758731/79042721-87fafe80-7c2c-11ea-9814-d83afe9b90ca.png" alt="image"></p><p>对于生产环境中分片的设定需要提前做好容量规划:</p><ul><li>分片数设置过小会导致后续无法增加节点实现水平扩容, 并且单个分片数据量过大会导致 reindex 耗时较长</li><li>分片数过大会影响搜索结果的相关性打分, 影响统计结果的准确性, 单个节点上过多的分片会导致资源浪费, 同时也会影响性能.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/health</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"destiny"</span>,</span><br><span class="line">  <span class="attr">"status"</span> : <span class="string">"green"</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"number_of_nodes"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"number_of_data_nodes"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"active_primary_shards"</span> : <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"active_shards"</span> : <span class="number">12</span>,</span><br><span class="line">  <span class="attr">"relocating_shards"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"initializing_shards"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"unassigned_shards"</span> : <span class="number">0</span>, </span><br><span class="line">  <span class="attr">"delayed_unassigned_shards"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_pending_tasks"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_in_flight_fetch"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"active_shards_percent_as_number"</span> : <span class="number">100.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Green: 主分片与副本分片都正常分配</li><li>Yellow: 主分片全部正常分片, 有副本分片未能正常分配</li><li>Red: 有主分片未能分配, 如磁盘容量超 85% 的时候创建索引</li></ul><h2 id="3-6-文档的-CRUD"><a href="#3-6-文档的-CRUD" class="headerlink" title="3.6 文档的 CRUD"></a>3.6 文档的 CRUD</h2><table><thead><tr><th>操作</th><th>请求</th><th>功能</th></tr></thead><tbody><tr><td>index</td><td>PUT my_index/_doc/1<br>{“user”:”mike”,”comment”:”you know, for search”}</td><td>如果 ID 不存在, 创建新的文档, 否则先删除现有的文档, 再创建新的文档, 版本会增加</td></tr><tr><td>Create</td><td>PUT my_index/_create/1<br>{“user”:”mike”,”comment”:”you know, for search”}<br>POST my_index/_doc/1<br>{“user”:”mike”,”comment”:”you know, for search”}</td><td>如果 ID 已经存在, 会失败</td></tr><tr><td>Read</td><td>GET my_index/_doc/1</td></tr><tr><td>Update</td><td>POST my_index/_update/1<br>{“doc”:{“user”:”mike”,”comment”:”you know, for search”}}</td><td>文档必须已经存在, 更新只会将相应字段做增量修改</td></tr><tr><td>Delete</td><td>DELETE my_index/_doc/1</td></tr></tbody></table><h3 id="3-6-1-创建一个文档"><a href="#3-6-1-创建一个文档" class="headerlink" title="3.6.1 创建一个文档"></a>3.6.1 创建一个文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /users/_create/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"firstName"</span>: <span class="string">"Jack"</span>,</span><br><span class="line">    <span class="attr">"lastName"</span>: <span class="string">"Johnson"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [<span class="string">"guitar"</span>, <span class="string">"games"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>支持自动生成文档 id 和指定文档 id 两种方式</li><li>通过调用 <code>post/users/_doc</code> 自动生成 documentId</li><li>使用 HTTP PUT <code>user/_create/1</code> 创建时, URI 中显示指定 <code>_create</code>, 此时如果该 id 的文档已经存在会报错</li></ul><blockquote><p>使用 id 为 1 的请求第一次创建成功, 而第二次由于 id 重复报错.</p></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/79043928-ef1cb100-7c34-11ea-9f93-1e86ca6e8f82.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/17758731/79043942-05c30800-7c35-11ea-93e0-ec08ab0074e2.png" alt="image"></p><blockquote><p>使用 POST 方式自动分配 id</p></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/79043859-8a615680-7c34-11ea-8fb8-36779dded710.png" alt="image"></p><h3 id="3-6-2-读取一个文档"><a href="#3-6-2-读取一个文档" class="headerlink" title="3.6.2 读取一个文档"></a>3.6.2 读取一个文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"users"</span>,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">32</span>,</span><br><span class="line">    <span class="attr">"_seq_no"</span>: <span class="number">36</span>,</span><br><span class="line">    <span class="attr">"primary_term"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"firstName"</span>: <span class="string">"Jack"</span>,</span><br><span class="line">        <span class="attr">"lastName"</span>: <span class="string">"Johnson"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">39</span>,</span><br><span class="line">        <span class="attr">"tags"</span>: [</span><br><span class="line">            <span class="string">"guitar"</span>,</span><br><span class="line">            <span class="string">"games"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>找到文档返回 HTTP 200, 否则返回 404</li><li>格式 <code>Get _index/_type/docId</code></li><li>版本信息: 同一个 id 的文档即使被删除, version 也会不断增加</li><li>_source 中国默认包含了文档的所有原始信息</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/79044003-50dd1b00-7c35-11ea-9287-8e4ea7698410.png" alt="image"></p><h3 id="3-6-3-Index-文档"><a href="#3-6-3-Index-文档" class="headerlink" title="3.6.3 Index 文档"></a>3.6.3 Index 文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tags"</span>: [</span><br><span class="line">        <span class="string">"guitar"</span>,</span><br><span class="line">        <span class="string">"games"</span>,</span><br><span class="line">        <span class="string">"Gunpla"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Index 和 Create 的不同之处在于如果文档不存在就索引新的文档, 否则现有的文档会被删除, 新的文档被索引, 版本信息 +1, 上面例子中此时再查出来的记录中只会存在 <code>tags</code></li></ul><blockquote><p>此时 version 增加, 再次 get 是发现文档内容已被覆盖<br><img src="https://user-images.githubusercontent.com/17758731/79044089-c648eb80-7c35-11ea-8b2a-40281f8e0343.png" alt="image"></p></blockquote><h3 id="3-6-4-Update-文档"><a href="#3-6-4-Update-文档" class="headerlink" title="3.6.4 Update 文档"></a>3.6.4 Update 文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /users/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"albums"</span>: [</span><br><span class="line">      <span class="string">"album1"</span>,</span><br><span class="line">      <span class="string">"album2"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Update 不会删除原有的文档, 而是实现真正的数据更新</li><li>Post 方法/Payload 需要包含在 <code>doc</code> 中</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/79044193-6bfc5a80-7c36-11ea-88ef-d4b31e80c93b.png" alt="image"></p><h3 id="3-6-5-Bulk"><a href="#3-6-5-Bulk" class="headerlink" title="3.6.5 Bulk"></a>3.6.5 Bulk</h3><ul><li>支持在一次调用中对不同的索引进行操作</li><li>支持四种类型操作:<ul><li>Index</li><li>Create</li><li>Update</li><li>Delete</li></ul></li><li>可以在 URI 中指定 index, 也可以在 payload 中指定</li><li>单条操作失败不影响其他操作</li><li>返回结果包括了每一条操作执行的结果</li><li>bulk api 对 json 的语法, 有严格的要求, 每个json串不能换行, 只能放一行, 同时一个 json 串和一个 json 串之间, 必须有一个换行</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/79044620-b8e13080-7c38-11ea-8a2d-414907758dd1.png" alt="image"></p><h3 id="3-6-6-MGet"><a href="#3-6-6-MGet" class="headerlink" title="3.6.6 MGet"></a>3.6.6 MGet</h3><p>批量操作, 可以减少网络连接所产生的开销, 提高性能, 当其中一条执行失败时同样不会影响其他文档的查询</p><p><img src="https://user-images.githubusercontent.com/17758731/79044689-0d84ab80-7c39-11ea-971c-cf1d952339d0.png" alt="image"></p><h3 id="3-6-7-MSearch"><a href="#3-6-7-MSearch" class="headerlink" title="3.6.7 MSearch"></a>3.6.7 MSearch</h3><p><img src="https://user-images.githubusercontent.com/17758731/79044801-da8ee780-7c39-11ea-863c-f3c8b7f93dc7.png" alt="image"></p><h2 id="3-7-倒排索引"><a href="#3-7-倒排索引" class="headerlink" title="3.7 倒排索引"></a>3.7 倒排索引</h2><ul><li>正排索引: 类似于书的目录, 标示每一章的页码. 对搜索引擎来说就是文档 id 到文档内容的关联.</li><li>倒排索引: 类似于书中关键词的索引, 标示每个关键词分别在哪些页码出现过. 对搜索引擎来说就是文档内容到文档 id 的关联.</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/79071046-01b5e980-7d0c-11ea-835a-047be403a9f7.png" alt="image"></p><p>在倒排索引中记录每个词在文档中出现的次数和位置.</p><p>倒排索引的核心组成:</p><ul><li>单词词典(Term Dictionary): 记录所有文档的单词, 记录单词到倒排列表的关联关系, 单词词典一般比较大, 可以通过 B+树或者哈希表实现, 以满足高性能插入语查询</li><li>倒排列表(Posting List): 记录了单词对应的文档集合, 由倒排索引项组成:<ul><li>文档 Id;</li><li>词频 TF: 该单词在文档中出现的次数, 用于相关性评分;</li><li>位置(Position): 单词在文档中分词的位置, 用于语句搜索;</li><li>偏移(Offset): 记录单词的开始结束位置, 用于高亮显示.</li></ul></li></ul><h2 id="3-8-Analysis-与分词"><a href="#3-8-Analysis-与分词" class="headerlink" title="3.8 Analysis 与分词"></a>3.8 Analysis 与分词</h2><ul><li>Analysis: 是把全文本转换成一系列单词的过程, 也成分词</li><li>Analysis 是通过 Analyzer 实现的, 可以使用 ElasticSearch 内置的分词器或者按照需要定制化分词器</li><li>除了在数据写入时转换词条, 匹配 Query 语句时候也需要用相同的分析器对查询语句进行分析</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/79071680-99690700-7d0f-11ea-95ee-7a9bbd6b0f42.png" alt="image"></p><ol><li>CharacterFilter: 针对原始文本处理, 如去除 html 标签等</li><li>Tokenizer: 按照规则切分为单词</li><li>TokenFilters: 将切分的单词进行加工, 转小写, 删除 stopwords, 增加同义词等</li></ol><p>Elasticsearch 内置分词器</p><ul><li>Standard Analyzer: 默认分词器, 按词切分, 小写处理</li><li>Simple Analyzer: 按照非子母切分(符号被过滤), 小写处理</li><li>Stop Analyzer: 停用词过滤(the, a, is), 小写处理</li><li>Whitespace Analyzer: 按照空格切分, 不转小写</li><li>Keyword Analyzer: 不分词, 直接将输入当做输出</li><li>Patter Analyzer: 正则表达式, 默认 <code>\W+</code> (非字符分隔)</li><li>Language: 提供 30 多种常见语言的分词器</li><li>Customer Analyzer: 自定义分词器</li></ul><h3 id="3-8-1-Standard-Analyzer"><a href="#3-8-1-Standard-Analyzer" class="headerlink" title="3.8.1 Standard Analyzer"></a>3.8.1 Standard Analyzer</h3><ol><li>默认分词器</li><li>按词切分</li><li>小写处理</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/79072067-9707ac80-7d11-11ea-9c77-7910c46dc2ec.png" alt="image"></p><p>按照空格进行切分, 并将切分后的单词按照小写转换, 并且不会去掉 <code>a/an/the</code> 等词</p><h3 id="3-8-2-Simple-Analyzer"><a href="#3-8-2-Simple-Analyzer" class="headerlink" title="3.8.2 Simple Analyzer"></a>3.8.2 Simple Analyzer</h3><ol><li>按照非子母切分, 非子母的都会被去除</li><li>小写处理</li></ol><h3 id="3-8-3-Whitespace-Analyzer"><a href="#3-8-3-Whitespace-Analyzer" class="headerlink" title="3.8.3 Whitespace Analyzer"></a>3.8.3 Whitespace Analyzer</h3><ol><li>仅按照空格切分</li></ol><h3 id="3-8-4-Stop-Analyzer"><a href="#3-8-4-Stop-Analyzer" class="headerlink" title="3.8.4 Stop Analyzer"></a>3.8.4 Stop Analyzer</h3><ul><li>Tokenizer:<ul><li>lower case</li></ul></li><li>Token Filters:<ul><li>Stop</li></ul></li></ul><ol><li>按照非子母切分, 非子母的文本都会被去除</li><li>小写处理</li><li>会把 <code>the/a/is</code> 等修饰词去除</li></ol><h3 id="3-8-5-Keyword-Analyzer"><a href="#3-8-5-Keyword-Analyzer" class="headerlink" title="3.8.5 Keyword Analyzer"></a>3.8.5 Keyword Analyzer</h3><ul><li><p>Tokenizer:</p><ul><li>Keyword</li></ul></li><li><p>不分词, 直接将输出当一个 Term 输出</p></li></ul><h3 id="3-8-6-Pattern-Analyzer"><a href="#3-8-6-Pattern-Analyzer" class="headerlink" title="3.8.6 Pattern Analyzer"></a>3.8.6 Pattern Analyzer</h3><ul><li>Tokenizer:<ul><li>Pattern</li></ul></li><li>Token Filters:<ul><li>Lower Case</li><li>Stop</li></ul></li></ul><ol><li>通过正则表达式进行分词</li><li>默认是 <code>\W+</code>, 非字符的符号进行分隔</li></ol><h3 id="3-8-9-Language-Analyzer"><a href="#3-8-9-Language-Analyzer" class="headerlink" title="3.8.9 Language Analyzer"></a>3.8.9 Language Analyzer</h3><p>选择指定不同语言完成分词</p><h3 id="3-8-10-ICU-Analyzer"><a href="#3-8-10-ICU-Analyzer" class="headerlink" title="3.8.10 ICU Analyzer"></a>3.8.10 ICU Analyzer</h3><ul><li>Character Filters:<ul><li>Normalization</li></ul></li><li>Tokenizer:<ul><li>ICU Tokenizer</li></ul></li><li>Token Filters:<ul><li>Normalization</li><li>Folding</li><li>Collation</li><li>Transform</li></ul></li></ul><p>更多的中分分词器:</p><ul><li>IK: 支持自定义词库, 支持热更新分词字典 <a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></li><li>THULAC: 清华大学自然语言处理与社会人文计算实验室的一套中文分词器 <a href="https://github.com/microbun/elasticsearch-thulac-plugin" target="_blank" rel="noopener">https://github.com/microbun/elasticsearch-thulac-plugin</a></li></ul><h2 id="3-9-Search-API"><a href="#3-9-Search-API" class="headerlink" title="3.9 Search API"></a>3.9 Search API</h2><ol><li>URI Search: 在 HttpGET 方式下 URL 中提供查询参数</li><li>Request Body Search: 使用 ElasticSearch 提供的基于 json 格式的更加完备的 Query Domain Specific Language(DSL)</li></ol><p>指定查询的索引</p><table><thead><tr><th>语法</th><th>范围</th></tr></thead><tbody><tr><td>/_search</td><td>集群上所有的索引</td></tr><tr><td>/index1/_search</td><td>index1</td></tr><tr><td>/index1,index2/_search</td><td>index1 和 index2</td></tr><tr><td>index*/_search</td><td>以 index 开头的索引</td></tr></tbody></table><h3 id="3-9-1-URI-Search-通过-URI-query-实现搜索"><a href="#3-9-1-URI-Search-通过-URI-query-实现搜索" class="headerlink" title="3.9.1 URI Search: 通过 URI query 实现搜索"></a>3.9.1 URI Search: 通过 URI query 实现搜索</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /movies/_search?q=2012&amp;df=title&amp;sort=year:desc&amp;from=0&amp;size=0&amp;timeout=1s  </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"profile"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>q: 指定查询语句, 使用 Query String Syntax</li><li>df: 默认字段, 不指定时, 会对所有字段进行查询</li><li>sort: 排序</li><li>from/size: 用于分页</li><li>profile: 可以查看查询如何被执行</li></ul><h4 id="3-9-1-1-指定字段-amp-泛查询"><a href="#3-9-1-1-指定字段-amp-泛查询" class="headerlink" title="3.9.1.1 指定字段 &amp; 泛查询"></a>3.9.1.1 指定字段 &amp; 泛查询</h4><blockquote><p>q=title:2012 / q=2012</p></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/79130345-64c18200-7dd9-11ea-87b5-193897281771.png" alt="image"></p><p>可以看到指定 df 时, 只查询 title 中包含 2012 的文档, 可以简写为 <code>q=title:2012</code></p><p><img src="https://user-images.githubusercontent.com/17758731/79130531-b1a55880-7dd9-11ea-9eed-f52e02d76718.png" alt="image"></p><p>而如果不指定 df, ElasticSearch 会将 <code>(title.keyword:2012 | id.keyword:2012 | year:[2012 TO 2012] | genre:2012 | @version:2012 | @version.keyword:2012 | id:2012 | genre.keyword:2012 | title:2012)</code> 全部作为条件参与查询.</p><h4 id="3-9-1-2-Term-amp-Phrase"><a href="#3-9-1-2-Term-amp-Phrase" class="headerlink" title="3.9.1.2 Term &amp; Phrase"></a>3.9.1.2 Term &amp; Phrase</h4><blockquote><ul><li>Beautiful Mind 等效于 Beautiful OR Mind</li><li>“Beautiful Mind” 等效于 Beautiful AND Mind, Phrase 查询还要求前后顺序保持一致</li></ul></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/79131770-ba972980-7ddb-11ea-8dd9-f7a45808850c.png" alt="image"></p><p>查询 title 为 “Beautiful Mind” 的文档, <code>PhraseQuery</code> 代表 “Beautiful Mind”</p><p><img src="https://user-images.githubusercontent.com/17758731/79131430-2af17b00-7ddb-11ea-9d02-c08f1ab54043.png" alt="image"></p><p>可以看到, 查询方式变成了 <code>title:beautiful (title.keyword:Mind | id.keyword:Mind | MatchNoDocsQuery(&quot;failed [year] query, caused by number_format_exception:[For input string: &quot;Mind&quot;]&quot;) | genre:mind | @version:mind | @version.keyword:Mind | id:mind | genre.keyword:Mind | title:mind)</code></p><p>即 <code>(title 包含 &quot;Beautiful&quot;) 或 (匹配 &quot;Mind&quot; 泛查询)</code></p><h4 id="3-9-1-3-分组-amp-引号"><a href="#3-9-1-3-分组-amp-引号" class="headerlink" title="3.9.1.3 分组 &amp; 引号"></a>3.9.1.3 分组 &amp; 引号</h4><blockquote><ul><li>title:(Beautiful AND Mind) (分组)</li><li>title=”Beautiful Mind” (Phrase)</li></ul></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/79132307-ab64ab80-7ddc-11ea-8d0b-1b7ee7cc8ff2.png" alt="image"></p><p>此时变成了 BoolQuery, 必须满足title 中包括 <code>beautiful</code> 或 <code>mind</code> 的文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"BooleanQuery"</span>,</span><br><span class="line">            <span class="attr">"description"</span> : <span class="string">"title:beautiful title:mind"</span>,</span><br><span class="line">            <span class="attr">"time_in_nanos"</span> : <span class="number">16955769</span>,</span><br><span class="line">            <span class="attr">"children"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"type"</span> : <span class="string">"TermQuery"</span>,</span><br><span class="line">                    <span class="attr">"description"</span> : <span class="string">"title:beautiful"</span>,</span><br><span class="line">                    <span class="attr">"time_in_nanos"</span> : <span class="number">5470360</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"type"</span> : <span class="string">"TermQuery"</span>,</span><br><span class="line">                    <span class="attr">"description"</span> : <span class="string">"title:mind"</span>,</span><br><span class="line">                    <span class="attr">"time_in_nanos"</span> : <span class="number">8406435</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-1-4-Bool-操作"><a href="#3-9-1-4-Bool-操作" class="headerlink" title="3.9.1.4 Bool 操作"></a>3.9.1.4 Bool 操作</h4><ul><li><code>AND</code> / <code>OR</code> / <code>NOT</code> 或者 <code>&amp;&amp;</code> / <code>||</code> / <code>!</code><ul><li>必须大写</li><li>title:(matrix NOT reloaded): 排除《reloaded》的《matrix》</li></ul></li></ul><h4 id="3-9-1-5-分组"><a href="#3-9-1-5-分组" class="headerlink" title="3.9.1.5 分组"></a>3.9.1.5 分组</h4><ul><li><code>+</code> 表示 must</li><li><code>-</code> 表示 must_not</li><li>title:(+matrix -reloaded)</li></ul><h4 id="3-9-1-6-范围查询"><a href="#3-9-1-6-范围查询" class="headerlink" title="3.9.1.6 范围查询"></a>3.9.1.6 范围查询</h4><p>区间表示:</p><ul><li><code>[]</code> 闭区间: year:[* TO 2020]</li><li><code>{}</code> 开区间: year:{2018 TO 2020}</li></ul><h4 id="3-9-1-7-算数符号"><a href="#3-9-1-7-算数符号" class="headerlink" title="3.9.1.7 算数符号"></a>3.9.1.7 算数符号</h4><ul><li>year:&gt;2010</li><li>year:(&gt;2010 &amp;&amp; &lt;=2018)</li><li>year:(+&gt;2010 +&lt;=2018)</li></ul><h4 id="3-9-1-8-通配符查询"><a href="#3-9-1-8-通配符查询" class="headerlink" title="3.9.1.8 通配符查询"></a>3.9.1.8 通配符查询</h4><ul><li><code>?</code> 代表一个字符, <code>*</code> 代表 0 或多个字符<ul><li>title:b*</li><li>title:mi?d</li></ul></li></ul><blockquote><p>查询所有包含 B 开头单词的电影<br><img src="https://user-images.githubusercontent.com/17758731/87317863-28c5c680-c55a-11ea-8ba7-2acfc2d710d3.png" alt="image"></p></blockquote><h4 id="3-9-1-9-正则匹配"><a href="#3-9-1-9-正则匹配" class="headerlink" title="3.9.1.9 正则匹配"></a>3.9.1.9 正则匹配</h4><ul><li>title:[bt]oy</li></ul><h4 id="3-9-1-10-模糊匹配与近似查询"><a href="#3-9-1-10-模糊匹配与近似查询" class="headerlink" title="3.9.1.10 模糊匹配与近似查询"></a>3.9.1.10 模糊匹配与近似查询</h4><ul><li>title:beafutifl~1, 允许输错一个字符</li><li>title:”lord rings”~2</li></ul><h3 id="3-9-2-RequestBody-Search"><a href="#3-9-2-RequestBody-Search" class="headerlink" title="3.9.2 RequestBody Search"></a>3.9.2 RequestBody Search</h3><ul><li>将查询语句通过 HttpRequestBody 发送给 ElasticSearch</li><li>Query DSL</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /movies/_search?ignore_unavailable=true</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"profile"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"order_date"</span>: <span class="string">"desc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"order_date"</span>, <span class="string">"category.keyword"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>请求体字段</th><th>类型</th><th>功能</th></tr></thead><tbody><tr><td>profile</td><td>bool</td><td>是否返回查询过程, 类似 explain</td></tr><tr><td>query</td><td></td><td>查询条件</td></tr><tr><td>from</td><td>number</td><td>分页起点</td></tr><tr><td>size</td><td>number</td><td>分页偏移量</td></tr><tr><td>sort</td><td>list</td><td>字段名和升序/降序的组合</td></tr><tr><td>_source</td><td>list<string></string></td><td>需要查询的字段</td></tr></tbody></table><h4 id="3-9-2-1-脚本字段"><a href="#3-9-2-1-脚本字段" class="headerlink" title="3.9.2.1 脚本字段"></a>3.9.2.1 脚本字段</h4><blockquote><p>实例: 将订单日期与 <code>hello</code> 进行拼接<br><img src="https://user-images.githubusercontent.com/17758731/87319645-78a58d00-c55c-11ea-84b3-e2487ef5a80b.png" alt="image"></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /kibana_sample_data_ecommerce/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">    <span class="attr">"FIELD"</span>: &#123;</span><br><span class="line">      <span class="attr">"script"</span>: &#123;</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"doc['order_date'].value+'hello'"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-2-2-match-query"><a href="#3-9-2-2-match-query" class="headerlink" title="3.9.2.2 match query"></a>3.9.2.2 match query</h4><blockquote><p>该模式下所有的 query 单词只需要命中一个<br><img src="https://user-images.githubusercontent.com/17758731/87320647-c078e400-c55d-11ea-9b85-a7621b6aa534.png" alt="image"><br>如果添加了 and, 则所有单词需要同时出现(不记顺序)<br><img src="https://user-images.githubusercontent.com/17758731/87320934-2b2a1f80-c55e-11ea-84d5-00edebe91d09.png" alt="image"></p></blockquote><h4 id="3-9-2-3-math-phrase"><a href="#3-9-2-3-math-phrase" class="headerlink" title="3.9.2.3 math phrase"></a>3.9.2.3 math phrase</h4><blockquote><p>phrase 查询会保证顺序<br><img src="https://user-images.githubusercontent.com/17758731/87321324-b0adcf80-c55e-11ea-84c7-2f8cdd96f9d2.png" alt="image"></p></blockquote><h4 id="3-9-2-4-Query-string"><a href="#3-9-2-4-Query-string" class="headerlink" title="3.9.2.4 Query string"></a>3.9.2.4 Query string</h4><p>类似 URI Query</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"query_string"</span>: &#123;</span><br><span class="line">      <span class="attr">"default_field"</span>: <span class="string">"name"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"destiny"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-2-5-simple-query-string"><a href="#3-9-2-5-simple-query-string" class="headerlink" title="3.9.2.5 simple query string"></a>3.9.2.5 simple query string</h4><ul><li>类似 Query String, 但是会忽略错误的语法, 同时只支持部分查询语法</li><li>不支持 AND, OR, NOT, 会当做字符串处理</li><li>Term 之间默认的关系是 or, 可以指定 operator</li><li>支持部分逻辑:<ul><li><code>+</code> 代替 AND</li><li><code>|</code> 替代 OR</li><li><code>-</code> 提到 NOT</li></ul></li></ul><h2 id="3-10-Mapping"><a href="#3-10-Mapping" class="headerlink" title="3.10 Mapping"></a>3.10 Mapping</h2><ul><li>Mapping 类似数据库中 schema 的定义, 作用:<ol><li>定义索引中的字段名称</li><li>定义字段的数据类型</li><li>字段, 倒排索引的相关配置(Analyzed or Not Analyzed)</li></ol></li><li>Mapping 会把 JSON 文档映射成 Lucene 所需要的扁平格式</li><li>一个 Mapping 属于一个索引的 Type<ol><li>每个文档都属于一个 Type</li><li>一个 Type 有一个 Mapping 定义</li><li>7.0 开始不需要在 Mapping 中定义 Type 信息</li></ol></li></ul><p>字段类型:</p><ul><li>简单类型:<ol><li>Text/Keyword</li><li>Date</li><li>Integer/Folating</li><li>Boolean</li><li>IPv4 &amp; IPv6</li></ol></li><li>复杂类型: 对象和嵌套类型</li><li>特殊类型: geo_point &amp; geo_shape / percolator</li></ul><h3 id="3-10-1-Dynamic-Mapping"><a href="#3-10-1-Dynamic-Mapping" class="headerlink" title="3.10.1 Dynamic Mapping"></a>3.10.1 Dynamic Mapping</h3><ul><li>在写入文档的时候, 如果索引不存在, 就会自动创建索引</li><li>Dynamic Mapping 的机制使得我们无需手动定义 Mapping, ElasticSearch 会自动根据文档信息推算出字段的类型</li><li>如果类型设置错误, 会导致一些功能无法正常运行, 例如 Range 查询</li></ul><blockquote><p>类型的自动识别</p></blockquote><table><thead><tr><th>JSON 类型</th><th>ElasticSearch 类型</th></tr></thead><tbody><tr><td>字符串</td><td>匹配日期格式, 设置成 Date<br>配置数字设置为 float或 long, 该选项默认关闭<br>设置为 Text, 并且增加 keyword 子字段</td></tr><tr><td>布尔</td><td>boolean</td></tr><tr><td>浮点数</td><td>float</td></tr><tr><td>整数</td><td>long</td></tr><tr><td>对象</td><td>object</td></tr><tr><td>数组</td><td>由第一个非空数值的类型所决定</td></tr><tr><td>空值</td><td>忽略</td></tr></tbody></table><h3 id="3-10-2-Mapping-字段的修改"><a href="#3-10-2-Mapping-字段的修改" class="headerlink" title="3.10.2 Mapping 字段的修改"></a>3.10.2 Mapping 字段的修改</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"_doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"dynamic"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段的新增:<ul><li>Dynamic 为 true 时, 一旦有新增字段的文档写入, Mapping 也同时被更新</li><li>Dynamic 为 false 时, Mapping 不会被更新, 新增字段无法被索引, 但是信息会出现在 <code>_source</code> 中</li><li>Dynamic 为 strict 时, 文档写入失败</li></ul></li><li>修改字段<ul><li>正常情况下一旦写入就不再支持修改字段定义, 因为 Lucene 实现倒排索引一旦生成就不允许修改</li><li>如果希望改变字段类型, 需要 Reindex, 重建索引</li></ul></li></ul><blockquote><p>如果修改了字段的数据类型, 会导致已被索引的数据无法被搜索, 如果只是新增字段, 就不会有影响</p></blockquote><h3 id="3-10-3-显式-Mapping-设置"><a href="#3-10-3-显式-Mapping-设置" class="headerlink" title="3.10.3 显式 Mapping 设置"></a>3.10.3 显式 Mapping 设置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    // mapping definition</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考 API 手册</li><li>先自动创建, 再手动修改:<ol><li>创建临时 index, 写入样本数据</li><li>获取该临时 index 的动态 Mapping 定义</li><li>修改后用该配置创建真正的索引</li><li>删除临时索引</li></ol></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"firstName"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"lastName"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"mobile"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        "index": false, // 设为 false 则不提供搜索</span><br><span class="line">        "null_value": "NULL" // 需要对 NULL 实现搜索</span><br><span class="line">      &#125;,</span><br><span class="line">      "bio": &#123;</span><br><span class="line">        "type": "text",</span><br><span class="line">        "index_options": "offsets"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>四种不同级别的 indexOptions 配置, 可以控制倒排索引记录的内容:<ol><li>docs: 记录 doc id</li><li>freqs: 记录 doc id / term frequencies</li><li>positions: 记录 doc id / term frequencies / term position</li><li>offsets: 记录 doc id / term frequencies / term position / character offsets</li></ol></li><li>text 类型默认记录 positions, 其他默认为 docs</li><li>记录内容越多, 占用存储空间越大</li></ul><h3 id="3-10-4-copy-to-设置"><a href="#3-10-4-copy-to-设置" class="headerlink" title="3.10.4 copy_to 设置"></a>3.10.4 copy_to 设置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"firstName"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="attr">"copy_to"</span>: <span class="string">"fullName"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"lastName"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="attr">"copy_to"</span>: <span class="string">"fullName"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>_all</code> 在 7.0 以上版本中被 <code>copy_to</code> 所替代</li><li>满足一些特定的搜索需求</li><li><code>copy_to</code> 将字段的数值拷贝到目标字段中, 实现类似 <code>_all</code> 的作用</li><li><code>copy_to</code> 的目标字段不会出现在 <code>_source</code> 中</li></ul><h3 id="3-10-5-数组类型"><a href="#3-10-5-数组类型" class="headerlink" title="3.10.5 数组类型"></a>3.10.5 数组类型</h3><p>ElasticSearch 中不提供专门的数组类型, 但是任何字段都可以包含多个相同类型的数值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT user/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"onebird"</span>,</span><br><span class="line">  <span class="attr">"interests"</span>: <span class="string">"reading"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"twobirds"</span>,</span><br><span class="line">  <span class="attr">"interests"</span>: [</span><br><span class="line">    <span class="string">"reading"</span>,</span><br><span class="line">    <span class="string">"music"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-生态圈&quot;&gt;&lt;a href=&quot;#1-1-生态圈&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解 nginx</title>
    <link href="https://destinywang.github.io/blog/2019/11/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-nginx/"/>
    <id>https://destinywang.github.io/blog/2019/11/17/深入理解-nginx/</id>
    <published>2019-11-17T14:37:24.000Z</published>
    <updated>2020-04-05T03:03:52.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Nginx-简介"><a href="#1-Nginx-简介" class="headerlink" title="1. Nginx 简介"></a>1. Nginx 简介</h2><h3 id="1-1-Nginx-的三个主要应用场景"><a href="#1-1-Nginx-的三个主要应用场景" class="headerlink" title="1.1 Nginx 的三个主要应用场景"></a>1.1 Nginx 的三个主要应用场景</h3><ol><li>静态资源服务: 通过本地文件系统提供服务</li><li>反向代理服务: 缓存, 负载均衡</li><li>API 服务: OpenResty</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/69009167-cd711380-098d-11ea-8c78-2a5c8d1a713b.png" alt="image"></p><p>用户请求会首先经过 Nginx, 再导应用服务(如 Tomcat, Apache 等), 应用服务根据自身逻辑再去访问存储服务(如 MySQL, Redis, Elasticsearch 等), 通过这样的方式对外部提供最基础的服务.</p><p>这样的一个典型架构模式中, Nginx 往往处于企业内网的边缘节点, 随着网络链路的增长, 用户的请求时延会不断变长, 如果我们能够把所有用户在一段时间内看起来不变的动态内容缓存在 Nginx 上, 由 Nginx 直接向用户提供反馈, 这样时延就会相应得到降低, 因此反向代理会衍生出另一个功能: 缓存加速, 这样能够加速我们的访问. 很多时候当我们在访问 css, JavaScript 以及小图片的时候, 这样的资源没有必要通过应用服务器来返回, 只需要通过本地文件查询系统上放置的静态资源, 由 Nginx 提供访问即可.</p><p>此外由于应用服务普遍运行效率较低, QPS 受限, 因此通常会将多个应用服务组成集群, 向用户提供高性能, 高可用, 可扩展的服务, 此时就需要可以提供反向代理功能的 Nginx 来将动态请求传导给应用服务器. 当多个应用服务器构成集群之后, 就需要能够支持服务的弹性伸缩, 如节点的新增和下线, 因此反向代理服务器必须具备负载均衡功能.</p><p>最后, 由于应用服务的性能存在瓶颈, 但数据库由于使用场景简单, 并发性能较高, 因此性能高于应用服务, 所以 Nginx 可以直接访问数据库, Redis, 利用 Nginx 自身强大的性能实现如 Web 防火墙等功能直接提供给用户, 这要求 API 服务有强大的业务处理功能. 因此向 OpenResty, 以及 Nginx 集成 JavaScript, 利用 JS, LUA 提供完整的 API 服务.</p><h3 id="1-2-Nginx-的优点"><a href="#1-2-Nginx-的优点" class="headerlink" title="1.2 Nginx 的优点"></a>1.2 Nginx 的优点</h3><ol><li>高并发, 高性能: 同时具备高并发和高性能, 高并发往往需要为每个连接分配的资源尽可能少, 高性能需要好的设计, Nginx 在 32 核 64G 内存的服务器上可以达到千万级的并发连接, 对于简单的请求可以达到百万级.</li><li>可扩展性好: 可扩展性主要体现在 Nginx 的模块化设计, 稳定的模块化设计使得第三方模块生态圈非常丰富.</li><li>高可靠性: Nginx 可以在服务器上持续不间断的运行数年. 由于 Nginx 往往出现在企业内网的边缘节点, 直接面向用户, 因此可靠性非常重要, 是企业能够向用户提供 4 个 9 甚至更高可靠性的保障.</li><li>热部署: Nginx 可以在不停止服务的情况下升级重启. 服务器可能同时存在百万级的并发连接, 如果简单 kill 掉进程会导致操作系统向所有正在连接状态的 TCP 客户端发送一个 TCP 中的终端响应. 而热部署可以保证 Nginx 重启的同事连接不会中断.</li><li>BSD 许可证: Nginx 不只是开源免费, 而且可以在有定制需要的场景下修改 Nginx 源代码, 并且运行在商业场景下, 这是合法的.</li></ol><h3 id="1-3-Nginx-的组成"><a href="#1-3-Nginx-的组成" class="headerlink" title="1.3 Nginx 的组成"></a>1.3 Nginx 的组成</h3><ol><li>二进制可执行文件: 由各模块源码编译出的一个文件, 由官方模块以及自定义的第三方模块共同组成.</li><li>Nginx.conf 文件: 控制 Nginx 的行为.</li><li>access.log 访问日志: 记录每一条 HTTP 请求信息.</li><li>error.log 错误日志: 用于定位问题.</li></ol><h3 id="1-4-编译-Nginx"><a href="#1-4-编译-Nginx" class="headerlink" title="1.4 编译 Nginx"></a>1.4 编译 Nginx</h3><p>安装 Nginx 的步骤:</p><ol><li>下载 Nginx: 可以从官网下载压缩包, 或者通过 <code>yum</code>, <code>apt-get</code> 等命令完成;</li><li>执行 <code>configure</code> 文件, 会生成很多中间文件;</li><li>执行编译</li><li>安装</li></ol><h4 id="1-4-1-下载"><a href="#1-4-1-下载" class="headerlink" title="1.4.1 下载"></a>1.4.1 下载</h4><p>可以直接在 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 页面选择合适的版本并下载</p><p><img src="https://user-images.githubusercontent.com/17758731/69018029-4bacd480-09e5-11ea-97cd-dc1a361bb794.png" alt="image"></p><p>Nginx 目录下个各个文件目录的主要功能:</p><table><thead><tr><th style="text-align:center">目录名</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">auto</td><td>用辅助 configure 脚本执行时去判定 Nginx 需要支持的模块, 已经当前操作系统特性等</td></tr><tr><td style="text-align:center">conf</td><td>示例文件的集合, 为了方便运维配置, 可以把示例文件拷贝到安装目录</td></tr><tr><td style="text-align:center">contrib</td><td>提供了两个 peal 脚本和 vim 工具, 由于 vim 默认不支持 Nginx 语法高亮, 我们可以将 contrib/vim 下的所有文件拷贝到本地 vim 配置中 <code>cp -r contrib/vim/* ~/.vim/</code>, 此时 vim 就支持 Nginx 配置文件的语法高亮了 <img src="https://user-images.githubusercontent.com/17758731/69018388-27ea8e00-09e7-11ea-8bde-77bb8c66c3d8.png" alt="image"></td></tr><tr><td style="text-align:center">html</td><td>提供了两个 HTML 文件, 一个是发现 50X 错误时, 可以默认重定向到该页面, 另一个是默认的欢迎界面</td></tr><tr><td style="text-align:center">man</td><td>Linux 对 Nginx 的帮助文件</td></tr><tr><td style="text-align:center">src</td><td>Nginx 的源代码目录</td></tr><tr><td style="text-align:center">CHANGES</td><td>记录了当前 Nginx 版本新增的 feature 以及 bugfix</td></tr><tr><td style="text-align:center">CHANGES.ru</td><td>俄语版 CHANGES文件</td></tr><tr><td style="text-align:center">configure</td><td>用来生成中间文件的脚本, 是执行编译前的一个必备动作</td></tr></tbody></table><h4 id="1-4-2-configure-命令"><a href="#1-4-2-configure-命令" class="headerlink" title="1.4.2 configure 命令"></a>1.4.2 configure 命令</h4><p>configure 命令的参数主要分为几个部分:</p><ol><li>Nginx 运行中辅助文件路径:</li></ol><table><thead><tr><th style="text-align:center">参数名</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>--modules-path=$PATH</code></td><td>nginx 引用动态模块的路径</td></tr><tr><td style="text-align:center"><code>--lock-path=$PATH</code></td><td>设置 nginx.lock 文件的路径</td></tr><tr><td style="text-align:center"><code>--prefix=$PATH</code></td><td>指定编译输出的路径, 其他路径都会使用该前缀路径</td></tr></tbody></table><ol start="2"><li>确定使用/启用模块(前缀通常是 <code>--with/--without</code>)</li></ol><p>以 <code>--with</code> 前缀开始的模块名意味着 Nginx 默认不会编译进来, 而以 <code>--without</code> 前缀开始的模块名意味着 Nginx 默认会编译进来.</p><ol start="3"><li>指定 Nginx 中需要的特殊参数</li></ol><table><thead><tr><th style="text-align:center">参数名</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>--with-debug</code></td><td>编译时打印 debug 参数</td></tr></tbody></table><p>执行完 configure 命令后, Nginx 安装路径下会自动创建一个目录 <code>objs</code>, 其中有一个 <code>ngx_modules.c</code>, 该文件决定后面的编译会引入哪些模块.</p><p><img src="https://user-images.githubusercontent.com/17758731/69063029-c104bd80-0a56-11ea-9059-fa4439c01898.png" alt="image"></p><p>所有被编译的模块会在该文件中被声明为一个 <code>ngx_module_t</code> 类型的数组.</p><p>依次进行 <code>make</code> 和 <code>make install</code> 即可.</p><h3 id="1-5-Nginx-配置语法"><a href="#1-5-Nginx-配置语法" class="headerlink" title="1.5 Nginx 配置语法"></a>1.5 Nginx 配置语法</h3><ol><li>配置文件由指令与指令块构成;</li><li>每条指令以 <code>;</code> 分号结尾, 指令与参数间以空格符号分割;</li><li>指令块以 <code>{}</code> 大括号将多条指令组织在一起;</li><li><code>include</code> 语句允许组合多个配置文件以提升可维护性;</li><li>使用 <code>#</code> 符号添加注释, 提高可读性;</li><li>使用 <code>$</code> 符号使用变量;</li><li>部分指令的参数支持正则表达式;</li></ol><p>如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">inclue</span>      mime.types;</span><br><span class="line">    <span class="attribute">upstream</span> thwp &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> http2;</span><br><span class="line">        <span class="comment"># Nginx 配置语法</span></span><br><span class="line">        <span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=1r/s;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~* \.(gif|jpg|jpeg)$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_cache</span> my_cache;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">3m</span>; <span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">302</span> <span class="number">1d</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://thwp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置块的主要内容:</p><ol><li>http: 包含的所有的指令都由 http 模块去解析</li><li>upstream: 表示上游服务, 当 Nginx 需要与 Tomcat 等服务交互时, 需要定义 upstream</li><li>server: 定义的一组域名</li><li>location: 一组 url 表达式</li></ol><h4 id="1-5-1-配置参数-时间单位"><a href="#1-5-1-配置参数-时间单位" class="headerlink" title="1.5.1 配置参数: 时间单位"></a>1.5.1 配置参数: 时间单位</h4><table><thead><tr><th style="text-align:center">配置单位</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ms</td><td style="text-align:center">毫秒</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">秒</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">分</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">小时</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">天</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">周</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">月, 30 天</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">年, 365 天</td></tr></tbody></table><h4 id="1-5-2-配置参数-空间单位"><a href="#1-5-2-配置参数-空间单位" class="headerlink" title="1.5.2 配置参数: 空间单位"></a>1.5.2 配置参数: 空间单位</h4><table><thead><tr><th style="text-align:center">配置单位</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">字节</td></tr><tr><td style="text-align:center">k/K</td><td style="text-align:center">kb</td></tr><tr><td style="text-align:center">m/M</td><td style="text-align:center">MB</td></tr><tr><td style="text-align:center">g/G</td><td style="text-align:center">GB</td></tr></tbody></table><h3 id="1-6-Nginx-命令行"><a href="#1-6-Nginx-命令行" class="headerlink" title="1.6 Nginx 命令行"></a>1.6 Nginx 命令行</h3><p>命令行规则:</p><ol><li>格式: nginx + 命令 + 参数, 如 <code>nginx -s reload</code></li><li>帮助: <code>-?</code> 或 <code>-h</code></li><li>使用指定配置文件: <code>-c</code></li><li>指定配置指令: <code>-g</code></li><li>指定运行目录: <code>-p</code></li><li>发送信号: <code>-s</code><ol><li>立刻停止服务: stop</li><li>优雅的停止服务: quit</li><li>重新加载配置文件: reload</li><li>重新开始记录日志文件: reopen</li></ol></li><li>测试配置文件是否有语法错误: <code>-t</code> 或 <code>-T</code></li><li>打印 Nginx 版本信息, 编译信息等: <code>-v</code> 或 <code>-V</code></li></ol><h4 id="1-6-1-重载配置文件"><a href="#1-6-1-重载配置文件" class="headerlink" title="1.6.1 重载配置文件"></a>1.6.1 重载配置文件</h4><p>重载配置文件指的是在 Nginx 不重启的前提下修改配置文件. 在修改了配置文件后, 可以直接执行下面命令, 让 Nginx 进程再不停止的情况下重新加载配置文件.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="1-6-2-热部署"><a href="#1-6-2-热部署" class="headerlink" title="1.6.2 热部署"></a>1.6.2 热部署</h4><p>热部署指的是在 Nginx 不重启的前提下更新 Nginx 版本, 此时只需要更换 Nginx 的二进制文件(/sbin/nginx)即可, 将新版本的 nginx 二进制文件放入 sbin 路径下</p><p><img src="https://user-images.githubusercontent.com/17758731/69107614-eb816580-0aac-11ea-993c-354a17eb4db8.png" alt="image"></p><h4 id="1-6-3-日志切割"><a href="#1-6-3-日志切割" class="headerlink" title="1.6.3 日志切割"></a>1.6.3 日志切割</h4><p>当 Nginx 运行一段时间后, 日志量会比较大, 此时可以通过日志切割, 将一段时间范围之外的日志切割出去, 保持当前文件日志量不会太大, 此外, 该过程依然需要保持 Nginx 处于运行状态.</p><p><img src="https://user-images.githubusercontent.com/17758731/69108643-436d9b80-0ab0-11ea-840b-fa35634f73f6.png" alt="image"></p><p>上图的方式就完成了一次日志切割, 利用 <code>nginx -s reopen</code> 实现, 但实际场景中, 我们更多是希望能够每天或者每周自动执行一次日志切割, 这样可以写成一个 bash 脚本, 先复制当前日志文件, 再执行 reopen, 再将该脚本放在 crontab 中定时执行.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">LOGS_PATH=/Users/destiny/dev/nginx/logs/<span class="built_in">history</span></span><br><span class="line">CUR_LOGS_PATH=/Users/destiny/dev/nginx/logs</span><br><span class="line">YESTERDAY=$(date -d <span class="string">"yesterday"</span> +%Y-%m-%d)</span><br><span class="line">mv <span class="variable">$&#123;CUR_LOGS_PATH&#125;</span>/access.log <span class="variable">$&#123;LOGS_PATH&#125;</span>/access_<span class="variable">$&#123;YESTERDAY&#125;</span>.<span class="built_in">log</span></span><br><span class="line">mv <span class="variable">$&#123;CUR_LOGS_PATH&#125;</span>/error.log <span class="variable">$&#123;LOGS_PATH&#125;</span>/error<span class="variable">$&#123;YESTERDAY&#125;</span>.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 向 Nginx 主进程发送 USR1 信号, USR1 信号是重新打开日志文件, 等同于 reopen</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 $(cat /Users/destiny/dev/nginx/logs/nginx.pid)</span><br></pre></td></tr></table></figure><h3 id="1-7-Nginx-作为静态资源服务器的典型场景"><a href="#1-7-Nginx-作为静态资源服务器的典型场景" class="headerlink" title="1.7 Nginx 作为静态资源服务器的典型场景"></a>1.7 Nginx 作为静态资源服务器的典型场景</h3><h4 id="1-7-1-展示静态页面"><a href="#1-7-1-展示静态页面" class="headerlink" title="1.7.1 展示静态页面"></a>1.7.1 展示静态页面</h4><p>使用 Hadoop 的 HTML 格式文档用来展示, 目录结构如下:</p><p><img src="https://user-images.githubusercontent.com/17758731/69154134-66cd3080-0b1a-11ea-9fa8-def4c162b512.png" alt="image"></p><p>将该路径复制到 Nginx 的安装路径下</p><p><img src="https://user-images.githubusercontent.com/17758731/69154346-cdeae500-0b1a-11ea-8a5c-0b48336e1f00.png" alt="image"></p><p>可以看到此时 Nginx 安装文件下新增了一个 <code>hadoop</code> 文件.</p><p>修改 Nginx 配置文件, <code>conf/nginx.conf</code>:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 配置监听的端口</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8000</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拦截所有的 URL, 都去访问 Nginx 安装路径下的 hadoop/ 路径</span></span><br><span class="line">        <span class="comment"># URL 的后缀需要与文件后缀一一对应</span></span><br><span class="line">        <span class="comment"># localhost:8000/abc.html =&gt; hadoop/abc.html</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">alias</span> hadoop/;</span><br><span class="line">            <span class="comment"># root   html;</span></span><br><span class="line">            <span class="comment"># index  index.html index.htm;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Nginx 就可以看到效果:</p><p><img src="https://user-images.githubusercontent.com/17758731/69155207-3e463600-0b1c-11ea-8dc4-a649886b801f.png" alt="image"></p><p>此时我们已经完成了 Nginx 最基础的功能之一, 构建静态 web 站点.</p><h4 id="1-7-2-压缩响应"><a href="#1-7-2-压缩响应" class="headerlink" title="1.7.2 压缩响应"></a>1.7.2 压缩响应</h4><p><img src="https://user-images.githubusercontent.com/17758731/69155384-92511a80-0b1c-11ea-8102-6c5b2c0ff529.png" alt="image"></p><p>在上面的请求中, 我们可以看到 <code>hadoop-project-dist/hadoop-common/CLIMiniCluster.html</code> 请求的大小为 23.1KB, 这与实际的文件大小一致, Nginx 提供了GZIP 压缩的功能, 通常文本文件经过 GZIP 压缩后的大小会有大幅的降低, 因此我们可以通过配置开启 GZIP 压缩功能:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启 gzip</span></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 设置允许压缩的最小长度, 超过大小的文件才会开启压缩功能</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 压缩级别</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment"># 只针对列出类型的文件进行压缩</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时重启 Nginx 后强制刷新页面可以看到文件大小已经大幅降低, 并且响应头中也带上了 <code>Content-Encoding: gzip</code> 标识, 说明经过了压缩.</p><p><img src="https://user-images.githubusercontent.com/17758731/69156437-5d45c780-0b1e-11ea-8163-ca7f04cfe52f.png" alt="image"></p><h4 id="1-7-3-目录浏览"><a href="#1-7-3-目录浏览" class="headerlink" title="1.7.3 目录浏览"></a>1.7.3 目录浏览</h4><p>Nginx 中 <code>auto_index</code> 模块可以提供这样的功能:</p><blockquote><p>当我们访问以 <code>/</code> 结尾的 URL 时, 把目录中的文件结构返回</p></blockquote><p>配置方法也很简单, 在 location 模块中加入启动 autoindex 即可.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">alias</span> hadoop/;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-4-响应限流"><a href="#1-7-4-响应限流" class="headerlink" title="1.7.4 响应限流"></a>1.7.4 响应限流</h4><p>由于公网带宽比较有限, 当有大量用户访问大文件时, 请求之间会形成争抢关系, 可能会为了当用户访问大文件时限制其速度, 以期望能够分离出足够的带宽以供用户访问小文件. 此时可以通过 set 命令以及内置的变量完成该功能</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">alias</span> hadoop/;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 限制 Nginx 向客户浏览器发送响应的速度, 每秒最多传输 1k 字节</span></span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$limit_rate</span> <span class="number">1k</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置文件后重启 Nginx</p><p><img src="https://user-images.githubusercontent.com/17758731/69158562-9b90b600-0b21-11ea-9856-339e826d4fd5.png" alt="image"></p><p>再强制刷新页面后可以看到, 此时响应速度维持在 1k/s 的速度. <code>hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html</code> 文件大小为 13KB, 请求用时 13s.</p><h4 id="1-7-5-访问日志-access-log"><a href="#1-7-5-访问日志-access-log" class="headerlink" title="1.7.5 访问日志(access.log)"></a>1.7.5 访问日志(access.log)</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志格式</span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志路径, 对所在模块生效, 第一个参数是日志路径, 第二个是采用的日志格式</span></span><br><span class="line">    <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面日志就会按照 main 所规定的格式打印, 此外还有很多不同的参数支持自定义配置, 如 <code>http-core-module</code> 下的 <code>$content_length</code> 等.</p><h3 id="1-8-Nginx-作为具备缓存功能的反向代理服务器应用场景"><a href="#1-8-Nginx-作为具备缓存功能的反向代理服务器应用场景" class="headerlink" title="1.8 Nginx 作为具备缓存功能的反向代理服务器应用场景"></a>1.8 Nginx 作为具备缓存功能的反向代理服务器应用场景</h3><h4 id="1-8-1-反向代理功能"><a href="#1-8-1-反向代理功能" class="headerlink" title="1.8.1 反向代理功能"></a>1.8.1 反向代理功能</h4><p>以上个例子的 Hadoop 文档服务器作为上游服务器, 我们搭建一个用户实现反向代理的 Nginx 服务器, 可以支持反向代理以及缓存.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># upstream 定义一批上游服务器</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">9000</span>;</span><br><span class="line">        <span class="comment"># 反向代理服务器的域名</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 将 HTTP 请求添加自定义的 header 发送给上游</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将 location 匹配到的请求代理到下面的路径</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置中, 我们对作为反向代理的 Nginx 服务器开启了 <code>upstream</code> 配置, 表示上游服务, Nginx 就会将匹配的请求转发到该配置块内部的 server 中, 如果 server 包含多个节点, 我们可以配置分发的策略, 包括 hash, 轮询等. <code>upstream</code> 配置块定义的一批服务器, 可以以一个统一的名字命名, 上例中起名为 <code>local</code>.</p><p><code>location</code> 配置块中通过 <code>proxy_pass</code> 配置, 将匹配的所有请求代理到 <code>local</code> 的所有上游服务中.</p><p>此时通过 <a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a> 就可以通过代理服务器访问到 Hadoop 的文档.</p><h4 id="1-8-2-缓存"><a href="#1-8-2-缓存" class="headerlink" title="1.8.2 缓存"></a>1.8.2 缓存</h4><p>在 web 开发中, 通常只有不同用户展示内容不同的动态内容才需要请求应用服务器, 对于一段时间内不会发生变化的内容, 为了减轻上游服务器的压力, 我们可以让 Nginx 把上游服务器返回的内容缓存一段时间. 由于一般情况下, Nginx 的性能远高于普通应用服务器, 因此对于小站点会有较大的性能提升.</p><p>Nginx 缓存的使用方式:</p><ol><li>在 HTTP 配置块中声明缓存配置</li><li>在需要开启缓存的 location 配置块中启用</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置缓存文件路径, 文件的命名方式, 文件的 key(关键字需要放在共享内存中)</span></span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /tmp/nginxcache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">9000</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 将 HTTP 请求添加自定义的 header 发送给上游</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 指定使用上面声明的共享内存 my_cache</span></span><br><span class="line">            <span class="attribute">proxy_cache</span> my_cache;</span><br><span class="line">            <span class="comment"># 在共享内存中设置的 key, 由于同一个 uri 不同用户的返回可能不同, 此时需要将参数也作为 key</span></span><br><span class="line">            <span class="attribute">proxy_cache_key</span> <span class="variable">$host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">            <span class="comment"># 对于哪些响应开启缓存</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">302</span> <span class="number">1d</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将 location 匹配到的请求代理到下面的路径</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置生效后, 当 Nginx 反向代理服务器拥有缓存时, 即使停掉应用服务器依然可以正常提供服务.</p><h3 id="1-9-access-日志"><a href="#1-9-access-日志" class="headerlink" title="1.9 access 日志"></a>1.9 access 日志</h3><p>access 日志记录了 Nginx 运行时的访问信息, 我们可以通过 access 日志来分析定位问题以及用户的运营数据, 但大部分都是离线场景, 在线实时分析相对比较困难, 而 GoAccess 可以通过图形化的方式, 通过 websocket 协议实时把 access 日志的内容展示出来, 方便我们分析问题.</p><p>原生的 access 日志内容:</p><pre><code>127.0.0.1 - - [21/Nov/2019:23:04:13 +0800] &quot;GET /css/print.css HTTP/1.0&quot; 200 215 &quot;http://127.0.0.1:9000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:04:13 +0800] &quot;GET /images/breadcrumbs.jpg HTTP/1.0&quot; 200 349 &quot;http://127.0.0.1:9000/css/maven-theme.css&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:04:13 +0800] &quot;GET /images/external.png HTTP/1.0&quot; 200 230 &quot;http://127.0.0.1:9000/css/maven-theme.css&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:04:13 +0800] &quot;GET /images/h5.jpg HTTP/1.0&quot; 200 357 &quot;http://127.0.0.1:9000/css/maven-theme.css&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET / HTTP/1.0&quot; 200 20536 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /css/maven-base.css HTTP/1.0&quot; 200 2310 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /css/maven-theme.css HTTP/1.0&quot; 200 4624 &quot;http://127.0.0.1:9000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /css/site.css HTTP/1.0&quot; 200 936 &quot;http://127.0.0.1:9000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /images/logos/maven-feather.png HTTP/1.0&quot; 200 3330 &quot;http://127.0.0.1:9000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /css/print.css HTTP/1.0&quot; 200 215 &quot;http://127.0.0.1:9000/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /images/breadcrumbs.jpg HTTP/1.0&quot; 200 349 &quot;http://127.0.0.1:9000/css/maven-theme.css&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /images/external.png HTTP/1.0&quot; 200 230 &quot;http://127.0.0.1:9000/css/maven-theme.css&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;127.0.0.1 - - [21/Nov/2019:23:28:32 +0800] &quot;GET /images/h5.jpg HTTP/1.0&quot; 200 357 &quot;http://127.0.0.1:9000/css/maven-theme.css&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;</code></pre><p><a href="https://goaccess.io/" target="_blank" rel="noopener">GoAccess官网</a></p><p><img src="https://goaccess.io/images/goaccess-dashboard.png?20190828082924" alt="image"></p><p>GoAccess 以一种友好的图形化方式展示, 当我们使用 Nginx 配置中默认的日志格式时, 可以支持使用 <code>goaccess access.log -o report.html --log-format=COMBINED</code> 命令解析, <code>-o</code> 参数会指定生成一个报表 html, <code>--log-format=COMBINED</code> 指定了解析日志的默认格式, 当我们的 access log 格式发生改变的时候, 需要更换解析格式.</p><p>效果展示:</p><ul><li><p>命令行<br><img src="https://user-images.githubusercontent.com/17758731/69478057-d0a24e80-0e28-11ea-88c8-de6a57d575a8.png" alt="image"></p></li><li><p>网页版<br><img src="https://user-images.githubusercontent.com/17758731/69478068-edd71d00-0e28-11ea-9c1c-496be9894f99.png" alt="image"></p></li></ul><h3 id="1-10-SSL-协议"><a href="#1-10-SSL-协议" class="headerlink" title="1.10 SSL 协议"></a>1.10 SSL 协议</h3><p>大部分站点都通过使用 HTTPS 协议保证网络安全.</p><p>SSL 协议(Secure Sockets Layer), 现在更多使用 TLS(Transport Layer Security), SSL 协议是由网井公司在 1995 年推出的, 1999 年 RETF 把 SSL 更名为 TLS1.0.</p><p><img src="https://user-images.githubusercontent.com/17758731/69473898-a8006180-0df4-11ea-8060-7cab57aefdd7.png" alt="image"></p><p>在七层模型中, HTTP 处在应用层, SSL 协议处在表示层, 通过握手, 交换秘钥, 告警和对称加密的方式, 使 HTTP 层在没有感知的情况下做到数据加密.</p><p>当我们抓包时可以看到类似下图的密码配置</p><p><img src="https://user-images.githubusercontent.com/17758731/69473978-85bb1380-0df5-11ea-9122-86811e3eb0fb.png" alt="image"></p><table><thead><tr><th>TLS</th><th>_</th><th>ECDHC</th><th>_</th><th>RSA</th><th>_</th><th>WITH</th><th>_</th><th>AES</th><th>_</th><th>128</th><th>_</th><th>GCM</th><th>_</th><th>SHA256</th></tr></thead><tbody><tr><td></td><td></td><td>秘钥交换</td><td></td><td>身份验证</td><td></td><td></td><td></td><td>算法</td><td></td><td>强度</td><td></td><td>模式</td><td></td><td>MAC 或 PRF</td></tr><tr><td></td><td></td><td>椭圆曲线加密算法, 为了解决浏览器和服务器之间如何各自独立生成相同的秘钥</td><td></td><td>身份验证算法 RSA</td><td></td><td></td><td></td><td>对称加密算法名</td><td></td><td>对称加密算法加密强度</td><td></td><td>对称加密算法分组模式</td><td></td><td>摘要算法, 用来将不定长度的字符串生成定长摘要.</td></tr></tbody></table><h4 id="1-10-1-对称加密"><a href="#1-10-1-对称加密" class="headerlink" title="1.10.1 对称加密"></a>1.10.1 对称加密</h4><p>在对称加密的场景中, A 和 B 共同持有同一把秘钥, A 可以把明文通过秘钥加密生成密文, 而 B拿到密文后可以通过同一个秘钥解密出明文. 除此之外的其他人如果没有秘钥, 即使知道了对称加密的具体算法也无法解密.</p><p>具体的工作原理可以以对称加密的典型算法 <code>RC4</code> 来理解:</p><pre><code>假设我们有秘钥序列 1010, 明文内容是 0110, 通过秘钥的加密过程其实就是二者做异或操作:1010 ^ 0110 = 1100 此时就通过秘钥将原文加密, 生成密文由于异或具有对称的特性, 密文与秘钥做同样的异或操作就可以还原出明文:1100 ^ 0110 = 1010</code></pre><p>由于以上原理, 对称加密的性能较好, 基本上遍历一次就可以完成加密/解密</p><h4 id="1-10-2-非对称加密"><a href="#1-10-2-非对称加密" class="headerlink" title="1.10.2 非对称加密"></a>1.10.2 非对称加密</h4><p>相比对称加密, 非对称加密的性能就会差很多:</p><ol><li>根据数学原理, 首先会生成一对秘钥, 我们称其中一个为公钥, 另一个为私钥, 其特点是同一份明文文档, 如果用公钥加密, 只有用与其一起生成的私钥才能解密, 反之亦然.</li><li>假设 A 生成了一对公钥和私钥, 并将其公钥发布出去, 此时 B 想和 A 通信, 就需要先将自己的明文用 A 发布的公钥加密, A 接收到之后, 再用自己的私钥解密即可.</li><li>此外公钥和私钥还可以用来做身份严重, 假设有一段信息, A 用自己的私钥完成加密, 将密文发给 B, 只要 B 拿到 A 的公钥, 且可以成功解开这段密文, 就证明这段密文确实是 A 发出的.</li></ol><h4 id="1-10-3-SSL-证书的公信力如何保证"><a href="#1-10-3-SSL-证书的公信力如何保证" class="headerlink" title="1.10.3 SSL 证书的公信力如何保证"></a>1.10.3 SSL 证书的公信力如何保证</h4><p>使用公钥私钥进行加密通信的前提条件是首先需要确定消息的发送发身份, 才能使用发送者提供的公钥进行解密, 在多方通信的场景中为了解决这个问题必须有一个工信机构, 即 CA.</p><ol><li>向登记机构申请证书, 需要等级申请人身份</li><li>登记机构通过 CSR发给 CA, CA 通过之后会生成一对公钥和私钥给订阅人, 其中公钥在 CA 自身保存.</li><li>登记人获得公钥和私钥之后, 将其部署到自己的 web 服务器上.</li><li>当浏览器访问 HTTP 站点的时候, 首先会请求证书, web 服务器会将公钥证书发给浏览器, 浏览器会去验证证书是否合法</li><li>CA 会把过期的证书放在 CRL 或 OCSP 服务器上.</li></ol><p>证书的类型:</p><ol><li>域名验证(domain validated, DV) 证书, 验证域名的归属是否正确;</li><li>组织验证(origanization validated, OV)证书, 申请证书时验证企业名称, 申请较慢, 价格较高.</li><li>扩展验证(extended vaiidation, EV)证书, 会把申请证书时填写的地址名称显示出来.</li></ol><p>证书链:</p><p>目前所有站点的主证书都是由 3 个证书构成:</p><ol><li>根证书</li><li>二级证书</li><li>主证书</li></ol><p>根证书的验证非常谨慎, 操作系统每年只会更新一次根证书库, 因此新的根证书 CA 机构很难快速加入到操作系统认可的证书库. 大部分浏览器使用操作系统的证书库. Nginx 在向浏览器发送证书的时候, 只发送二级证书和主证书, 浏览器会验证二级证书的签发机构根证书是否有效.</p><h4 id="1-10-4-TLS-的通信过程"><a href="#1-10-4-TLS-的通信过程" class="headerlink" title="1.10.4 TLS 的通信过程"></a>1.10.4 TLS 的通信过程</h4><p>通信过程需要完成的任务:</p><ol><li>验证身份</li><li>达成安全套件共识</li><li>传递秘钥</li><li>加密通信</li></ol><p>具体通信步骤:</p><ol><li>由浏览器向服务器发送 client hello 消息, 不同的浏览器所支持的安全套件和加速算法都是不同的.</li><li>服务端维护一套自己支持的加密算法列表以及优先选择的加密算法套件. 发送给客户端. 发送最终选择的安全套件.</li><li>Nginx 将自己的公钥证书(包含证书链)发送给浏览器.</li><li>发送 <code>Server Hello Done</code>.</li><li>客户端根据椭圆曲线的公共参数生成自己的私钥, 再把公钥发送给服务器.</li><li>此时 Nginx 有自己的私钥, 并把公钥发送给客户端, 可以根据自己的私钥和客户端的公钥共同生成双发加密的秘钥; 客户端根据服务器发来的公钥和自己生成的私钥也可以生成秘钥, 服务器和客户端分别生成的秘钥是相同的.</li></ol><p>TLS 的工作:</p><ol><li>交换秘钥</li><li>加密数据</li></ol><p>Nginx 优化方式:</p><h4 id="1-10-5-OpenResty"><a href="#1-10-5-OpenResty" class="headerlink" title="1.10.5 OpenResty"></a>1.10.5 OpenResty</h4><h2 id="2-Nginx-架构基础"><a href="#2-Nginx-架构基础" class="headerlink" title="2. Nginx 架构基础"></a>2. Nginx 架构基础</h2><h3 id="2-1-Nginx-请求处理流程"><a href="#2-1-Nginx-请求处理流程" class="headerlink" title="2.1 Nginx 请求处理流程"></a>2.1 Nginx 请求处理流程</h3><p><img src="https://user-images.githubusercontent.com/17758731/69478508-4826ac80-0e2e-11ea-8fe2-e405105bbff5.png" alt="image"></p><ol><li>大致有三种流量会被 Nginx 接收;</li><li>Nginx 有三个主要的状态机, 分别是 处理 TCP/UDP 的传输层状态机, 处理应用层的 HTTP 状态机, 处理邮件的 Mail 状态机. 被称为状态机是因为Nginx 是通过非阻塞事件驱动处理引擎(epoll), 一旦使用异步处理引擎, 通常都需要通过状态机来把请求正确的识别和处理;</li><li>通过解析如果发现请求需要访问静态资源, 就会走磁盘缓存;</li><li>如果发现请求走反向代理, 反向代理的内容可以做磁盘缓存;</li><li>在处理静态资源的时候, 如果内存不足以完全缓存所有资源的时候, <code>sendfile</code> 和 AIO 会退化成阻塞的磁盘调用, 因此需要线程池来处理;</li><li>对于每一个完成的请求, 需要记录 access 日志和 error 日志;</li><li>Nginx 更多是作为负载均衡/反向代理服务器使用, 因此需要把请求通过协议级传输都上游服务器.</li></ol><h3 id="2-2-Nginx-进程结构"><a href="#2-2-Nginx-进程结构" class="headerlink" title="2.2 Nginx 进程结构"></a>2.2 Nginx 进程结构</h3><ul><li>单进程结构: 不适用于生产环境, 一般仅用于开发调试</li><li>多进程结构: 更加健壮, 使用多核计算机.</li></ul><p>Nginx 进程主要分为如下几个部分:</p><ul><li><p>master, 用来完成 worker 进程的管理, 通常第三方模块不会再此加入自己的代码</p><ul><li>Cache 相关进程: 在多个 worker 进程共享, 此外还要被 CacheManager 和 CacheLoader 进程使用.<ul><li>CacheManager: 开启动态代理时后端发来的动态请求做缓存所使用.</li><li>CacheLoader:</li></ul></li><li>Worker 进程(多个): 处理外部请求, Nginx 采用事件驱动模型, 希望每个 worker 从头到尾占用一颗 CPU, 因此不只要把 worker 进程数与 CPU 核数配置相同, 还需要把每个 Worker 进程与 CPU 核心绑定在一起, 这样可以更好的使用每颗 CPU 核心上的 CPU 缓存.</li></ul></li><li><p>master/workfer 间通过信号通信;</p></li><li>worker 进程间的通信采用共享内存解决.</li></ul><blockquote><p>Nginx 采用多进程而非多线程结构的原因:<br>主要还是考虑到了不同模块之间的隔离, 由于Nginx 需要保证高可靠性, 如果采用多线程模式, 由于线程之间共享同一段地址空间, 如果当某个第三方模块引发了地址空间的段错误, 出现地址越界时, 会导致 Nginx 进程下的全部线程都挂掉; 而如果采用了多进程则不会出现这样的问题.</p></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/69479146-2a107a80-0e35-11ea-8c83-4e740e310101.png" alt="image"></p><p>当我们执行了 <code>nginx -s reload</code> 时, 可以看到 master 进程重新启动了 3 个 worker 进程.</p><p>当我们向 worker 进程发送退出信号时, 该进程退出时会自动向父进程(master)发送一个 <code>SIGCHLD</code> 信号, 这样 master 进程就知道该 worker 进程退出, 会重新再启动一个 worker 进程.</p><p><img src="https://user-images.githubusercontent.com/17758731/69479275-54af0300-0e36-11ea-9f06-9152c0e99435.png" alt="image"></p><h3 id="2-3-使用信号管理-Nginx-进程"><a href="#2-3-使用信号管理-Nginx-进程" class="headerlink" title="2.3 使用信号管理 Nginx 进程"></a>2.3 使用信号管理 Nginx 进程</h3><p>首先列出 Nginx 各个进程可接收的信号:</p><ul><li>master 进程:<ul><li>监控 worker 进程:<ul><li>CHLD: linux 操作系统中规定当子进程退出后, 需要向父进程发送 <code>CHLD</code> 信号</li></ul></li><li>通过接收信号来管理 worker 进程<ul><li>TERM, INT: 立刻停止 Nginx 进程</li><li>QUIT: 优雅停止 Nginx(保证当前连接都完成)</li><li>HUP: 重载配置文件</li><li>USR1: 重新打开日志文件, 用于日志切割</li><li>USR2: 热部署使用</li><li>WINCH</li></ul></li></ul></li><li>worker 进程: (不推荐直接对 worker 进程发送信号, 最好可以向 master 发送信号, 由 master 完成对 worker 的控制)<ul><li>TERM, INT</li><li>QUIT</li><li>USR1</li><li>WINCH</li></ul></li><li>Nginx 命令行: Nginx 在 <code>logs/nginx.pid</code> 文件中记录了当前 master 进程, 下面几个命令的执行方式就是从上面文件中找到 master 的 pid, 向该 pid 发送同样的信号<ul><li>reload: HUP</li><li>reopen: USR1</li><li>stop: TERM</li><li>quit: QUIT</li></ul></li></ul><h3 id="2-4-reload-重载配置文件的实现方式"><a href="#2-4-reload-重载配置文件的实现方式" class="headerlink" title="2.4 reload 重载配置文件的实现方式"></a>2.4 reload 重载配置文件的实现方式</h3><p>reload 命令可以在 Nginx 继续对外提供服务的同时重新加载配置文件:</p><ol><li>向 master 进程发送 HUP 信号(reload 命令触发)</li><li>master 进程校验配置语法是否正确</li><li>master 进程打开新的监听端口</li><li>master 进程用新配置启动新的 worker 子进程</li><li>master 进程向老 worker 子进程发送 <code>QUIT</code> 信号</li><li>老 worker 进程关闭监听句柄, 处理完当前连接后结束进程</li></ol><p>因此, 如果老的 worker 进程由于存在大量连接, 短时间内无法关闭, 在刚执行完 <code>nginx -s reload</code> 时会出现 worker 进程数量增加的情况.</p><h3 id="2-5-热升级的完整流程"><a href="#2-5-热升级的完整流程" class="headerlink" title="2.5 热升级的完整流程"></a>2.5 热升级的完整流程</h3><ol><li>将旧的 nginx 二进制文件替换成新的 nginx 二进制文件(注意备份)</li><li>向旧 master 进程发送 <code>USR2</code> 信号</li><li>旧 master 进程修改 pid 文件名, 加后缀 <code>.oldbin</code></li><li>旧 master 进程用新 Nginx 文件启动新 master 进程(新 master 进程是老 master 的子进程)</li><li>向老 master 进程发送 <code>QUIT</code> 信号, 关闭老 master 进程</li><li>如果需要回滚, 向老 master 发送 <code>HUP</code>, 向新 master 发送 <code>QUIT</code></li></ol><p>所谓优雅的关闭 Nginx, 主要是针对 worker 进程而言, 因为只有 worker 负责处理请求. 所谓优雅关闭就是让 Nginx 的 worker 进程可以识别出当前哪些连接不再处理请求再去关闭. </p><ol><li>设置定时器: worker_shutdown_timeout</li><li>关闭监听句柄</li><li>关闭空闲连接</li><li>在循环中等待全部连接关闭</li><li>退出进程</li></ol><h2 id="2-6-Nginx-网络事件"><a href="#2-6-Nginx-网络事件" class="headerlink" title="2.6 Nginx 网络事件"></a>2.6 Nginx 网络事件</h2><p><img src="https://user-images.githubusercontent.com/17758731/69479916-be7edb00-0e3d-11ea-8148-d70007c14a25.png" alt="image"></p><p>当主机 A 向主机 B 发送 HTTP 请求的时候:</p><ol><li>应用层发送一个 GET 请求</li><li>传输层记录通信双方的端口</li><li>网络层记录双方的公网 IP</li><li>到达链路层后经过以太网, 到达路由器, 路由器记录所在运营商的公网 ip.</li><li>再经过广域网到达主机 B 所在的路由器中</li><li>再经过链路层, 网络层, 传输层, 此时操作系统会将数据流交给对应端口的进程.</li></ol><p>TCP 报文内容:</p><p><img src="https://user-images.githubusercontent.com/17758731/69479903-a6a75700-0e3d-11ea-80a4-191211392ade.png" alt="image"></p><p>TCP 协议会将以此网络传输视上层报文大小, 拆分为多个小的报文, TCP 层会考虑中间每个环节中最大的 MTU 值, 该值被称为 MSS, 因此每收到一个 MSS 大小的报文时, 都是一个网络事件.</p><p><img src="https://user-images.githubusercontent.com/17758731/69480188-1fa7ae00-0e40-11ea-93d1-65d2db8d155e.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Nginx-简介&quot;&gt;&lt;a href=&quot;#1-Nginx-简介&quot; class=&quot;headerlink&quot; title=&quot;1. Nginx 简介&quot;&gt;&lt;/a&gt;1. Nginx 简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-Nginx-的三个主要应用场景&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Nginx" scheme="https://destinywang.github.io/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://destinywang.github.io/blog/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Viper: Go 配置管理利器</title>
    <link href="https://destinywang.github.io/blog/2019/09/07/Viper-Go-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%88%A9%E5%99%A8/"/>
    <id>https://destinywang.github.io/blog/2019/09/07/Viper-Go-配置管理利器/</id>
    <published>2019-09-07T08:35:20.000Z</published>
    <updated>2019-09-14T07:40:06.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Viper-简介"><a href="#1-Viper-简介" class="headerlink" title="1. Viper 简介"></a>1. Viper 简介</h1><h2 id="1-1-什么是-Viper"><a href="#1-1-什么是-Viper" class="headerlink" title="1.1. 什么是 Viper"></a>1.1. 什么是 Viper</h2><p>Viper 是 Go 工程的完整配置解决方案, 能够在工程中处理所有类型的需求和格式, Viper 可以支持:</p><ul><li>设置默认值</li><li>JSON, TOML, YAML, HCL, envfile 和 Java properties 配置文件的读取</li><li>实时查看并重新读取配置文件(可选)</li><li>环境变量的读取</li><li>远程配置系统(etcd 和 Consul) 的读取和变更查看</li><li>命令行标志的读取</li><li>buffer 的读取</li><li>设置显示值</li></ul><p>Viper 可以被看做一个你所有工程配置需求的注册表.</p><h2 id="1-2-为什么使用要使用-Viper"><a href="#1-2-为什么使用要使用-Viper" class="headerlink" title="1.2. 为什么使用要使用 Viper"></a>1.2. 为什么使用要使用 Viper</h2><p>在构建现代应用时, 你一定不想关心配置文件的格式, 你应该把精力放在构建出色的软件系统, Viper 就是为此而生的.</p><p>Viper 可以为你完成如下工作:</p><ul><li>从 JSON, TOML, YAML, HCL, envfile 或 Java properties 格式中找到, 加载并解析配置文件;</li><li>提供为不同配置项设置默认值的机制;</li><li>提供在命令行中指定配置项来覆盖的机制;</li><li>提供别名系统来重命名配置, 而不用破坏现有代码;</li><li>当用户提供了与默认值相同的命令行或配置文件时了, 可以很容易地区分它们.</li></ul><p>Viper 使用如下优先级顺序, 每一项都会比后面优先级更高:</p><ol><li>通过显示调用去设置</li><li>命令行参数</li><li>环境变量</li><li>配置文件</li><li>k/v 存储系统</li><li>默认值</li></ol><p>Viper 配置项的 key 大小写不敏感.</p><h2 id="1-3-向-Viper-设置值"><a href="#1-3-向-Viper-设置值" class="headerlink" title="1.3. 向 Viper 设置值"></a>1.3. 向 Viper 设置值</h2><h3 id="1-3-1-设置默认值"><a href="#1-3-1-设置默认值" class="headerlink" title="1.3.1 设置默认值"></a>1.3.1 设置默认值</h3><p>一个好的配置系统是需要支持默认值的. 默认值对于 key 来说不是必须的, 但如果配置文件, 环境变量, 远程配置系统, 命令行, Set 函数都没有指定时, 默认值将会起作用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.SetDefault(<span class="string">"ContentDir"</span>, <span class="string">"content"</span>)</span><br><span class="line">viper.SetDefault(<span class="string">"LayoutDir"</span>, <span class="string">"layouts"</span>)</span><br><span class="line">viper.SetDefault(<span class="string">"Taxonomies"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"tag"</span>: <span class="string">"tags"</span>, <span class="string">"category"</span>: <span class="string">"categories"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="1-3-2-读取"><a href="#1-3-2-读取" class="headerlink" title="1.3.2 读取"></a>1.3.2 读取</h3><p>Viper 可以搜索多个路径, 但当前一个 Viper 实例只支持单个配置文件. Viper 不会设置配置项的默认搜索路径, 需要应用程序指定.</p><p>下面是一些关于 Viper 如何搜索并读取配置文件的例子. 没有任何路径是必须的, 但至少应该提供一个需要配置文件的路径.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">"config"</span>) <span class="comment">// 配置文件名称, 不需要扩展名, viper 会自动识别</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"etc/appname/"</span>) <span class="comment">// 查找配置文件的路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"$Home/.appname"</span>) <span class="comment">// 可以多次添加查找路径</span></span><br><span class="line">viper.AddCOnfigPath(<span class="string">"."</span>) <span class="comment">// 添加当前路径</span></span><br><span class="line">err := viper.ReadInConfig() <span class="comment">// 查找并读取配置文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Errorf(<span class="string">"fatal error config file: %s\n"</span>, err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以像这样处理一些特定的错误场景:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;</span><br><span class="line">        <span class="comment">// 配置文件找不到</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 配置文件可以找到但发生了其他错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后续逻辑</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-写入"><a href="#1-3-3-写入" class="headerlink" title="1.3.3 写入"></a>1.3.3 写入</h3><h3 id="1-3-4-监视并重新读取配置文件"><a href="#1-3-4-监视并重新读取配置文件" class="headerlink" title="1.3.4 监视并重新读取配置文件"></a>1.3.4 监视并重新读取配置文件</h3><p>Viper 支持让你的应用在运行中实时读取配置文件.</p><p>需要重启服务才能使新配置生效的日子一去不复返了, Viper 支持的应用可以在运行时读取文件, 并且可以快速感知.</p><p>只需要将 <code>watchConfig</code> 告诉 Viper 实例, 也可以选在在每次发生改变时为 Viper 提供一个运行函数.</p><p>确保在调用 watchConfig 之前已经添加所有的 configPath.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viper.WatchConfig()</span><br><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span>)</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Config file changed: "</span>, e.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-5-从-io-Reader-读取配置文件"><a href="#1-3-5-从-io-Reader-读取配置文件" class="headerlink" title="1.3.5 从 io.Reader 读取配置文件"></a>1.3.5 从 io.Reader 读取配置文件</h3><p>Viper 预先定义了多个配置源, 包括文件, 环境变量, 命令行参数和远程 k/v 存储, 但你不必受它们的约束, 你依然可以实现你自己所必须的配置源并提供给 Viper.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadFromIOReader</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">viper.SetConfigType(<span class="string">"yaml"</span>)</span><br><span class="line"><span class="keyword">var</span> yamlExample = []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">Hacker: true</span></span><br><span class="line"><span class="string">name: steve</span></span><br><span class="line"><span class="string">hobbies:</span></span><br><span class="line"><span class="string">- skateboarding</span></span><br><span class="line"><span class="string">- snowboarding</span></span><br><span class="line"><span class="string">- go</span></span><br><span class="line"><span class="string">clothing:</span></span><br><span class="line"><span class="string">  jacket: leather</span></span><br><span class="line"><span class="string">  trousers: denim</span></span><br><span class="line"><span class="string">age: 35</span></span><br><span class="line"><span class="string">eyes : brown</span></span><br><span class="line"><span class="string">beard: true</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">viper.ReadConfig(bytes.NewBuffer(yamlExample))</span><br><span class="line">name := viper.Get(<span class="string">"name"</span>) <span class="comment">// this would be "steve"</span></span><br><span class="line">fmt.Printf(<span class="string">"type of name: %T\n"</span>, name)</span><br><span class="line">fmt.Printf(<span class="string">"value of name: %s"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出结果:</p><pre><code>type of name: stringvalue of name: steve</code></pre><h3 id="1-3-6-使用环境变量"><a href="#1-3-6-使用环境变量" class="headerlink" title="1.3.6 使用环境变量"></a>1.3.6 使用环境变量</h3><p>Viper 对环境变量提供了完整的支持, 有以下五种方式使用 ENV:</p><ul><li>AutomaticEnv()</li><li>BindEnv(string…): error</li><li>SetEnvPrefix(string)</li><li>SetEnvKeyReplacer(string…) *strings.Replacer</li><li>AllowEmptyEnv(bool)</li></ul><p>在使用环境变量的时候, 需要认识到 Viper 会将 ENV 变量视为区分大小写.</p><h4 id="1-3-6-1-SetEnvPrefix"><a href="#1-3-6-1-SetEnvPrefix" class="headerlink" title="1.3.6.1 SetEnvPrefix"></a>1.3.6.1 SetEnvPrefix</h4><p>Viper 提供了确保 ENV 变量唯一的机制. 通过使用 SetEnvPrefix, 你可以让 Viper 在读取环境变量时使用前缀, <code>BindEnv</code> 和 <code>AutomaticEnv</code> 都会使用这个前缀.</p><h4 id="1-3-6-2-BindEnv"><a href="#1-3-6-2-BindEnv" class="headerlink" title="1.3.6.2 BindEnv"></a>1.3.6.2 BindEnv</h4><p><code>BindEnv</code> 接收一个或两个参数, 第一个参数是 key 名, 第二个参数是环境变量名称. 环境变量的名称是大小写敏感的, 如果环境变玲名称没有提供, 那么 Viper 将自动假定环境变量匹配以下格式: <code>前缀 + &quot;_&quot; + key 名称大写</code>, 当你显式的提供了环境变量名称(即第二个参数)时, 就不会自动添加前缀. 例如, 如果第二个参数名是 <code>id</code>, Viper 就会查找环境变量 <code>ID</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEnv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">viper.SetEnvPrefix(<span class="string">"spf"</span>)</span><br><span class="line">viper.BindEnv(<span class="string">"id"</span>)</span><br><span class="line"></span><br><span class="line">os.Setenv(<span class="string">"SPF_ID"</span>, <span class="string">"13"</span>)</span><br><span class="line">id := viper.Get(<span class="string">"id"</span>)</span><br><span class="line">assert.Equal(t, id, <span class="string">"13"</span>)</span><br><span class="line"></span><br><span class="line">viper.BindEnv(<span class="string">"id"</span>, <span class="string">"myspf"</span>)</span><br><span class="line">os.Setenv(<span class="string">"myspf"</span>, <span class="string">"15"</span>)</span><br><span class="line">id = viper.Get(<span class="string">"id"</span>)</span><br><span class="line">assert.Equal(t, <span class="string">"15"</span>, id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinEnv 会将环境变量与 Viper 维护的某个变量绑定, 如果只传一个参数, 这个参数将作为 key 名, 去匹配名称为 <code>大写(前缀_key)</code> 的环境变量. 如果传入两个参数, 第二个参数将直接作为读取的环境变量, 其值将到第一个参数上</p><h4 id="1-3-6-3-AutomaticEnv"><a href="#1-3-6-3-AutomaticEnv" class="headerlink" title="1.3.6.3 AutomaticEnv"></a>1.3.6.3 AutomaticEnv</h4><p><code>AutomaticEnv</code> 是一个强大的助手, 尤其是当与 <code>SetEnvPrefix</code> 组合使用时. 当被调用时, Viper 会在任何使用 <code>viper.Get</code> 的时候检查环境变量. 检查的逻辑是如下规则: 它将如果设置了 <code>EnvPrefix</code> 检查环境变量的名称是否与加上前缀的大写 key 相匹配</p><h4 id="1-3-6-4-SetEnvKeyReplacer"><a href="#1-3-6-4-SetEnvKeyReplacer" class="headerlink" title="1.3.6.4 SetEnvKeyReplacer"></a>1.3.6.4 SetEnvKeyReplacer</h4><p><code>SetEnvKeyReplacer</code> 允许你使用 <code>strings.Replacer</code>, 以在一定程度上重写环境变量的 key. 如果默希望在 <code>Get()</code> 调用中使用 <code>-</code> 或某些东西, 但希望环境变量使用 <code>_</code> 分隔符, 那么这是非常有用的. 使用它的一个例子可以在 <code>viper_test.go</code> 中找到.</p><h3 id="1-3-7-使用命令行变量"><a href="#1-3-7-使用命令行变量" class="headerlink" title="1.3.7 使用命令行变量"></a>1.3.7 使用命令行变量</h3><p>就像 <code>BindEnv</code>, 在调用绑定方法时, 不会设置该值, 这意味着可以尽早绑定, 甚至可以在 <code>init()</code> 的时候就绑定.</p><p>对于单个标识, <code>BindPFlag</code> 方法提供此功能:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverCmd.Flags().Int(<span class="string">"port"</span>, <span class="number">1138</span>, <span class="string">"Port to run Application server on"</span>)</span><br><span class="line">viper.BindPFlag(<span class="string">"port"</span>, serverCmd.Flags().Lookup(<span class="string">"port"</span>))</span><br></pre></td></tr></table></figure><p>还可以绑定一组现有的 pflag</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pflag.Int(<span class="string">"flagname"</span>, <span class="number">1234</span>, <span class="string">"help message for flagname"</span>)</span><br><span class="line"> </span><br><span class="line">pflag.Parse()</span><br><span class="line">viper.BindPFlags(pflag.CommandLine)</span><br><span class="line"> </span><br><span class="line">i := viper.GetInt(<span class="string">"flagname"</span>)</span><br></pre></td></tr></table></figure><h1 id="2-部分源码解析"><a href="#2-部分源码解析" class="headerlink" title="2. 部分源码解析"></a>2. 部分源码解析</h1><p>以一个简单的测试用例来作为源码分析的入口:</p><blockquote><p>viper_test.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFlag</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">os.Setenv(<span class="string">"env"</span>, <span class="string">"test"</span>) <span class="comment">// 设置环境变量</span></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">viper.SetDefault(<span class="string">"Best Friend"</span>, <span class="string">"Cream"</span>)</span><br><span class="line"><span class="comment">// 绑定变量, 将环境变量 env 绑定到 viper 维护的配置 env 上</span></span><br><span class="line">viper.BindEnv(<span class="string">"env"</span>, <span class="string">"env"</span>)</span><br><span class="line">env := viper.Get(<span class="string">"env"</span>)</span><br><span class="line">assert.NotNil(t, env)</span><br><span class="line"><span class="comment">// 按照配置读取不同文件, 此时需要读取 test-conf 文件</span></span><br><span class="line">viper.SetConfigName(fmt.Sprintf(<span class="string">"%s-conf"</span>, env))</span><br><span class="line"><span class="comment">// 路径为 ./conf</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"conf"</span>)</span><br><span class="line"><span class="comment">// 类型为 yaml</span></span><br><span class="line">viper.SetConfigType(<span class="string">"yaml"</span>)</span><br><span class="line"><span class="comment">// viper 读取配置文件</span></span><br><span class="line">err := viper.ReadInConfig()</span><br><span class="line">assert.Nil(t, err)</span><br><span class="line"><span class="comment">// 取出 Color</span></span><br><span class="line">color := viper.Get(<span class="string">"Color"</span>)</span><br><span class="line">assert.Equal(t, <span class="string">"yellow"</span>, color)</span><br><span class="line"><span class="comment">// 取出 Age</span></span><br><span class="line">age := viper.Get(<span class="string">"Age"</span>)</span><br><span class="line">assert.Equal(t, <span class="number">1</span>, age)</span><br><span class="line"><span class="comment">// 取出 Hobby</span></span><br><span class="line">hobby := viper.Get(<span class="string">"Hobby"</span>)</span><br><span class="line">assert.Equal(t, <span class="number">2</span>, <span class="built_in">len</span>(hobby.([]<span class="keyword">interface</span>&#123;&#125;)))</span><br><span class="line"><span class="comment">// 取出 Best Friend</span></span><br><span class="line">bestFriend := viper.Get(<span class="string">"Best Friend"</span>)</span><br><span class="line">assert.Equal(t, <span class="string">"Cream"</span>, bestFriend)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在测试文件路径下, 还有 conf/test-conf.yaml 文件内容如下:</p><p>目录结构如下:</p><p><img src="https://user-images.githubusercontent.com/17758731/64476222-e2c40780-d1be-11e9-921d-b21bd736e7d7.png" alt="image"></p><p>内容是我的爱猫王蛋黄 :)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Color:</span> <span class="string">"yellow"</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">"DanHuang"</span></span><br><span class="line"><span class="attr">Age:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Hobby:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"Eat"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"Sleep"</span></span><br></pre></td></tr></table></figure><h2 id="2-1-Viper-对象"><a href="#2-1-Viper-对象" class="headerlink" title="2.1 Viper 对象"></a>2.1 Viper 对象</h2><p>viper 包所有暴露出的函数在内部都是 viper 对象的方法, 这些方法都是对 viper 实例对象的操作, 因此我们先看看 viper 对象的底层结构:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Viper <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 分隔键列表的分隔符, 用于一次性访问嵌套值</span></span><br><span class="line">keyDelim <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找配置文件的路径集合</span></span><br><span class="line">configPaths []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从中读取配置的文件系统</span></span><br><span class="line">fs afero.Fs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程提供者的集合, 用于搜索配置</span></span><br><span class="line">remoteProviders []*defaultRemoteProvider</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要在路径中查找的文件名称</span></span><br><span class="line">configName        <span class="keyword">string</span></span><br><span class="line">configFile        <span class="keyword">string</span></span><br><span class="line">configType        <span class="keyword">string</span></span><br><span class="line">configPermissions os.FileMode</span><br><span class="line">envPrefix         <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">automaticEnvApplied <span class="keyword">bool</span></span><br><span class="line">envKeyReplacer      *strings.Replacer</span><br><span class="line">allowEmptyEnv       <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">config         <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">override       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">defaults       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">kvstore        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">pflags         <span class="keyword">map</span>[<span class="keyword">string</span>]FlagValue</span><br><span class="line">env            <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">aliases        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">typeByDefValue <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象上存储读取属性, 这样我们就可以按顺序用注释进行回写</span></span><br><span class="line"><span class="comment">// 只有在读取的配置是属性文件时才会使用</span></span><br><span class="line">properties *properties.Properties</span><br><span class="line"></span><br><span class="line">onConfigChange <span class="function"><span class="keyword">func</span><span class="params">(fsnotify.Event)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-viper-SetDefault"><a href="#2-2-viper-SetDefault" class="headerlink" title="2.2 viper.SetDefault"></a>2.2 viper.SetDefault</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为这个 key 提供默认值, 对 key 的大小写不敏感, 仅当用户没有通过命令行, 配置或环境变量提供值时才会被使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetDefault</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123; v.SetDefault(key, value) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Viper)</span> <span class="title">SetDefault</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果传入alias，则设置适当的缺省值</span></span><br><span class="line">key = v.realKey(strings.ToLower(key))</span><br><span class="line">value = toCaseInsensitiveValue(value)</span><br><span class="line"></span><br><span class="line">path := strings.Split(key, v.keyDelim)</span><br><span class="line">lastKey := strings.ToLower(path[<span class="built_in">len</span>(path)<span class="number">-1</span>])</span><br><span class="line">deepestMap := deepSearch(v.defaults, path[<span class="number">0</span>:<span class="built_in">len</span>(path)<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// set innermost value</span></span><br><span class="line">deepestMap[lastKey] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作:</p><ol><li><a href="#221">如果传入的 key 是别名, 遍历所有别名, 直到找到真正的 key (#2.2.1)</a></li><li><a href="#222">面对复杂的 value 类型, 将其所有 key 转变为小写 (#2.2.2)</a></li><li>通过 <code>&quot;.&quot;</code> 将 key 分割, 如 <code>spring.datasource.password</code></li><li>将 path 分割的最后一个字符串转为小写</li><li>用分割后的所有前缀搜索 defaults map, 如果不存在就创建</li><li>用分割后的最后一个字符创和传入的值做键值对放入 defaults 中</li></ol><p>面对复杂的默认值配置, 最终保存的结构类似如下形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">defaults := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="string">"server"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="string">"port"</span>: <span class="number">8080</span>,</span><br><span class="line"><span class="string">"servlet"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="string">"context-path"</span>: <span class="string">"/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"spring"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="string">"datasource"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="string">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line"><span class="string">"password"</span>: <span class="number">123456</span>,</span><br><span class="line"><span class="string">"url"</span>: <span class="string">"jdbc:mysql://localhost:3306/test"</span>,</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>,</span><br><span class="line"><span class="string">"driver-class-name"</span>: <span class="string">"com.mysql.cj.jdbc.Driver"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-v-Viper-realKey"><a href="#2-2-1-v-Viper-realKey" class="headerlink" title="2.2.1 (v *Viper) realKey"></a><span id="221">2.2.1</span> (v *Viper) realKey</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Viper)</span> <span class="title">realKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">newkey, exists := v.aliases[key]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">jww.DEBUG.Println(<span class="string">"Alias"</span>, key, <span class="string">"to"</span>, newkey)</span><br><span class="line"><span class="keyword">return</span> v.realKey(newkey)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 viper 存在别名系统, 别名系统是一个递归的结构, 如 B 是 A 的别名, C 是 B 的别名, D 是 C 的别名, viper 自身使用一个 <code>aliases map[string]string</code> 来存储别名信息, 因此上例中的情况会有如下存储结构:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aliases = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line"><span class="string">"B"</span>: <span class="string">"A"</span>,</span><br><span class="line"><span class="string">"C"</span>: <span class="string">"B"</span>,</span><br><span class="line"><span class="string">"D"</span>: <span class="string">"C"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给该方法输入 D, debug 输出的结果就是:</p><pre><code>DEBUG Alias D to CDEBUG Alias C to BDEBUG Alias B to A</code></pre><p>最终返回 A.</p><p>用户在设置默认值的时候有可能传入一个别名, 由于不知道别名的指向是否是另一个别名, 因此需要通过递归的方式找到不存在为止.</p><p>因此不断的通过当前的 key 取出 value 作为 newKey, 如果 newKey 已经存在, 就需要拿着 newKey 再去取值, 直到某一次通过 newKey 取不出值, 就说明当前的 newKey 是真正的 key.</p><h3 id="2-2-2-toCaseInsensitiveValue"><a href="#2-2-2-toCaseInsensitiveValue" class="headerlink" title="2.2.2 toCaseInsensitiveValue"></a><span id="222">2.2.2</span> toCaseInsensitiveValue</h3><p>判断 value 的类型:</p><ul><li>如果是 map 类型, 将它 key 的类型全部转换为 string</li><li>转成 map[string]interface{} 之后, 做一份拷贝并将 value</li><li>如果不是 map 类型, 直接返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toCaseInsensitiveValue</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">switch</span> v := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">value = copyAndInsensitiviseMap(cast.ToStringMap(v))</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">value = copyAndInsensitiviseMap(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-1-copyAndInsensitiviseMap"><a href="#2-2-2-1-copyAndInsensitiviseMap" class="headerlink" title="2.2.2.1 copyAndInsensitiviseMap"></a>2.2.2.1 copyAndInsensitiviseMap</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyAndInsensitiviseMap</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">nm := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> m &#123;</span><br><span class="line">lkey := strings.ToLower(key)</span><br><span class="line"><span class="keyword">switch</span> v := val.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">nm[lkey] = copyAndInsensitiviseMap(cast.ToStringMap(v))</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">nm[lkey] = copyAndInsensitiviseMap(v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">nm[lkey] = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个新 map</li><li>通过遍历当前 <code>map[string]interface{}</code> 的所有键值对</li><li>将 key 改为小写</li><li>如果 value 类型是 <code>map[interface{}]interface{}</code>, 转成 <code>map[string]interface{}</code> 后递归调用当前函数</li><li>如果 value 类型是 <code>map[string]interface{}</code>, 递归调用当前函数</li><li>如果类型不再是 map, 就将当前 kv 设置进拷贝 map</li><li>返回拷贝 map</li></ul><p>对 map 进行特殊处理的原因是在配置文件系统中, 配置文件类似树形结构, 每个配置项都有值或者子配置, 如:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  servlet:</span></span><br><span class="line"><span class="attr">    context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>只有 map 用来表示递归的内容 <code>map[interface{}]interface{}</code> 意味着 map 中的每个元素可能是一个新的 map, 这个方法就是为了将上述结构复制为 <code>map[string]interface{}</code> 并遍历整个 map, 将所有的 key 转换成小写.</p><h3 id="2-2-3-deepSearch"><a href="#2-2-3-deepSearch" class="headerlink" title="2.2.3 deepSearch"></a>2.2.3 deepSearch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deepSearch</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, path []<span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> path &#123;</span><br><span class="line">m2, ok := m[k]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// intermediate key does not exist</span></span><br><span class="line"><span class="comment">// =&gt; create it and continue from there</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m[k] = m3</span><br><span class="line">m = m3</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">m3, ok := m2.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// intermediate key is a value</span></span><br><span class="line"><span class="comment">// =&gt; replace with a new map</span></span><br><span class="line">m3 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m[k] = m3</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// continue search from here</span></span><br><span class="line">m = m3</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要功能:</p><ol><li>传入 <code>defaults(map[string]interface{})</code> 和 <code>path, 分割后的所有前缀(除去最后一个元素)</code></li><li>遍历 path 的每一个元素:<ol><li>如果当前元素不存在与 defaults:<ol><li>创建新 map m3</li><li>将 k, m3 赋值给当前 m</li><li>再将m 指向该空 map, 用于下一个 key 的赋值</li><li>直接开心新一轮循环</li></ol></li><li>判断当前 value 是否为 <code>map[string]interface{}</code><ol><li>如果不是, 将空 map 赋给当前 map 的 key</li></ol></li></ol></li></ol><h2 id="2-3-BindEnv"><a href="#2-3-BindEnv" class="headerlink" title="2.3 BindEnv"></a>2.3 BindEnv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BindEnv</span><span class="params">(input ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> v.BindEnv(input...) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Viper)</span> <span class="title">BindEnv</span><span class="params">(input ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> key, envkey <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"BindEnv missing key to bind to"</span>)</span><br><span class="line">&#125;</span><br><span class="line">key = strings.ToLower(input[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input) == <span class="number">1</span> &#123;</span><br><span class="line">envkey = v.mergeWithEnvPrefix(key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">envkey = input[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">v.env[key] = envkey</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接收一个可变长度参数</li><li>变量名称是第一个参数, 环境变量名称是第二个参数</li><li>如果没指定第二个参数, 就会通过 <code>环境变量前缀大写 + _ + 变量名称大写</code> 的形式指定</li><li>以环境变量名为 key, viper 变量名为 value 放入 env 的 map 中</li></ol><h2 id="2-4-Get"><a href="#2-4-Get" class="headerlink" title="2.4 Get"></a>2.4 Get</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> v.Get(key) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Viper)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">lcaseKey := strings.ToLower(key)</span><br><span class="line">val := v.find(lcaseKey)</span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v.typeByDefValue &#123;</span><br><span class="line"><span class="comment">// TODO(bep) this branch isn't covered by a single test.</span></span><br><span class="line">valType := val</span><br><span class="line">path := strings.Split(lcaseKey, v.keyDelim)</span><br><span class="line">defVal := v.searchMap(v.defaults, path)</span><br><span class="line"><span class="keyword">if</span> defVal != <span class="literal">nil</span> &#123;</span><br><span class="line">valType = defVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> valType.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToBool(val)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToString(val)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int32</span>, <span class="keyword">int16</span>, <span class="keyword">int8</span>, <span class="keyword">int</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToInt(val)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToUint(val)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint32</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToUint32(val)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint64</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToUint64(val)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int64</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToInt64(val)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>, <span class="keyword">float32</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToFloat64(val)</span><br><span class="line"><span class="keyword">case</span> time.Time:</span><br><span class="line"><span class="keyword">return</span> cast.ToTime(val)</span><br><span class="line"><span class="keyword">case</span> time.Duration:</span><br><span class="line"><span class="keyword">return</span> cast.ToDuration(val)</span><br><span class="line"><span class="keyword">case</span> []<span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToStringSlice(val)</span><br><span class="line"><span class="keyword">case</span> []<span class="keyword">int</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToIntSlice(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将传入 key 转为小写</li><li><a href="#241">查找 key 对应的 value</a></li><li>如果为空返回</li><li>如果开启了 typeByDefValue, 需要根据不同类型依次完成转换</li></ol><h3 id="2-4-1-find"><a href="#2-4-1-find" class="headerlink" title=" 2.4.1  find"></a><span id="241"> 2.4.1 </span> find</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Viper)</span> <span class="title">find</span><span class="params">(lcaseKey <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">val    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">exists <span class="keyword">bool</span></span><br><span class="line">path   = strings.Split(lcaseKey, v.keyDelim)</span><br><span class="line">nested = <span class="built_in">len</span>(path) &gt; <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the path through the nested maps to the nested value</span></span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInDeepMap(path, castMapStringToMapInterface(v.aliases)) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the requested key is an alias, then return the proper key</span></span><br><span class="line">lcaseKey = v.realKey(lcaseKey)</span><br><span class="line">path = strings.Split(lcaseKey, v.keyDelim)</span><br><span class="line">nested = <span class="built_in">len</span>(path) &gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set() override first</span></span><br><span class="line">val = v.searchMap(v.override, path)</span><br><span class="line"><span class="keyword">if</span> val != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.override) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PFlag override next</span></span><br><span class="line">flag, exists := v.pflags[lcaseKey]</span><br><span class="line"><span class="keyword">if</span> exists &amp;&amp; flag.HasChanged() &#123;</span><br><span class="line"><span class="keyword">switch</span> flag.ValueType() &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"int"</span>, <span class="string">"int8"</span>, <span class="string">"int16"</span>, <span class="string">"int32"</span>, <span class="string">"int64"</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToInt(flag.ValueString())</span><br><span class="line"><span class="keyword">case</span> <span class="string">"bool"</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToBool(flag.ValueString())</span><br><span class="line"><span class="keyword">case</span> <span class="string">"stringSlice"</span>:</span><br><span class="line">s := strings.TrimPrefix(flag.ValueString(), <span class="string">"["</span>)</span><br><span class="line">s = strings.TrimSuffix(s, <span class="string">"]"</span>)</span><br><span class="line">res, _ := readAsCSV(s)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">case</span> <span class="string">"intSlice"</span>:</span><br><span class="line">s := strings.TrimPrefix(flag.ValueString(), <span class="string">"["</span>)</span><br><span class="line">s = strings.TrimSuffix(s, <span class="string">"]"</span>)</span><br><span class="line">res, _ := readAsCSV(s)</span><br><span class="line"><span class="keyword">return</span> cast.ToIntSlice(res)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> flag.ValueString()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInFlatMap(path, v.pflags) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Env override next</span></span><br><span class="line"><span class="keyword">if</span> v.automaticEnvApplied &#123;</span><br><span class="line"><span class="comment">// even if it hasn't been registered, if automaticEnv is used,</span></span><br><span class="line"><span class="comment">// check any Get request</span></span><br><span class="line"><span class="keyword">if</span> val, ok := v.getEnv(v.mergeWithEnvPrefix(lcaseKey)); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInAutoEnv(path) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">envkey, exists := v.env[lcaseKey]</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line"><span class="keyword">if</span> val, ok := v.getEnv(envkey); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInFlatMap(path, v.env) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Config file next</span></span><br><span class="line">val = v.searchMapWithPathPrefixes(v.config, path)</span><br><span class="line"><span class="keyword">if</span> val != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.config) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// K/V store next</span></span><br><span class="line">val = v.searchMap(v.kvstore, path)</span><br><span class="line"><span class="keyword">if</span> val != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.kvstore) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default next</span></span><br><span class="line">val = v.searchMap(v.defaults, path)</span><br><span class="line"><span class="keyword">if</span> val != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.defaults) != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// last chance: if no other value is returned and a flag does exist for the value,</span></span><br><span class="line"><span class="comment">// get the flag's value even if the flag's value has not changed</span></span><br><span class="line"><span class="keyword">if</span> flag, exists := v.pflags[lcaseKey]; exists &#123;</span><br><span class="line"><span class="keyword">switch</span> flag.ValueType() &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"int"</span>, <span class="string">"int8"</span>, <span class="string">"int16"</span>, <span class="string">"int32"</span>, <span class="string">"int64"</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToInt(flag.ValueString())</span><br><span class="line"><span class="keyword">case</span> <span class="string">"bool"</span>:</span><br><span class="line"><span class="keyword">return</span> cast.ToBool(flag.ValueString())</span><br><span class="line"><span class="keyword">case</span> <span class="string">"stringSlice"</span>:</span><br><span class="line">s := strings.TrimPrefix(flag.ValueString(), <span class="string">"["</span>)</span><br><span class="line">s = strings.TrimSuffix(s, <span class="string">"]"</span>)</span><br><span class="line">res, _ := readAsCSV(s)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">case</span> <span class="string">"intSlice"</span>:</span><br><span class="line">s := strings.TrimPrefix(flag.ValueString(), <span class="string">"["</span>)</span><br><span class="line">s = strings.TrimSuffix(s, <span class="string">"]"</span>)</span><br><span class="line">res, _ := readAsCSV(s)</span><br><span class="line"><span class="keyword">return</span> cast.ToIntSlice(res)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> flag.ValueString()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// last item, no need to check shadowing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个 key, 找出它的 value. 将按照以下顺序检查:<br>命令行标识, 环境变量, 配置文件, kv存储, 默认值.</p><p>Viper 将首先检查是否存在别名。</p><ol><li>[如果存在嵌套, 通过嵌套 map 得到嵌套的值的路径]</li></ol><h4 id="2-4-1-1"><a href="#2-4-1-1" class="headerlink" title="2.4.1.1"></a>2.4.1.1</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Viper-简介&quot;&gt;&lt;a href=&quot;#1-Viper-简介&quot; class=&quot;headerlink&quot; title=&quot;1. Viper 简介&quot;&gt;&lt;/a&gt;1. Viper 简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是-Viper&quot;&gt;&lt;a href=&quot;#1-1-什么
      
    
    </summary>
    
      <category term="Go" scheme="https://destinywang.github.io/blog/categories/Go/"/>
    
      <category term="源码" scheme="https://destinywang.github.io/blog/categories/Go/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Viper" scheme="https://destinywang.github.io/blog/tags/Viper/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 MySQL 原理</title>
    <link href="https://destinywang.github.io/blog/2019/08/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MySQL-%E5%8E%9F%E7%90%86/"/>
    <id>https://destinywang.github.io/blog/2019/08/13/深入理解-MySQL-原理/</id>
    <published>2019-08-13T14:20:12.000Z</published>
    <updated>2019-09-07T08:32:02.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL-体系架构"><a href="#1-MySQL-体系架构" class="headerlink" title="1. MySQL 体系架构"></a>1. MySQL 体系架构</h1><p>MySQL 的架构整体上可以分为服务层和引擎层:</p><ul><li>Server 层涵盖了 MySQL 大多数核心服务, 包括请求的接收, 以及绝大多数内置函数(如 DATE()等)</li><li>Engine 层负责数据的读写</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/62950141-13ac5900-be1a-11e9-9497-d217c977a872.png" alt="image"></p><h2 id="1-1-连接器"><a href="#1-1-连接器" class="headerlink" title="1.1 连接器"></a>1.1 连接器</h2><pre><code>负责建立与客户端建立连接, 获取权限, 维持和管理连接</code></pre><p>通过 TCP 连接, 验证用户身份, 当连接到达时获取用户当前所有权限, 而权限的获取是一次性的, 也就是说即使登录后对该用户的权限做了修改, 也无法立即生效, 需要等到用户下一次登录 MySQL 才能体现.</p><p>常用的登录命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ mysql -h<span class="variable">$IP</span> -P<span class="variable">$PORT</span> -u<span class="variable">$USER</span> -p</span><br><span class="line">Enter password: <span class="comment"># 此时再输入密码</span></span><br></pre></td></tr></table></figure><p>然后再输入密码, 虽然 -p 后可以直接跟密码, 但此时界面不会对密码进行隐藏, 为了安全起见还是建议使用前者</p><p>在登录之后, 可以通过 <code>show processlist</code> 命令查询当前所有生效的连接, 下图是我通过两个终端分别登录本机的 MySQL, 并使用第二个连接执行该命令的结果</p><p><img src="https://user-images.githubusercontent.com/17758731/62951975-7b17d800-be1d-11e9-92c6-1c2db4c906f7.png" alt="image"></p><p>登录成功后, 如果没有后续的操作, 连接会处于 <code>Sleep</code> 状态, 如上图中 Id 为 3 的连接, 表示系统中存在的一个空闲连接. 而 Id 为 4 的连接此时由于正在执行 <code>show processlist</code> 命令, 因此 Command 列值为 <code>Query</code></p><p>MySQL 连接默认的超时时间为 8 小时, 意味着该连接如果 8 小时内没有进行任何的操作, 就会被系统逐出. 超时失效后的连接如果试图再执行任何操作, 都会被告知 <code>Lost connection to MySQL server during query</code></p><h2 id="1-2-查询缓存"><a href="#1-2-查询缓存" class="headerlink" title="1.2 查询缓存"></a>1.2 查询缓存</h2><p>MySQL 所有的查询请求都会先从查询缓存中查找, 其内容可以看做一个一个典型的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;SQL 语句, 结果集&gt;</span><br></pre></td></tr></table></figure><p>如果查询语句命中缓存就不会执行后面的操作</p><p>虽然看起来很美好, 但 MySQL 为此做了相对复杂的缓存一致性的维护, 对表的任何写操作都会导致使用该表所对应的缓存全部失效.</p><p>为什么需要全部失效呢? 因为 MySQL 对于范围查询的侦测基本上无能为力, 假设我们有如下语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, score <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> score &gt; <span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>这样一个典型的区间查询, 假设有如下操作:</p><ol><li>插入一条 score 为 92 的字段;</li><li>假设有一个 name 为 Bob 的记录, score 为 80, 现在将其修改为 91;</li></ol><p>执行这样的操作时, MySQL 难以实现也没有必要去完成对缓存细粒度的更新, 因此任何写操作都会导致该表的全部缓存失效.</p><p>这样的机制就带来了一个问题: 对于写操作比较频繁的表, 对应缓存失效非常频繁, 导致白白浪费内存和 CPU. 因此可以在配置中禁用缓存模块, 甚至在 MySQL8.0 之后, 官方已经彻底将缓存模块删除.</p><h2 id="1-3-分析器"><a href="#1-3-分析器" class="headerlink" title="1.3 分析器"></a>1.3 分析器</h2><p>分析器是执行 SQL 的第一步</p><h3 id="1-3-1-词法分析"><a href="#1-3-1-词法分析" class="headerlink" title="1.3.1 词法分析"></a>1.3.1 词法分析</h3><p>解析字符串中每个单词的含义, 建立连接后, 客户端都是已一条字符串格式的 SQL 语句与 MySQL 进行交互, 假设客户端传入了如下一条 SQL 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, gender, score <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> grade = <span class="number">4</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>在进行词法分析的时候, 会进行如下操作:</p><ol><li>从 <code>SELECT</code> 判断出这是一条查询语句</li><li>从 <code>id, name, gender, score</code> 识别为列名</li><li>从 <code>student</code> 识别出表名  </li><li>…</li></ol><p>分析的的输出是一棵语法树, 语法树的节点主要分为以下两种类型:</p><ol><li>单个元素, 例如关键字, 表名, 运算符等</li><li>子语句, 例如子查询, 而每个子语句也有一棵语法树用来表示自身的所有单个元素和子语句</li></ol><h3 id="1-3-2-语法分析"><a href="#1-3-2-语法分析" class="headerlink" title="1.3.2 语法分析"></a>1.3.2 语法分析</h3><p>根据词法分析的结果和语法规则判断输入的 SQL 语句是否满足 MySQL 语法</p><h3 id="1-3-3-语义分析"><a href="#1-3-3-语义分析" class="headerlink" title="1.3.3 语义分析"></a>1.3.3 语义分析</h3><h2 id="1-4-优化器"><a href="#1-4-优化器" class="headerlink" title="1.4 优化器"></a>1.4 优化器</h2><p>经过分析器, MySQL 已经理解了 SQL 语句要做什么, 现在需要进行优化操作</p><ol><li>根据规则(扫描行数/是否排序等)决定使用哪条索引</li><li>进行多表关联的时候, 决定表的连接顺序</li></ol><p>最终确定执行方案</p><h2 id="1-5-执行器"><a href="#1-5-执行器" class="headerlink" title="1.5 执行器"></a>1.5 执行器</h2><p>先判断用户对表有没有相应的执行权限, 如果有权限, 根据表所属的引擎调用不同接口. 至于为什么在此处才查询是否有权限, 是因为有时候 SQL 语句需要操作的表不只是 SQL 语句中使用的, 例如当有触发器需要执行时, 涉及的表就没有 体现在 SQL 语句中. 查询语句会优先执行 <code>获取满足条件的第一行</code> 接口, 然后再循环调用 <code>查询满足条件的下一行</code> 接口</p><h1 id="2-MySQL-日志系统"><a href="#2-MySQL-日志系统" class="headerlink" title="2. MySQL 日志系统"></a>2. MySQL 日志系统</h1><p>这里主要介绍两种日志, 慢查询日志和二进制日志(BinLog)</p><p>RedoLog(重做日志) 和 UndoLog(回滚日志)属于 InnoDB 提供的特性, 而非 MySQL 提供, 对二者的介绍会放在事务的实现一章.</p><h2 id="2-1-慢查询日志"><a href="#2-1-慢查询日志" class="headerlink" title="2.1 慢查询日志"></a>2.1 慢查询日志</h2><h2 id="2-2-BinLog"><a href="#2-2-BinLog" class="headerlink" title="2.2 BinLog"></a>2.2 BinLog</h2><p>BinLog 记录了对 MySQL 数据库执行更改的所有操作, BinLog 功能会将所有事务的操作通过日志的形式追加到磁盘中持久化, 不存在被自动覆盖的情况.</p><p>BinLog 是 MySQL server 层的概念, 与存储引擎无关, 但大部分支持事务的存储引擎都实现了 BinLog 的整合, 例如 InnoDB 中 BinLog 的持久化是事务中的一个步骤, InnoDB 会等待 MySQL 返回 BinLog 持久化的结果, 再决定自身是提交还是回滚, 因此对 InnoDB 来说, 任何提交的事务必然存在 BinLog.</p><h3 id="2-2-1-BinLog-内容"><a href="#2-2-1-BinLog-内容" class="headerlink" title="2.2.1 BinLog 内容"></a>2.2.1 BinLog 内容</h3><p>BinLog 有两种形式:</p><table><thead><tr><th>形式</th><th>描述</th></tr></thead><tbody><tr><td>STATEMENT</td><td>BinLog 记录的是执行的 SQL 语句本身, 优点是节省空间, 缺点是有些特定的函数在不同情况下得到的结果不同</td></tr><tr><td>ROW</td><td>BinLog 记录的是记录的修改情况, 假设一条 SQL 语句修改了 100 条语句, 该模式下 BinLog 会记录这 100 条语句的被修改情况, 缺点是浪费空间, 优点是记录的更为准确, 也不会出现 STATEMENT 模式的问题</td></tr><tr><td>MIXED</td><td>是以上两种模式的混合, 一般的语句修改使用 STATEMENT 保存, 而如果存在某些 STATEMENT 无法完成主从复制的操作, 则采用 ROW 格式保存.</td></tr></tbody></table><p>假设有如下表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`t_modified`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_t_modified`</span>(<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>当我们执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> a &gt;= <span class="number">4</span> <span class="keyword">and</span> t_modified &lt;= <span class="string">'2019-09-04'</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果 BinLog 格式为 statement, BinLog 中记录的就是 SQL 语句的原文, 但这样一条看似没有问题的 BinLog 如果用来复现数据, MySQL 会抛出一条警告, 因为这条 delete 语句带 limit, 贸然执行可能会带来数据不一致的场景:</p><ul><li>如果 delete 语句使用的是索引 idx_a, 那么会根据 idx_a 找到第一个满足条件的行</li><li>如果 delete 语句使用的索引是 idx_t_midified, 那么会根据 idx_t_midified 删除第一个满足条件的行.</li></ul><p>如果 BinLog 格式为 row, 此时的 BinLog 原文中不会存在 SQL 语句原文, 而是替换成了两个 event:</p><ul><li>Table_map event: 标识后面的操作是基于哪张表;</li><li>Delete_rows event: 用于定义删除行为.</li></ul><p>此时 BinLog 中记录的是真实被删除记录的主键, 当然不会出现主备删除不同行的问题.</p><p>此外, statement 模式下对一些函数做了处理, 例如 NOW(), 不会出现在主库从库分别记录当前时间的情况, 原理是在BinLog 生成时, 多记了一条命令: <code>SET TIMESTAMP=1567611268</code>, 通过这条命令, 让 MySQL 显式确保主备数据的一致性.</p><h3 id="2-2-2-BinLog-功能"><a href="#2-2-2-BinLog-功能" class="headerlink" title="2.2.2 BinLog 功能"></a>2.2.2 BinLog 功能</h3><p>总的来说, BinLog 具有以下功能:</p><ol><li>恢复数据, 数据库存在误操作的可能, 假设某个时间被删库跑路应该如何防范?<br>比较常见的方式是采用定级备份 + BinLog 恢复. 定时备份可以选择每日或者每周进行一次, BinLog 会一直追加. 假设数据库在 <code>t1</code> 时刻被删库跑路, 而距离 <code>t1</code> 最近的一次全量备份发生在 <code>t0</code>, 那么首先需要将 <code>t0</code> 时刻的副本覆盖, 然后就可以通过全量执行 <code>t0</code> ~ <code>t1</code> 期间的全量 BinLog 来将数据库恢复到 <code>t1</code> 时刻的状态.</li><li>主备复制, 目前数据库集群在主备模式下, 一般都使用 BinLog 来实现主从复制. 每个备库会定时从主库进行 BinLog 的同步去执行. 每个备库都维护了自身的同步进度, 同步时会根据自己当前额进度去获取其后的 BinLog.</li><li>业务需求, 业务系统间有时会通过监听 BinLog 的方式去实现通信. 如某个系统本身逻辑比较复杂, 但只需要关心其写入 DB 的数据情况, 此时就可以通过监听该系统所用数据库的 BinLog 即可. 常见的工具有 <code>Cannal</code>, <code>Maxwell</code> 等.</li></ol><p>BinLog 的日志文件格式为二进制, 其产生的二进制文件不能通过 vim, cat, tail 等命令直接查看, 需要使用 MySQL 提供的专用查看工具 <code>mysqlbinlog</code> 进行查看.</p><p>BinLog 的写入机制</p><blockquote><p>事务执行过程中, 先把日志写到 BinLog Cache, 事务提交的时候再把 BinLog Cache 写入到 BinLog 文件中.</p></blockquote><p>一个事务的 BinLog 不能被拆开, 再大的事务也要确保一次性写入. MySQL 给每个线程分配了一块 BinLog Cache 的内存, 如果超过了这个大小就需要暂存到磁盘, 事务提交的时候执行器把 BinLog Cache 里完整事务写入到 BinLog 中, 并清空 BinLog Cache.</p><p><img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png" alt="image"></p><p>每个线程都有自己的 BinLog Cache, 但是共用一份 BinLog 文件.</p><ul><li>write 操作指的是将日志写入文件系统的 Page cache, 并没有落盘, 速度较快;</li><li>fsync 会落盘</li></ul><p>wirte 和 fsync 的时机由 <code>sync_binlog</code> 控制:</p><ul><li>sync_binlog = 0, 每次提交只 write, 不 fsync</li><li>sync_binlog = 1, 每次提交既 write, 又 fsync</li><li>sync_binlog = N(N &gt; 1), 每次提交都 write, 累计 N 个后再 fsync</li></ul><p>实际业务场景中, 考虑到丢失日志量的可控性, 通常会设置为 100~1000 之间, 但这样的话如果 MySQL 宕机重启, 会丢失最新一部分事务的 BinLog 日志.</p><h1 id="3-MySQL-索引"><a href="#3-MySQL-索引" class="headerlink" title="3. MySQL 索引"></a>3. MySQL 索引</h1><h2 id="3-1-索引概述"><a href="#3-1-索引概述" class="headerlink" title="3.1 索引概述"></a>3.1 索引概述</h2><p>常见的索引有如下几种:</p><ol><li>哈希表</li><li>搜索树</li></ol><p>哈希表示一种 以 k-v 形式存储数据的结构, 其典型的实现有 Java 中的 <code>HashMap</code> 等, 只要输入查询的 key, 就可以找到其对应的 value. 哈希表的实现方式比较简单, 根据 key 计算出一个哈希值, 然后放在数组的某个特定位置, 常见的 <code>数组+链表挂链</code> 的形式就是对哈希表的实现.</p><p>哈希表的插入和查询性能十分优秀, 通常可以认为其 get/set 方法的时间复杂度是 O(1). 对于等值查询通常是首选, 在 Redis, Memcache 中均有广泛应用. 但由于其 key 的排布无序, 虽然在 put 新元素时由于不需要考虑顺序因此非常快, 但却无法处理区间查询(大于和小于)</p><p>最典型的搜索树结构就是二叉查找树, 二叉树的特点是左子树的值小于等于双亲结点, 右子树的值大于双亲结点, 在查询的时候应用二分查找的原理能够做到理想情况下 O(log(N)) 级别的插入和查询, 并且由于其本身就是有序的, 因此天然支持区间查询.</p><p>如果能够加上自平衡的功能, 例如红黑树, 确实作为索引的性能已经比较理想, 但是这样的结论仅限于内存中的数据结构.</p><p>由于数据库系统的数据和索引需要存储在磁盘上, 而对于正常的机械磁盘来说, 一次随机读平均耗时 10ms, 其实时间主要消耗在寻到和旋转磁头的延迟上了. 而顺序读一条数据的消耗大概不到前者的 1%,  因此如果想作为一个对磁盘友好的索引结构, 不能只考虑内存中的性能, 还需要尽可能的降低随机读的频率.</p><p>那么应该如何去降低随机读的频率呢? 以红黑树为例, 假设有一千万条数据, 红黑树最少需要 24 层能够容纳得下, 那就意味着如果想根据磁盘中的红黑树找到磁盘中的数据, 就需要随机读 24 次磁盘, 这显然是不能接受的, 因此想降低随机读的频率, 首先就需要尽可能降低查询次数, 也就是降低树的深度. 在数据总量保持不变的前提下, 如果想降低树的深度, 最可行的办法就是将二叉树变为多叉树. 每个节点变成多叉树之后, 其双亲结点内部相应的需要维护一个小索引(假设是 10 叉树, 则双亲节点内部需要维护其负责的 10 个区间对应的指针), 但其实这个成本是可以忽略不计的, 因为我们一次将其从磁盘中取出, 每个节点内部的索引操作都是在内存中完成. 这样就能避免在一次查询中过多操作磁盘.</p><p>因此引出了 InnoDB 索引的实现: B+树, B+树就是为了充分利用磁盘预读功能而设计的一种数据结构:</p><blockquote><p>磁盘预读与局部性原理:<br>由于存储介质的特性, 磁盘的IO 速度远远低于主存, 因此为了提高效率, 要尽量减少磁盘 IO, 因此磁盘往往不是严格按需读取, 而是每次会预读一块数据, 即使只读一个字节, 磁盘也会从这个位置开始, 顺序向后读取一定长度(默认 4k)的数据放入内存, 这样做的理论依据是注明的局部性原理:<br>当一个数据被用到时, 其附近的数据也通常马上会被使用.</p></blockquote><p>B+ 数每个节点可以存储多个关键字, 它将节点大小设置为磁盘页的大小, 充分利用了磁盘预读的功能, 每次读取磁盘页的时候就会读取整个节点, 也正因为每个节点存储着非常多的关键字(InnoDB 每个双亲结点大概可以存储 1200 个子节点), 会使得树深度很小, 进而要执行的磁盘读取操作次数就会非常少, 更多的是在内存中对读取的数据进行查询操作, 而这部分操作的消耗往往可以忽略不计.</p><p><img src="https://user-images.githubusercontent.com/17758731/63212520-4d41d480-c138-11e9-92fc-6417e6d29717.png" alt="image"></p><h2 id="3-2-InnoDB-索引模型"><a href="#3-2-InnoDB-索引模型" class="headerlink" title="3.2 InnoDB 索引模型"></a>3.2 InnoDB 索引模型</h2><p>InnoDB 支持以下几种索引:</p><ul><li>B+ 树索引</li><li>全文索引</li><li>自适应性哈希索引</li></ul><p>B+ 树索引就是传统意义上的索引, 是目前关系型数据系统中查找数据最为常用和有效的索引. 结构类似于一棵多叉树, 根据键快速找到数据. 自适应性哈希索引, 顾名思义是由 InnoDB 根据实时的查询情况自动为表生成的索引, 不能人为干预.</p><p>B+ 数索引的本质就是 B+ 树在数据库中的实现. 在 InnoDB 中, 每个 B+ 数的双亲节点大致可以保存 1200 个子节点, 可以近似理解为 1200 叉树, 那么即使在面对亿级数据量时, 也能够做到不超过 4 层, 并且 B+ 数的第二层基本会常驻内存, 因此平均场景下, InnoDB 通过索引查询一条记录最多只需要 2~4 次磁盘 IO, 意味着查询时间大致需要 20~40ms.</p><pre><code>在 InnoDB 中, 表都是根据主键顺序以索引的形式存放的, 这种存储方式称之为索引组织表. 所有的数据都存储在主键的 B+ 树中.除了主键以外的其他索引被称为辅助索引, 叶子节点存储着索引字段和主键的映射, 在通过辅助索引查询时, 需要先从辅助索引中找到记录的主键, 再回到主索引查询对应记录.</code></pre><p>下面通过一个例子来解释一下 InnoDB 是如何通过索引快速定位数据的.</p><p>假设有以下表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">index</span>(k)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="string">'Alice'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">20</span>, <span class="number">2</span>, <span class="string">'Bob'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">30</span>, <span class="number">3</span>, <span class="string">'Carl'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">50</span>, <span class="number">5</span>, <span class="string">'David'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">60</span>, <span class="number">6</span>, <span class="string">'Eartha'</span>);</span><br></pre></td></tr></table></figure><p>此时表中记录为</p><table><thead><tr><th>id</th><th>k</th><th>name</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>Alice</td></tr><tr><td>20</td><td>2</td><td>Bob</td></tr><tr><td>30</td><td>3</td><td>Carl</td></tr><tr><td>10</td><td>1</td><td>David</td></tr><tr><td>10</td><td>1</td><td>Eartha</td></tr><tr><td>10</td><td>1</td><td>Frank</td></tr></tbody></table><p><img src="https://user-images.githubusercontent.com/17758731/63221133-1535a280-c1c7-11e9-9a16-eb6ccbf017b9.png" alt="image"></p><ul><li>如果查询语句是 <code>SELECT * FROM t WHERE id = 10;</code>, 及主键查询, 则只需所搜主索引;</li><li>如果查询语句是 <code>SELECT * FROM t where k = 5;</code>, 即普通索引查询, 则需要先搜索 k 索引树, 得到 id 值为 50, 再去主索引中搜索一次, 这个过程被称为回表.</li></ul><h2 id="3-3-索引维护"><a href="#3-3-索引维护" class="headerlink" title="3.3 索引维护"></a>3.3 索引维护</h2><p>B+ 树是一种相对较为复杂的数据结构, 为了能够最大程度优化磁盘的读写, 引入了很多较为复杂的特性, 这里简单介绍一下 B+ 树节点的分裂与合并</p><p>B+ 树在插入和删除元素的时候, 都需要维护其有序性:</p><ul><li>以上图为例, 加入插入的新行 id 为 70, 则只需要在 R5 后追加一条记录. 如果插入的 id 值为 40, 就相对麻烦一些, 需要将 R4 后的数据在逻辑上向后挪, 并将 id 为 40 的记录插入到 R3 之后, 更糟的情况是, 如果该叶子节点已满, 就需要申请一个新的数据页, 然后挪动一部分数据过去, 这个过程称为页的分裂, 频繁的分裂会对性能造成影响</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/63221460-dd7d2980-c1cb-11e9-8cd8-ed1b13b6eb0b.png" alt="image"></p><table><thead><tr><th style="text-align:center">叶子节点满</th><th style="text-align:center">双亲节点满</th><th>操作</th></tr></thead><tbody><tr><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td>直接将记录插入到叶子节点</td></tr><tr><td style="text-align:center">YES</td><td style="text-align:center">NO</td><td>1. 拆分叶子节点<br>2. 将中间的节点放入双亲结点<br>3. 小于中间节点的记录放左边<br>4. 大于或等于中间节点的记录放右边</td></tr><tr><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td>1. 拆分叶子节点<br> 2. 小于中间节点的记录放在左边<br> 3. 大于中间节点的记录放在右边<br> 4. 拆分双亲结点<br> 5. 小于中间节点的记录放左边<br> 6. 大于中间节点的记录放右边<br> 7. 中间节点放入上一层双亲结点</td></tr></tbody></table><blockquote><p>为什么 InnoDB 的表推荐使用自增主键<br>从上图的插入过程可以发现, 对 B+ 树来说, 效率最高的插入方式就是插入 id 最大的元素(未必需要递增, 只需要保证每次插入最大即可), 这样的插入永远是在最后一个叶子节点中向后最佳元素. 而其他情况下的插入则需考虑节点分裂. 对数据库来说, 实现 <code>永远插入最大值</code> 最简单的方式就是自增</p></blockquote><h2 id="3-4-联合索引"><a href="#3-4-联合索引" class="headerlink" title="3.4 联合索引"></a>3.4 联合索引</h2><p>联合索引指的是对表上的多个列进行索引, 联合索引的创建方法也和单个索引相同, 唯一的不同之处在于有多个索引列. 底层结构也与普通索引基本相同, 不同之处在于联合索引的叶子节点中, key 是由多个值组成的, 并且 key 之间时按照多个列从左到右的顺序排序</p><p>联合索引能够解决相对复杂的查询逻辑, 同时对多个字段进行查询, 但其使用时必须遵循最左匹配原则.</p><p><img src="https://user-images.githubusercontent.com/17758731/63221796-be34cb00-c1d0-11e9-9478-11a90c6d4682.png" alt="image"></p><p>上图是对两个 int 列进行联合索引的示意图, 可以看到, 联合索引中 key 的顺序先按照列 a 排序, 列 a 相同再按照列 b 排序, 这样类似字典序的排序方式.</p><p>由于这种特性, 如果想使用某条联合索引, 筛选条件中列的顺序必须严格符合联合索引的最左匹配, 因为如果跳过了某一列, 索引就不再有序, 假设把上图中的列 a 去掉, 列 b 的索引就变成了 <code>[10, 15, 3, 5, 5]</code> 显然无法发挥索引的功能.</p><blockquote><p>假设现在有一条 a, b, c, d 列组成的联合索引, 那么能匹配该索引的查询语句为:<br>a -&gt; b -&gt; c -&gt; d<br>a -&gt; b -&gt; c<br>a -&gt; b<br>a</p></blockquote><h2 id="3-5-覆盖索引"><a href="#3-5-覆盖索引" class="headerlink" title="3.5 覆盖索引"></a>3.5 覆盖索引</h2><p>如果一条查询语句能够从辅助索引中获得全部需要的信息, 那么就不再需要回表, 我们就将这样的索引成为覆盖索引.</p><p>对于 InnoDB 的辅助索引而言, 叶子节点的 key 为参与索引的所有字段, value 为主键信息, 假设该索引的字段为k1, k2, 那么如下查询语句都可以使用覆盖所以, 免去回表操作.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> k1 <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> k2 = ?;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, k1 <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> k2 = ?;</span><br></pre></td></tr></table></figure><h2 id="3-6-索引的选择"><a href="#3-6-索引的选择" class="headerlink" title="3.6 索引的选择"></a>3.6 索引的选择</h2><p>由于一张表中可以存在多个索引(建议索引的数量不要超过 16 条), 但目前一条 SQL 语句只会选择一条索引去执行, 当 SQL 语句中没有明确规定走哪一条索引时, 就会由查询优化器来选择一条.</p><p>下面我们来聊一聊优化器是如何选择索引的.</p><p>查询优化器选择索引的目的, 是为了找到一个最优的方案, 最终以最小的代价去执行语句. 在绝大部分情况下, 查询优化器的行为都是符合预期的, 但既然查询优化器的行为也是由代码逻辑控制, 就可能在特定的情况下与预期不符.</p><p>先说说优化器选择的几个主要标准:</p><ol><li>扫描行数: 这是最直接的指标, 扫描行数越多就意味着访问磁盘的次数越多, 消耗的 CPU 越多;</li><li>是否需要回表</li><li>是否使用临时表;</li><li>是否排序;</li></ol><h3 id="3-6-1-扫描行数"><a href="#3-6-1-扫描行数" class="headerlink" title="3.6.1 扫描行数"></a>3.6.1 扫描行数</h3><p>首先需要明确一个概念, MySQL 在真正开始执行语句前, 无法准确知道满足条件的记录有多少条, 只能根据 <code>统计信息</code> 来估算记录数.</p><p>统计信息就是索引的区分度, 我们在建立索引时普遍会选择区分度更高, 也就是值的离散程度更高的列作为索引. 而一个索引上不同值的个数, 我们称之为 <code>基数</code>, 基数越大, 索引的区分度越高.</p><p>在 MySQL 中, 可以使用 <code>show index</code> 方法查看一个索引的基数.</p><p>而 MySQL 获取索引基数的方式是通过采样统计, 也就是说这里的 <code>cardinality</code> 列只是一个估算的值. 真正执行一遍 SQL 语句再统计虽然可以得到较为准确的值, 但是一旦表中数据过大, 这项统计工作就会变得异常耗时.</p><blockquote><p>在进行统计工作的时候, MySQL 会默认选择 N 个数据页, 统计这些页上不同的值, 得到这些页上的基数后, 得到一个平均值, 再乘以这个索引的数据页数, 就得到整条索引的基数. 而表的数据是会持续更新的, 因此索引的统计信息也不是一成不变的. 从上一次统计开始, 当整条索引上的数据行变更超过 1/M 的时候, 会自动触发重新进行一次索引统计.<br>MySQL 可以使用 <code>innodb_stats_persistent</code> 参数控制索引统计的行为  </p><ol><li>当设置为 on 的时候, 表示会将统计信息持久化存储, 此时默认 N 为 20, M 为 10.</li><li>当设置为 off 的时候, 表示统计信息只存储在内存中, 此时默认的 N 为 8, M 为 16.</li></ol></blockquote><p>我们可以看到当设置为 off 的时候, 统计采样的页数更少, 并且更新的更不活跃, 一般情况下设置为 on 会获得更好的统计效果. 但不论哪种采样方式, 与实际情况依然会存在一定偏差.</p><p>对 MySQL 的查询优化器来说, 大部分查询操作如果能通过主索引完成, 哪怕预计的扫描行数会更多, 也会优先选择主索引, 因为回表也是一种比较耗时的操作, 从辅助索引取出的没一行记录都需要再从主索引中找到整行记录在大部分情况下都会比直接走主索引更加耗时. 这一点, 在统计行数基本无误的情况下, 是没有问题的, 但假如统计行数出现了问题, 就可能会出现通过某一条辅助索引能很快定位, 优化器却选择了另一条扫描行数更多的索引.</p><p>而什么情况会导致 MySQL 对索引的采样统计出现偏差呢?</p><ol><li>最容易想到的就是索引记录进行了大量的修改, 却没有到达触发下次采样统计的行为时</li><li>在数据库短时间进行了大量的删除和插入语句时, 由于 MySQL 是使用标记删除来删除记录的,并不从索引和数据文件中真正的删除, 如果 delete 和 insert 中间的间隔相对较小,purge线程还没有来得及清理该记录. 如果主键相同的情况下, 新插入的insert会沿用之前删除的delete的记录的空间. 由于相同的近似的以及表大小,所以导致了统计信息没有变化</li></ol><p>遇到由于索引基数采样统计不准确而导致的索引选择问题, 可以通过重新统计索引信息的命令来处理:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ANALYZE</span> <span class="keyword">TABLE</span> t</span><br></pre></td></tr></table></figure><h3 id="3-6-2-是否会回表"><a href="#3-6-2-是否会回表" class="headerlink" title="3.6.2 是否会回表"></a>3.6.2 是否会回表</h3><p>回表也是一个相对耗时的操作, 对于一个满足覆盖索引的查询语句来说, 执行步骤通常是这样的:</p><ol><li>从辅助索引中找到第一条符合条件的记录, 并将其需要的字段放入结果集中</li><li>从辅助索引中找到下一条符合条件的记录, 并将其需要的字段放入结果集中</li><li>重复第 2 步, 直到辅助索引中下一条记录不再符合条件</li><li>向客户端返回</li></ol><p>而对于需要回表的查询语句, 执行步骤会变成:</p><ol><li>从辅助索引中找到第一条符合条件的记录</li><li>拿到其主键, 通过主索引找到整行记录, 并将其需要的字段防入结果集中</li><li>从辅助索引中找到吓一跳符合条件的记录</li><li>拿到其主键, 通过主索引找到整行记录, 并将其需要的字段放入结果集中</li><li>重复 3/4 步骤, 直到辅助索引中下一条记录不再符合条件</li></ol><p>不难看出, 一旦脱离覆盖索引, 最坏情况下辅助索引筛选出的每条记录都需要进行一次磁盘 IO, 这个代价是比较大的, 因此会出现如果一条查询语句同时通过主键和辅助索引筛选, 即便辅助索引扫描行数小于主键, 优化器也会选择使用主键</p><h3 id="3-6-3-是否需要排序"><a href="#3-6-3-是否需要排序" class="headerlink" title="3.6.3 是否需要排序"></a>3.6.3 是否需要排序</h3><p>排序的情况也和回表类似, 排序也是一个相对耗时的操作, 尤其是大数据量的排序, 如果无法直接在内存中完成, MySQL 会借助临时文件进行基于归并思想的外部排序. 在查询优化器的决策思路中, 也会尽量选择排序使用的索引而非前面筛选使用的索引.</p><p>假设我们的表 t 中有 a, b 两个字段, a 是主键, b 使用辅助索引, 我们向该表插入 100000 条记录, a, b 两列均从 1 开始递增, 现在执行查询语句:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> (a <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span>) <span class="keyword">AND</span> (b <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">100000</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>正常情况下, 查询优化器会得出索引 a 的扫描行数 ≈ 1000, 索引 b 的扫描行数 ≈ 50000 的结论, 但最终会选择 b 索引, 原因就在于 <code>ORDER BY</code> 语句, 会使得查询优化器更倾向于选择能够直接排序的索引, 选择 b 的好处是从该索引上获取的数据天然有序, 不必再去进行额外的排序操作.</p><p>我们来简单解释一下 MySQL 是如何执行 ORDER BY 语句的</p><blockquote><p>当我们对一条 SQL 语句执行 Explain 时, 如果 Extra 字段值为 <code>Using filesort</code> 就表示需要排序, MySQL 会给每个线程分配一块内存(sort_buffer)用于排序.<br>正常的排序语句执行过程:  </p><ol><li>初始化 sort_buffer, 并确定需要参与的字段(MySQL 的原则是内存足够的情况下尽量将 select 的全部字段放入, 否则排序完还需要回表)</li><li>从主索引(可能需要回表)取出整行, 再去 select 的字段存入 sort_buffer 中</li><li>从主索引再取一行记录进行相同操作, 直到不满足查询条件为止.</li><li>在 sort_buffer 中对 ORDER BY 字段进行快速排序</li><li>按照结果返回给客户端  </li></ol><p>这是一条 ORDER BY 语句最理想的执行情况, sort_buffer 大小大于需要排序的总数据量, 一旦 MySQL 发现内存放不下, 就需要借助磁盘临时文件辅助排序, MySQL 需要将总数据量分为 N 份, 每一份单独排序后存在这些临时文件中, 然后把这 N 有序文件再合并成一个有序的大文件. 这个 N 与排序的总数据量和 sort_buffer 大小有关.</p><p>此外, 如果 MySQL 认为单行数据量太大, 超过 <code>max_length_for_sort_data</code> 的值, 就会换成另外一种算法, 只在 sort_buffer 中对 ORDER BY 字段 + id 进行排序, 得到结果后再进行回表.</p></blockquote><p>因此在出现可能的排序场景时, 有如下优化措施:</p><ol><li>我们大部分情况下尽量让走排序字段的索引, 这样数据就天然有序, 不需要再额外进行排序操作.</li><li>也可以利用覆盖索引的特性, 尽可能不进行额外的回表操作</li><li>只 SELECT 必要的字段, 过多的字段可能会触发 MySQL 只对 ORDER BY 字段排序, 再利用 ID 回表.</li></ol><h3 id="3-6-4-如何选择正确的索引"><a href="#3-6-4-如何选择正确的索引" class="headerlink" title="3.6.4 如何选择正确的索引"></a>3.6.4 如何选择正确的索引</h3><p>在前面我们分析了查询优化器选择索引的原理, 也分析了几个查询优化器误选索引的场景, 现在来解决不同情况下误选索引的问题</p><ol><li>由于 MySQL 索引基数采样不准确引起的, 这类问题可以通过 <code>SHOW INDEX FROM t</code> 语句确定, 再通过 <code>ANALYZE TABLE t</code> 重新触发采样解决</li><li>由于回表/排序问题导致的误选索引, 在确定该语句绝大部分情况下都会误选的前提下(因为范围查询未必总会出现上述情况), 可以通过 <code>FORCE INDEX(idx_name)</code> 来强制使用某条索引.</li><li>此外对于排序问题, 还可以将其他的索引字段也加入 <code>ORDER BY</code> 子句中, 通过这样的方式让查询优化器明白, 无论选择哪条索引都无法避免排序, 从而强迫它放弃这一筛选条件, 如上述的 SQL 语句改成 <code>SELECT * FROM t WHERE (a BETWEEN 1 AND 1000) AND (b BETWEEN 50000 AND 100000) ORDER BY b, a limit 1;</code> 后, 查询优化器就会根据索引的扫描行数去决定.</li></ol><h2 id="3-7-索引没有生效的场景"><a href="#3-7-索引没有生效的场景" class="headerlink" title="3.7 索引没有生效的场景"></a>3.7 索引没有生效的场景</h2><p>上一节我们讨论了 MySQL 查询优化器选错索引的原因, 这节继续讨论设置了索引但是却意外的没有生效的场景</p><h3 id="3-7-1-条件字段做函数计算"><a href="#3-7-1-条件字段做函数计算" class="headerlink" title="3.7.1 条件字段做函数计算"></a>3.7.1 条件字段做函数计算</h3><p>假设表 t 中包含一个类型为 <code>datetime</code> 类型的字段 <code>create_time</code>, 并为该字段建立索引 <code>idx_create_time</code>, 如果查询语句为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> create_time = <span class="string">'2019-8-24'</span></span><br></pre></td></tr></table></figure><p>此时可以正常通过 <code>idx_create_time</code> 查询, 但是如果使用如下语句查询 <code>create_time</code> 字段月数为 8 的全部记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">MONTH</span>(create_time) = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>此时 MySQL 会直接执行全表扫描.</p><p>这样的执行方式并不符合我们的预期结果, 因为月份和日期一样, 都是有序的, 但此时为什么不能通过 <code>idx_create_time</code> 进行快速查找呢, 这需要从 InnoDB 索引查询记录的方式说起:</p><p><img src="https://user-images.githubusercontent.com/17758731/63633157-05f69f00-c676-11e9-831f-a785011ae7ca.png" alt="image"></p><p>之前我们提到过, B+ 树的本质是一棵多叉树, 通过在一个节点上尽可能多放节点来降低树的深度, 且 B+树一个节点内的数据是有序的, 查找的方式是从根节点开始, 找到目标记录出现的下层指针, 直到查询到叶子节点, 这样的查询必须依赖与每层跨界点有序, 不然在遍历当前层级的时候, 记录旧可能出现在多个叶子节点, 这样 B+树的查询就会失去意义. 在上图叶子节点的绿色数据中, 我列出了每个 k 的 MONTH() 函数值, 显然并不满足同一层级跨节点有序. 因此 InnoDB 无法通过这样的一条索引去完成 MONTH() 查询.</p><p>但是优化器并不是完全放弃使用这个索引, 优化器可以选择遍历主键索引, 也可以选择遍历 <code>idx_create_time</code>, 这需要优化器按照查询计划分别计算出两种方式预计的耗时.</p><p>对于会改变有序性的函数, 优化器的决定毋庸置疑, 但对于本身就不会改变有序性的函数来说, 优化器由于场景比较复杂, 依然直接采用放弃索引的方式规避麻烦.</p><h3 id="3-7-2-隐式类型转换"><a href="#3-7-2-隐式类型转换" class="headerlink" title="3.7.2 隐式类型转换"></a>3.7.2 隐式类型转换</h3><p>假设表 t 有字段 uid, 类型为 varchar(64), 当执行如下 SQL 语句时, 会直接走全表扫描:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> uid = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>原因是查询语句发生了隐式的类型转换, MySQL 的类型转换规则是如果字符型和数字做比较的话, 会将字符型转换成数字.</p><p>因此上面的 SQL 语句实际被优化器转换为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">CAST</span>(uid <span class="keyword">AS</span> signed <span class="built_in">int</span>) = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>隐式类型转换的问题本质上还是由于 <code>对索引字段做函数操作, 优化器会放弃走索引树的搜索功能, 触发主索引或辅助索引的全表扫描</code></p><h1 id="4-MySQL-锁"><a href="#4-MySQL-锁" class="headerlink" title="4. MySQL 锁"></a>4. MySQL 锁</h1><p>锁是一个用于管理对共享资源并发访问的数据结构.</p><p>对于写操作, InnoDB 会在行记录上加锁, 使用 lock 功能的对象是事务, 锁定的对象是数据库存储中的对象, 包括表, 页, 行. 并且一般锁会在事务 commit 或 rollback 后释放.</p><p>InnoDB 实现了两种标准的锁:</p><ol><li>共享锁(S 锁), 允许事务读一行数据, 与其他 S 锁兼容, 与 X 锁不兼容</li><li>排他锁(X 锁), 允许事务删除或更新一行数据, 与其他 S 锁或 X 锁均不兼容</li></ol><h2 id="4-1-锁的分类"><a href="#4-1-锁的分类" class="headerlink" title="4.1 锁的分类"></a>4.1 锁的分类</h2><p>根据加锁的范围, MySQL 中的锁大致可以分为全局锁, 表级锁和行级锁.</p><h3 id="4-1-1-全局锁"><a href="#4-1-1-全局锁" class="headerlink" title="4.1.1 全局锁"></a>4.1.1 全局锁</h3><p>全局锁会对整个数据库实例加锁.</p><p><code>Flush Tables With Read Lock (FTWRL)</code>, 可以让整个数据库全局加读锁, 处于只读状态, 所有更新 DDL, DML 和写事务的提交均会被阻塞.</p><p>一般用来做全库逻辑备份, 备份过程中整个库处于只读状态. 如果不加锁备份得到的库不是同一个逻辑时间点.</p><p>MySQL 自带的备份工具 <code>mysqldump</code>, 当使用 <code>-single-transaction</code> 时, 执行 dump 前会启动一个事务来获取一致性视图, MVCC 可以保证其他写操作正常.</p><h3 id="4-1-2-表级锁"><a href="#4-1-2-表级锁" class="headerlink" title="4.1.2 表级锁"></a>4.1.2 表级锁</h3><ol><li>表锁 <code>lock tables t read/write</code>, 限制接下来所有线程的读/写</li><li>元数据锁(metadata lock), 访问时会被自动加上, 保证读写操作的正确性. 防止事务 A 读期间事务 B 对表结构做修改. 普通的增删改查 DML 会对元数据加 S 锁, DDL 操作会对元数据加 X 锁.</li></ol><p>如果安全的执行 ALTER TABLE:</p><ol><li>解决长事务, 可以通过 information_schema 库的 innodb_trx 表查看执行中的事务.</li><li>读写频繁, 由于对元数据的修改会阻塞其后的所有事务, 可以给 ALTER TABLE 设定超时时间, 超时后扔拿不到锁就会直接放弃.</li></ol><h3 id="4-1-3-InnoDB-行锁的实现"><a href="#4-1-3-InnoDB-行锁的实现" class="headerlink" title="4.1.3 InnoDB 行锁的实现"></a>4.1.3 InnoDB 行锁的实现</h3><p>InnoDB 实现了 3 种行锁的算法, 分别是:</p><ol><li>记录锁: 单个记录上的锁, 总是会去锁住索引记录.</li><li>间隙锁: 锁定一个范围, 但不包含记录本身</li><li>临键锁: 实现的方式是记录锁+间隙锁, 锁定一个范围, 并且锁定记录本身.</li></ol><p>在 InnoDB 事务中, 行锁是在需要的时候才加上的, 但并不是不需要就立即释放, 需要等事务结束后再统一释放.</p><p>行锁在 InnoDB 中是基于索引实现的, 因此一旦某个加锁操作没有使用索引, 那么该锁就会退化为表锁.</p><h4 id="4-1-3-1-记录锁-Record-Locks"><a href="#4-1-3-1-记录锁-Record-Locks" class="headerlink" title="4.1.3.1 记录锁(Record Locks)"></a>4.1.3.1 记录锁(Record Locks)</h4><p>为某行记录加锁, 会封锁该行 的索引记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列必须为主键或唯一索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> grade = <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在使用 <code>SELECT FOR UPDATE</code> 和 <code>UPDATE</code> 时, id 为 1 的记录行会被锁住, 但锁住的索引必须是主索引或者唯一索引, 否则加的锁就是临键锁, 同时, 查询语句必须为精确匹配, 不能为 <code>&lt;</code>, <code>&gt;</code> 或 <code>LIKE</code>, <code>BETWEEN</code> 等, 否则也只会加临键锁</p><h4 id="4-1-3-2-间隙锁-Gap-Locks"><a href="#4-1-3-2-间隙锁-Gap-Locks" class="headerlink" title="4.1.3.2 间隙锁(Gap Locks)"></a>4.1.3.2 间隙锁(Gap Locks)</h4><p>间隙锁作用域普通索引(非主索引或唯一索引), 间隙锁锁住的是一个区间, 而不仅仅是这个区间中的每一条记录.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> grade = grade + <span class="number">10</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>即所有在(10, 20)区间范围内的行记录都会被锁住, 即 id 为 <code>11, 12, 13, 14</code> 的记录. 但 10 和 15 两条记录不会被锁住.</p><h4 id="4-1-3-3-临键锁"><a href="#4-1-3-3-临键锁" class="headerlink" title="4.1.3.3 临键锁"></a>4.1.3.3 临键锁</h4><p>可以理解为特殊的间隙锁. 每个数据行上的普通索引列都会存在一把临键锁, 当某个事务持有该行的临键锁时, 会锁住一段 <code>左开右闭区间</code> 的数据, InnoDB 中的行锁是基于索引实现, 临键锁只与普通索引有关, 在主索引和唯一键索引上不存在临键锁.</p><p>假设有如下数据表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span> primary <span class="keyword">key</span>,</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="keyword">index</span>(age),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>内容如下:</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">age</th><th style="text-align:center">name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">10</td><td style="text-align:center">Lee</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">24</td><td style="text-align:center">soraka</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">32</td><td style="text-align:center">Zed</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">45</td><td style="text-align:center">Talon</td></tr></tbody></table><p>此时, age 索引上潜在的临键锁有:</p><ul><li><code>(-∞, 10]</code></li><li><code>(10, 24]</code></li><li><code>(24, 32]</code></li><li><code>(32, 45]</code></li><li><code>(45, +∞)</code></li></ul><p>此时进行如下操作:</p><table><thead><tr><th>时刻</th><th>事务 A</th><th>事务 B</th><th>情况</th></tr></thead><tbody><tr><td>t1</td><td><code>SELECT * FROM t WHERE id BETWEEN 10 AND 24 FOR UPDATE</code></td><td>无</td><td>获得间隙锁</td></tr><tr><td>t2</td><td>无</td><td><code>INSERT INTO t(age, name) VALUES(15, &#39;Tom&#39;)</code></td><td>插入操作被阻塞</td></tr></tbody></table><p>使用这样的方式保证事务执行期间不会出现幻读.</p><h3 id="4-1-4-解决幻读"><a href="#4-1-4-解决幻读" class="headerlink" title="4.1.4 解决幻读"></a>4.1.4 解决幻读</h3><p>大部分数据库都是通过最高事务隔离级别 <code>SERIALIZABLE</code> 去解决幻读问题, 但 InnoDB 不同, 它是通过 MVCC 和临键锁, 在 <code>REPEATABLE READ</code> 隔离级别下避免幻读. 我们下面就来解释一下原因</p><blockquote><p>幻读: 在同一事务下, 连续执行两次 SQL 语句可能导致不同的结果, 第二次 SQL 语句可能会返回之前不存在的行或者没有返回之前存在的行, 即无法感知当前事务执行期间其他事务的 INSERT 或 DELETE 操作.</p></blockquote><p>假设有如下表记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>), (<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>当我们执行如下查询语句时:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>InnoDB 的加锁顺序是这样的:</p><ol><li>字段 d 没有索引, 只能通过主索引全表扫描, 将主索引上全部记录加行锁</li><li>将主索引上全部 <code>间隙</code> 加锁</li></ol><table><thead><tr><th>时刻</th><th>tx-a</th><th>tx-b</th><th>tx-c</th></tr></thead><tbody><tr><td>t1</td><td><code>select * from t where d=5 for update;</code></td><td></td><td></td></tr><tr><td>t2</td><td></td><td><code>update t set d=5 where id=0;</code></td><td></td><td></td></tr><tr><td>t3</td><td><code>select * from t where d=5 for update</code></td><td></td><td></td></tr><tr><td>t4</td><td></td><td></td><td><code>update t set d=5 where id=0;</code></td></tr><tr><td>t5</td><td><code>select * from t where d=5 for update</code></td><td></td></tr></tbody></table><p>如果只对 id=5 这一行加锁, 而其他行不加锁的话, 那么在事务 a 中, 三次 select 语句执行的结果均不相同. 这种情况就被成为幻读, 一个事务在前后两次查询同一个范围时, 第二次查询到了前一次没有看到的行.</p><p>幻读带来的问题:</p><ol><li>破坏语义: T1 时刻事务 a 想做的事情是 <code>把所有 d=5 的行锁住, 不准别的事务进行读写操作</code>, 但幻读显然破坏了这样的语义</li><li>数据一致: 假设在事务 a 执行范围修改后, 提交前其他事务插入了符合 a 修改条件的记录, 并直接提交, 那么事务 a 提交后的 BinLog(STATEMENT 模式) 中涉及的修改就会包含其他事务添加的行.</li></ol><p>幻读问题的根源在于即使把所有记录都加锁, 依然无法阻止新纪录的插入, 因此为了解决幻读, InnoDB 引入了间隙锁, 用于锁住两个值之前的空隙. 例如初始化后的表 t 有 6 条记录, 就会产生 7 个间隙:</p><pre><code>(-∞, 0) (0, 5) (5, 10) (10, 15) (15, 20) (25, +∞)</code></pre><p>当执行 <code>SELECT * FROM t WHERE d=5 FOR UPDATE;</code> 时, 由于 d 字段没有索引, 不止会给已有的 6 条记录加上行锁, 还同时给 7 个间隙全部加上间隙锁, 这样就保证无法再插入新的数据.</p><p>在 InnoDB 中, 数据行是可以加锁的实体, 数据行之间的间隙也是. 但间隙锁不像行锁会分为读锁和写锁, 与间隙锁存在冲突的是 <code>向这个间隙中插入记录</code> 这个操作, 不同间隙锁之间不存在冲突关系.</p><h1 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h1><p>事务是数据库系统区别于文件系统的重要特性之一, 在文件系统中, 如果在写文件的时候进程退出, 这个文件就很有可能被损坏. 还有在顺序写入多个文件的场景, 如果执行到中间某个状态时进程退出, 就会产生复杂的中间状态.</p><p>数据库引入了事务, 就是希望能够安全的将数据库从一种一致状态转换到另一种一致的状态上来, 当数据库提交工作时, 可以确保要么所有的修改都已经成功保存, 要么所有的修改都被废弃. 而保证这些功能的关键就在于满足 ACID 特性.</p><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>A(Atomicity) 原子性</td><td>原子性需要保证一系列的更新操作要么全部执行成功, 要么全部被废弃</td></tr><tr><td>C(Consisteny) 一致性</td><td>事务将数据库从一种抑制状态转变为下一种一致的状态, 在事务的开始和结束前后, 数据库的完整性约束没有被破坏</td></tr><tr><td>I(Isolation) 隔离性</td><td>隔离性保证每个读写事务的对象对其他事务的操作独享能相互分离, 即该事务提交前对其他事务都不可见</td></tr><tr><td>D(Durability) 持久性</td><td>事务一旦提交, 其结果就是持久性的, 即使发生宕机等事故, 数据库也能将数据恢复.</td></tr></tbody></table><h2 id="5-1-隔离级别"><a href="#5-1-隔离级别" class="headerlink" title="5.1 隔离级别"></a>5.1 隔离级别</h2><p>当数据库上有多个事务同时执行的时候, 可能出现脏读, 不可重复读, 幻读等问题, 为了解决这些问题, 就有了隔离级别的概念.</p><blockquote><p>在理解隔离级别的时候, 我们可以先想象机场的安检级别, 在机场中, 由于客流量较大, 并且安全问题非常重要, 因此通常会使用不同安检预案来应对不同的情况. 在常规情况下, 安检级别可能不高, 此时安检项目不多, 吞吐量较高; 但如果有国家政要等情况, 安检级别就会相对升高, 甚至当机场受到了恐怖威胁可能安检级别会更高.<br>总之安检级别越高, 相对吞吐量就会降低, 但可以保证更高的安全性.</p></blockquote><p>隔离级别也是同理, 是由 SQL92 标准定义的一套预案, 各个数据库自己来实现, 实际使用场景中, 需要由开发人员根据实际业务特点来灵活选择. 目前提供的标准事务隔离级别主要包括:</p><table><thead><tr><th style="text-align:center">隔离级别</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">读未提交</td><td>一个事务还没有提交时, 它做的变更就能被别的事务看到</td></tr><tr><td style="text-align:center">读已提交</td><td>一个事务提交后, 它的变更才能被其他事物看到</td></tr><tr><td style="text-align:center">可重复读</td><td>一个事务执行过程中看到的数据, 总是跟这个事务在启动过程中看到的数据是一致的.</td></tr><tr><td style="text-align:center">可串行化</td><td>对于同一行记录, 写加 X 锁, 读加 S 锁, 当读写冲突的时候, 后访问的事务必须等前一个事务执行完成才能继续执行.</td></tr></tbody></table><p>读未提交的实现方式比较简单, 写操作在完成之前就能被看到说明读写可以同时对一个事务加锁, 目前绝大部分数据库的默认隔离级别都不会是读未提交, 并且在绝大多数场景中都不能使用读未提交.</p><p>目前 InnoDB 的默认隔离级别是可重复读, Oracle 的默认隔离级别是读已提交.</p><h3 id="5-1-2-事务隔离级别的实现"><a href="#5-1-2-事务隔离级别的实现" class="headerlink" title="5.1.2 事务隔离级别的实现"></a>5.1.2 事务隔离级别的实现</h3><p>在 InnoDB 中, 每条记录在更新的时候都会同时记录一条回滚操作. 记录上的最新值通过回滚操作介意得到前一个状态的值. 假设一个值从 1 被依次改为 2, 3, 4, 在回滚段中会有类似记录:</p><p><img src="https://user-images.githubusercontent.com/17758731/63634553-a9ea4580-c68a-11e9-8cbf-91a37a340f7e.png" alt="image"></p><p>当前的值为 4, 但是在查询这条记录时, 不同时刻启动的事务会有不同的 ReadView(视图), 同一条记录可以存在多个版本, 这就是数据库的多版本并发控制(Multi-Version-Concurrency-Control, MVCC), 对于在该条记录为值为 1 时启动的事务, 会使用 ReadView-A 去查询该记录, 查询的原理是通过从最新值开始, 依次向前比较直到找到提交时间早于该事物启动时间的第一条记录, 然后返回.</p><p>回滚段的删除比较特殊, 需要等到整个系统中没有比这个回滚段更早的 ReadView 时, 才可以删除, 因为 InnoDB 不能确定哪些 ReadView 会访问这条数据, 只有等真正执行的时候才知道.</p><p>在可重复读隔离级别下, 事务启动时会同时启动一份快照, 这个快照是基于整个数据库的. 但它不是真的对整个数据库做一次备份.</p><blockquote><p>InnoDB 中每个事务都有一个唯一的事务 ID, 叫做 txId, 当事务启动时统一分配并且严格递增. 每条记录也有多个版本, 每次更新都会创建一个新的版本, 并且记录修改的 txId 作为 row rx-id. 同时旧的数据版本就放在回滚段中.<br>但是记录的多个版本只是逻辑上的概念, InnoDB 并不是真的存储数据, 存储的是能够将数据恢复到上一个版本的 <code>undo log</code>.<br>对于可重复读, 一个事务启动的时候, 能够看到所以已经提交的事务结果, 也就是该事物只能看到每条记录所有已提交的 <code>row tx_id</code> 小于自己 tx_id 的版本. InnoDB 为每个事务构造了一个数组, 用来保存这个事务启动时未提交的事务 id. 对于该事物, 通过 <code>未提交事务列表中最小值</code> 和 <code>当前数据库最大事务 id + 1</code> 两个值将当前时刻的全部事务分为三部分:</p></blockquote><ol><li>已创建, 并且确定提交的事务</li><li>已创建, 但需要进一步确认是否提交的事务</li><li>还未创建的事务</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/63651541-4a725f80-c788-11e9-9ac2-074d49378798.png" alt="image"></p><p>此时, 对数据库中全部记录的 row tx_id 来说, 分为四种类型:</p><ol><li>蓝色部分: 由已创建且已提交的事务生成, 可见</li><li>绿色部分:<ol><li>在当前事务 <code>未提交事务列表</code> 中, 代表由已创建但未提交的事务生成, 不可见</li><li>不在当前事务 <code>未提交事务列表</code> 中, 代表由已创建且已提交的事务生成, 可见</li></ol></li><li>黄色部分: 由未来启动的事务生成的, 不可见</li></ol><p>InnoDB 利用 redo log 实现了 MVCC, 再利用 MVCC 实现秒级创建快照的能力.</p><p>而读已提交和可重复读的实现都利用了快照, 不同之处在于:</p><ol><li>读已提交级别下, 每一条语句执行前都会重新计算出一个快照</li><li>可重复读级别下, 只在事务创建时计算一次快照, 之后事务里的其他查询都共用这一个视图.</li></ol><p>可序列化隔离级别, 不需要视图以及其他额外的特性, 每条记录都按照 S 锁和 X 锁的定义依次执行即可.</p><h2 id="5-2-事务的实现"><a href="#5-2-事务的实现" class="headerlink" title="5.2 事务的实现"></a>5.2 事务的实现</h2><p>事务的隔离性由锁来实现, 原子性和持久性由 redo log 实现, 一致性由 undo log 实现. redo log 用来恢复提交事务修改的页操作, undo log 用来将行记录回滚到某个特定版本.</p><h3 id="5-2-1-Redo-log"><a href="#5-2-1-Redo-log" class="headerlink" title="5.2.1 Redo log"></a>5.2.1 Redo log</h3><p>我们先想象一个最直接的 UPDATE 语句执行方式:</p><ol><li>根据索引从磁盘中读出记录所在的数据页</li><li>在内存中修改数据页对应的值</li><li>将数据页刷新回磁盘</li></ol><p>在不考虑性能的前提下, 这是完成一条更新操作最直观的方式.</p><p>但往往越直观的方式, 性能越差. UPDATE 操作是一个典型的随机写, 对于机械硬盘来说, 一次随机写平均花费 10ms, 并且一个事务中可能存在多条写操作, 在保证其能执行成功的同时还要保证原子性, 由此可见这并不是一个理想的方案.</p><p>InnoDB 引入了 WAL 思想, 其关键在于先写日志, 再写磁盘, 当有一条记录需要更新的时候, InnoDB 就会先把记录写到 RedoLog 中, 并更新内存, 此时更新操作就完成了. InnoDB 会在 <code>适当</code> 的时候, 将这个操作记录更新到磁盘中, 这样的更新都是在系统相对比较空闲的时候.</p><p><img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" alt="image"></p><p>这里借用极客时间的图来说明 RedoLog 的实现方式, 磁盘中的 RedoLog 是固定大小的(并不像 BinLog 可以在磁盘空间未满的情况下无限追加), 写入的方式类似环形队列, <code>write pos</code> 是当前记录的位置, 一边写一边后移, <code>checkpoint</code> 是当前需要擦除的位置, 也是往后推移并且循环, 擦除记录前要把记录更新到数据文件. 假设我们为 RedoLog 文件定义两个操作:</p><ul><li>push: 向 RedoLog 文件写入数据, 并增加 <code>write pos</code>, 当事务执行写操作触发</li><li>pop: 从 RedoLog 中删除数据, 并增加 <code>check point</code>, 当该事务的更新操作落盘时触发, 代表该条 RedoLog 不再需要.</li></ul><p>RedoLog 的写入机制:</p><blockquote><p>事务在执行的时候, 生成的 RedoLog 会先写入 RedoLog Buffer, 当事务提交时再统一持久化到磁盘.</p></blockquote><p>我们先从一条更新 SQL 语句的执行过程来体会 RedoLog 的功能.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> grade = grade + <span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>执行过程如下:</p><p><img src="https://user-images.githubusercontent.com/17758731/63781356-365f6700-c91c-11e9-9bb7-6f2d7b8534f9.png" alt="image"></p><p>需要着重解释的几个点:</p><h4 id="5-2-1-1-BinLog-和-RedoLog-能否相互替代"><a href="#5-2-1-1-BinLog-和-RedoLog-能否相互替代" class="headerlink" title="5.2.1.1 BinLog 和 RedoLog 能否相互替代"></a>5.2.1.1 BinLog 和 RedoLog 能否相互替代</h4><p>答案是不能, 首先 BinLog 是 MySQL Server 层提供的功能, 旨在提供数据恢复, 集群同步等功能; RedoLog 是 InnoDB 独有的概念, 用来实现事务的原子性和持久性. 简单来说二者的设计方向不同, BinLog 在磁盘空间足够的前提下可以无限增加, 用来复现某个时间点之后的全部写操作. RedoLog 文件在磁盘中大小固定, 循环队列的结构会使得较早的日志被清理掉.</p><ul><li>BinLog 功能: 保证数据库能够从某个时间点正确恢复以及主从一直.</li><li>RedoLog 功能: 保证事务原子性和持久性, RedoLog 落盘后数据库即使宕机重启更新依然不丢.</li></ul><h4 id="5-2-1-2-为什么-RedoLog-需要先-Prepare"><a href="#5-2-1-2-为什么-RedoLog-需要先-Prepare" class="headerlink" title="5.2.1.2 为什么 RedoLog 需要先 Prepare"></a>5.2.1.2 为什么 RedoLog 需要先 Prepare</h4><p>答案是为了保证 RedoLog 和 BinLog 的一致性.</p><p>我们可以做一个假设, 如果不使用两阶段提交, 分别提交 BinLog 和 RedoLog 看看会出现什么情况.</p><table><thead><tr><th>场景</th><th>问题</th></tr></thead><tbody><tr><td>先提交 BinLog, 提交 RedoLog 前数据库宕机</td><td>此时 BinLog 落盘成功, 从库可以拉取到该 BinLog, 会将该更新在自己身上提交, 主库恢复后无法复现该事务, 此时主从不一致. 此外, 主库如果从某个时刻想通过 BinLog 恢复到当前状态, 恢复出来的时候就会多出一个事务, 该记录的值与原库值不同.</td></tr><tr><td>先提交 RedoLog, 提交 BinLog 时数据库宕机</td><td>此时 RedoLog 落盘成功, 即使数据库宕机, 主库恢复后依然可以复现. 但由于 BinLog 没有写入成功, 此时如果用这个 BinLog 来恢复临时库或者主从同步, 恢复出来的行记录就会少一条事务, 依然与原库值不同</td></tr></tbody></table><p>因此我们可以看到, RedoLog 影响宕机重启后的事务重新执行, BinLog 影响可能需要的恢复和主从同步, 要想一致就必须使用两阶段提交.</p><h4 id="5-2-1-3-两阶段提交如何保证-RedoLog-与-BinLog-一致"><a href="#5-2-1-3-两阶段提交如何保证-RedoLog-与-BinLog-一致" class="headerlink" title="5.2.1.3 两阶段提交如何保证 RedoLog 与 BinLog 一致"></a>5.2.1.3 两阶段提交如何保证 RedoLog 与 BinLog 一致</h4><p>RedoLog 的两阶段提交一共分为三步:</p><ol><li>写入 RedoLog, 处于 Prepare 状态</li><li>写入 BinLog</li><li>提交事务, 处于 commit 状态</li></ol><p>问题可能出现在步骤 1 后和步骤 2 后, 我们分情况来讨论下:</p><ol><li>写入 Prepare 状态的 RedoLog 后 MySQL 宕机: 此时 BinLog 没有写入, RedoLog 也没有提交, 此时可以当做事务提交失败.</li><li>写入 BinLog 后 MySQL 宕机: 崩溃恢复的规则如下:<ol><li>如果 RedoLog 中事务是完整的, 也就是有了 commit 标识, 则可以直接提交;</li><li>如果 RedoLog 中事务只有完整的 Prepare, 则判断对应事务的 BinLog 是否完整, BinLog 如果完整就可以提交事务, 否则回滚.</li></ol></li></ol><p>对于 MySQL 来说, 每个事务的 BinLog 都有完整的格式, 通过识别该格式就可以判断事务额 BinLog 是否完整.</p><p>此外, BinLog 和 RedoLog 都有一个共同的字段 <code>XID</code>, 在崩溃恢复的时候会按顺序扫描 RedoLog:</p><ul><li>如果碰到既有 Prepare 又有 commit 的 RedoLog, 就直接提交;</li><li>如果碰到只有 Prepare 但没有 commit 的 RedoLog, 就需要通过 TXID 去 BinLog 中查询, 再通过 BinLog 是否完整决定提交或回滚.</li></ul><h3 id="5-2-2-回滚日志-UndoLog"><a href="#5-2-2-回滚日志-UndoLog" class="headerlink" title="5.2.2 回滚日志 UndoLog"></a>5.2.2 回滚日志 UndoLog</h3><p>RedoLog 记录了事务的行为, 可以通过其对数据页进行重做. 但事务如果需要进行回滚, 就需要 UndoLog. 当事务执行失败或者显式执行 ROLLBACK 的时候, 就可以利用 UndoLog 将数据回滚到某个特定的版本.</p><p>UndoLog 存放在数据库内部的回滚段中, UndoLog 本身不是快照, 只是逻辑地将数据库恢复到原来的样子, 比如某个字段自增, UndoLog 中就会记录将该字段 -1 可以得到上一个版本</p><h3 id="5-2-3-组提交"><a href="#5-2-3-组提交" class="headerlink" title="5.2.3 组提交"></a>5.2.3 组提交</h3><p>我们通常给 <code>sync_binlog</code> 和 <code>innodb_flush_log_at_trx_commit</code> 都会设置为 1, 也就是说一个完整的事务提交前, 需要进行两次 fsync 操作, 依次是 RedoLog(prepare), 另一次是 BinLog. 然而磁盘的 fsync 性能是有限的, 甚至磁盘 fsync 的速度很大程度上限制了数据库的 TPS 上限, 为了提高磁盘 fsync 的效率, MySQL 提供了 group commit 的功能, 即一次 fsync 可以刷新确保多个事务日志被写入文件.</p><p>事务提交时, 会进行两个阶段的操作:</p><ol><li>修改内存中事务对应的信息, 并且将日志写入 RedoLog Buffer</li><li>调用 fsync 将确保日志都从 RedoLog Buffer 写入磁盘</li></ol><p>步骤 2 的耗时远大于步骤 1, 此时我们就可以当某个事务进行步骤 2 的时候, 让其他事务先执行步骤 1, 这样就可以将多个事务的重做日志通过一次 fsync 刷新到磁盘, 这样可以减轻磁盘的压力.</p><p>MySQL 甚至提供了把 RedoLog 做 fsync 时间拖到步骤 1 之后的功能:</p><ul><li>binlog_group_commit_sync_delay 参数, 表示延迟多少微秒后才调用 fsync;</li><li>binlog_group_commit_sync_no_delay_count 参数, 表示累计多少次以后才调用 fsync</li></ul><p>因此 WAL 机制主要能带来两方面提升:</p><ol><li>RedoLog 和 BinLog 都是顺序写, 速率远大于随机写.</li><li>组提交机制, 大幅降低磁盘的 IOPS 消耗.</li></ol><h1 id="6-集群与高可用"><a href="#6-集群与高可用" class="headerlink" title="6. 集群与高可用"></a>6. 集群与高可用</h1><h2 id="6-1-通过-BinLog-保证主备一致"><a href="#6-1-通过-BinLog-保证主备一致" class="headerlink" title="6.1 通过 BinLog 保证主备一致"></a>6.1 通过 BinLog 保证主备一致</h2><p>在 MySQL 的高可用场景中, 最简单和常用的就是主备复制, 客户端的读写都直接访问主库, 而备库只负责将主库的更新同步到本地执行, 当主库出现问题的时候, 可以将主库下线, 并将备库立即提升为主库.</p><p>MySQL 是通过 BinLog 的同步完成主备的数据同步功能的.</p><p>在主备同步时, 备库与主库维持了一个长连接, 主库有一个单独的线程用于处理备库的长连接, 日志的同步过程如下:</p><ol><li>备库通过 <code>change master</code> 命令指定主库的 ip, 端口, 用户名, 密码以及请求 BinLog 的文件名和日志偏移量;</li><li>备库通过 <code>start slave</code> 命令启动两个线程: 负责与主库建立连接的 <code>io_thread</code> 和 负责复现数据的 <code>sql_thread</code>;</li><li>主库建立连接后, 会按照备库传来的位置从本地读取 BinLog 发给备库;</li><li>备库拿到 BinLog 后, 写入到本地文件, 成为中转日志(relay log);</li><li>sql_thread 读取中转日志, 解析出日志中的命令并执行.</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/64351234-8a5d0080-d02c-11e9-9a54-2b59ec14a68e.png" alt="image"></p><h2 id="6-2-主从延迟的来源"><a href="#6-2-主从延迟的来源" class="headerlink" title="6.2 主从延迟的来源"></a>6.2 主从延迟的来源</h2><p>在主从复制中, 主要由三步构成:</p><ol><li>主库提交事务, 写入 BinLog;</li><li>从库获得 BinLog, 放入 RelayLog;</li><li>备库执行完成.</li></ol><p>在备库上可以执行 <code>show salve status</code> 命令, 返回结果中有 <code>seconds_behind_master</code>, 用于表示当前备库延迟多少秒, MySQL 会统计BinLog 中主库记录的时间域当前系统时间的差值.</p><p>在正常情况下, BinLog 传给备库的延迟很低, 主备延迟的主要来源是备库接收完 BinLog 和提交事务的时间. 本质上说, 是从库消费中转日志(RelayLog) 的速度比主库生产 BinLog 的速度要慢.</p><p>产生这种情况的原因:</p><ol><li>很多情况下从库性能低于主库</li><li>备库除了同步数据, 还需要处理其他请求</li><li>主库频繁执行大事务</li><li>备库的并行复制能力.</li></ol><p>主备切换的时候, 正常情况下应该采用可靠性优先策略:</p><ol><li>判断从库当前的 <code>second_behind_master</code>, 如果大于某个值(如 5s), 则等待并重试, 这一步是为了尽可能在从库压力不大的时候进行.</li><li>如果小于某阈值, 把主库改成只读状态;</li><li>循环判断从库的 <code>second_behind_master</code> 直到为 0, 代表主库所有内容都已经同步到从库中;</li><li>把从库改为可写状态;</li><li>把业务请求转移到从库.</li></ol><p>这种方案下, 在步骤 3~5 期间整个数据库系统对外不可写.</p><p>MySQL 的高可用是依赖于主从延迟的, 延迟时间越小在故障转移的时候服务恢复需要的时间就越短.</p><p>在某些短暂的大事务或者备份时, 对备库延迟的影响可能会到达分钟级, 但通常备库是可以跟上进度的, 但如果备库同步的是一个持续压力较高的主库, 延迟可能达到小时级甚至永远追不上来.</p><p>究其原因就是大部分情况下从库消费中转日志的速度都会低于主库处理写操作的能力.</p><ul><li>在主库上, 影响并发度最主要的因素就是锁, InnoDB 支持行锁, 因此除了大量并发事务更新同一行的极端情况, 大部分情况下并发度都不低.</li><li>但是备库在执行的时候, 不论是单线程还是多线程, 都有一定的局限性, 导致理论上执行的速度会低于主库写操作.</li></ul><p>在 MySQL 5.6 之前, 从库采用单线程复制, 因此速度低于主库比较好理解. 但后续版本 MySQL 开始采用多线程复制之后问题依然没有得到很好的解决:</p><p><img src="https://user-images.githubusercontent.com/17758731/64469708-5cc9a180-d169-11e9-8add-a6ec8a6c8cce.png" alt="image"></p><p>中转日志中的全部记录, 首先由 <code>Coordinator</code> 读取, 然后分发给不同的 worker 负责执行.</p><blockquote><p>主库的写操作是由客户端触发的, 在从库中, 想要把主库写操作完整的复现出来, 并不能简单的让 <code>Coordinator</code> 随机分给不同 <code>Worker</code>, 这中间存在一定的限制. 比如对同一条记录的两个写操作, 如果分给了两个 Worker, 由于 CPU 的调度策略不可控, 很可能会出现第二个写早于第一个完成这样会直接导致主备不一致.<br>此外, 同一个事务分别更新了两张表, 如果放在两个 worker 中, 在其中一个 worker 完成而另一个没有完成时, 主备会出现短暂的不一致.</p></blockquote><p>因此, 多线程消费 RelayLog 的时候, 需要保证如下行为:</p><ol><li>不能出现覆盖更新, 因此对同一个行的两个事务必须由同一个 worker 顺序执行</li><li>一个事务的所有操作都需要由同一个 worker 顺序执行</li></ol><h2 id="6-3-并行复制策略"><a href="#6-3-并行复制策略" class="headerlink" title="6.3 并行复制策略"></a>6.3 并行复制策略</h2><h3 id="MySQL-5-5"><a href="#MySQL-5-5" class="headerlink" title="MySQL 5.5"></a>MySQL 5.5</h3><p>在 MySQL 5.5 的时候, 由于官方没有提供并行复制的策略, 因此 <code>《MySQL 实战 45 讲》作者林晓斌</code> 自己实现了并行复制策略: </p><h4 id="按表分发"><a href="#按表分发" class="headerlink" title="按表分发"></a>按表分发</h4><p>如果两个事务更新的是不同的表, 就可以交给不同的 worker 完成, 按表分发可以保证两个 worker 不会冲突. 但如果有跨表的事务, 还是需要放在一起</p><p><img src="https://user-images.githubusercontent.com/17758731/64469953-bfbd3780-d16d-11e9-87b3-5715034596bd.png" alt="image"></p><p>上述方案中, 在每个 worker 中维护了一个 HashTable, key 是 <code>库名.表名</code>, value 是该 worker 当前有多少个事务正在执行. 当有事务分配给该 worker 时, 涉及的表会加到 HashTable 中, 执行完成后再去掉.</p><p>每个事务在分发的时候, 跟所有的 worker 冲突关系包括三种情况:</p><ol><li>和所有的 worker 都不冲突, coordinator 会分配给最空闲的 worker;</li><li>只和一个 worker 冲突, coordinator 必须分配给该 worker;</li><li>和多个 worker 冲突, coordinator 进入等待状态, 直到和这个事务存在冲突的 worker 只剩一个, 分配给该 worker</li></ol><p>该方案在不同表之间负载均匀的场景中效果最好. 但如果出现热点表, 那么大量事务就会被集中分配给某个 worker, 退化为单线程复制.</p><h4 id="按行分发"><a href="#按行分发" class="headerlink" title="按行分发"></a>按行分发</h4><p>该方案用来解决热点表并行复制的问题: 如果两个事务没有更新相同的行, 那么在备库上可以并行执行, 按行复制的前提是 BinLog 格式为 row. (否则无法知道具体更新的行) 此时判断是否冲突的标准是是否修改了同一行记录.</p><p>此时 worker 上的 HashTable 的 key 就变成了 <code>库名+表名+主键+所有唯一键</code> 因为涉及唯一键的更新也可能存在冲突, 比如主库中 r1 让出了某个唯一键的值, r2 将唯一键更新为 r1 的值, 如果在备库中交给两个 worker 执行, 可能顺序会被打乱, 就存在问题.</p><p>按行分发的并发度更高, 但是也更消耗内存和 CPU 资源, 因为每一行记录都会作为 HashTable 的一个 key.</p><h3 id="MySQL-5-6"><a href="#MySQL-5-6" class="headerlink" title="MySQL 5.6"></a>MySQL 5.6</h3><p>MySQL 官方开始支持并行复制, 但粒度只有库, 从实现上说就是以库名作为 HashTable 的 key.</p><p>如果MySQL 实例上的各个库负载均匀就会起到一定作用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MySQL-体系架构&quot;&gt;&lt;a href=&quot;#1-MySQL-体系架构&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL 体系架构&quot;&gt;&lt;/a&gt;1. MySQL 体系架构&lt;/h1&gt;&lt;p&gt;MySQL 的架构整体上可以分为服务层和引擎层:&lt;/p&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://destinywang.github.io/blog/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://destinywang.github.io/blog/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何高效使用Vim</title>
    <link href="https://destinywang.github.io/blog/2019/06/19/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8Vim/"/>
    <id>https://destinywang.github.io/blog/2019/06/19/如何高效使用Vim/</id>
    <published>2019-06-19T14:18:17.000Z</published>
    <updated>2019-06-22T13:25:06.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h1 id="2-基本使用方式"><a href="#2-基本使用方式" class="headerlink" title="2. 基本使用方式"></a>2. 基本使用方式</h1><h2 id="2-1-vim-的模式"><a href="#2-1-vim-的模式" class="headerlink" title="2.1 vim 的模式"></a>2.1 vim 的模式</h2><p>当我们使用 <code>vim</code>, 或在后面加文件名的时候, 就可以进入 vim 的界面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Desktop</span><br><span class="line">$ vim demo.txt</span><br></pre></td></tr></table></figure><p>该命令就会在 ~/Desktop 路径下打开(如果有)或编辑(如果没有) <code>demo.txt</code> 文件</p><p>最初进入 vim 时是普通模式, vim 的特点之一就是可以通过不同的操作快速进入多种模式:</p><ul><li>普通模式: 进入 vim 默认的模式, 该模式有非常多的快捷键组合, 无法进行输入, 如果想编辑, 需要进入写入模式.</li><li>写入模式: 由命令模式进入, 最简单的方式通过在普通模式下输入小写 <code>i</code> 来完成(后面会介绍更多的方式), 进入写入模式后, 终端的左下角会出现 <code>-- INSERT --</code> 标志, 该模式下字母, 数字, 字符键都可以正常完成输入功能, 写入模式可以通过 <code>esc</code> 退出并回到普通模式.</li><li>命令模式: 所有的 vim 指令都需要进入由普通模式输入 <code>:</code> 进入命令模式完成, 常见的指令包括保存(w), 退出(q)等</li></ul><p>此外, 普通模式进入写入模式除了 <code>i</code> 之外, 还有其他几种方式, 不同方式之间的区别在于进入插入模式时光标的位置:</p><table><thead><tr><th style="text-align:center">输入</th><th style="text-align:center">全称</th><th style="text-align:center">光标的位置</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">insert</td><td style="text-align:center">与普通模式相同</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">append</td><td style="text-align:center">普通模式光标的下一个字符</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center"></td><td style="text-align:center">普通模式光标所在行的结尾</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center"></td><td style="text-align:center">普通模式光标所在行的下一行开出一个新行, 并把光标移动到新行的行首</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center"></td><td style="text-align:center">普通模式光标所在行的上一行开出一个新行, 并把光标移动到新行的行首</td></tr></tbody></table><h2 id="2-2-vim-光标移动"><a href="#2-2-vim-光标移动" class="headerlink" title="2.2 vim 光标移动"></a>2.2 vim 光标移动</h2><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">h</td><td style="text-align:center">光标向左</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">光标向下</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">光标向上</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">光标向右</td></tr></tbody></table><h1 id="3-vim-配置文件"><a href="#3-vim-配置文件" class="headerlink" title="3. vim 配置文件"></a>3. vim 配置文件</h1><p>vim 配置文件可以修改 vim 界面的外观, 组合按键等</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment"># 新建一个 .vim 文件夹</span></span><br><span class="line">$ mkdir .vim</span><br><span class="line">$ <span class="built_in">cd</span> .vim</span><br><span class="line"><span class="comment"># 新建一个 vimrc 文件</span></span><br><span class="line">$ vim vimrc</span><br></pre></td></tr></table></figure><p>开始进行配置:</p><pre><code>noremap 是一个更改键位的命令e.g. noremap a b当该配置生效后, 如果用户按下 a 键之后, vim 就会认为按的是 b</code></pre><p>我们需要替换的键位<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map s &lt;nop&gt;     <span class="comment"># 禁用 s 键</span></span><br><span class="line">map S :w&lt;CR&gt;    <span class="comment"># 用 S 替换 vim 中的 `:+w+回车` 的保存功能</span></span><br><span class="line">map Q :q&lt;CR&gt;    <span class="comment"># 用 Q 替换 vim 中的 `:+q+回车` 的退出功能</span></span><br><span class="line">map R :<span class="built_in">source</span> <span class="variable">$MYVIMRC</span>&lt;CR&gt; <span class="comment"># 用 R 键替换 source 当前 vimrc 文件</span></span><br></pre></td></tr></table></figure></p><h2 id="3-1-配置-vim-的编辑器"><a href="#3-1-配置-vim-的编辑器" class="headerlink" title="3.1 配置 vim 的编辑器"></a>3.1 配置 vim 的编辑器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syntax on       <span class="comment"># 开启语法高亮</span></span><br><span class="line"><span class="built_in">set</span> nu          <span class="comment"># 开启行号</span></span><br></pre></td></tr></table></figure><h3 id="3-1-1-set-relativenumber-开启真实行号"><a href="#3-1-1-set-relativenumber-开启真实行号" class="headerlink" title="3.1.1 set relativenumber 开启真实行号"></a>3.1.1 set relativenumber 开启真实行号</h3><p>该配置生效之后, 行号会分两列展示, 第一列用于展示真正的行号, 第二列用于展示其他行相对当前行的距离</p><p><img src="https://user-images.githubusercontent.com/17758731/59780134-1db74d00-92ec-11e9-8132-b0faf511498b.png" alt="image"></p><h3 id="3-1-2-set-cursorline-开启当前行高亮线"><a href="#3-1-2-set-cursorline-开启当前行高亮线" class="headerlink" title="3.1.2 set cursorline 开启当前行高亮线"></a>3.1.2 set cursorline 开启当前行高亮线</h3><p><img src="https://user-images.githubusercontent.com/17758731/59780278-5a834400-92ec-11e9-9b6b-92e9657ce20d.png" alt="image"></p><h3 id="3-1-3-set-wrap-开启自动换行"><a href="#3-1-3-set-wrap-开启自动换行" class="headerlink" title="3.1.3 set wrap 开启自动换行"></a>3.1.3 set wrap 开启自动换行</h3><h3 id="3-1-4-set-showcmd-右下角显示执行的命令"><a href="#3-1-4-set-showcmd-右下角显示执行的命令" class="headerlink" title="3.1.4 set showcmd 右下角显示执行的命令"></a>3.1.4 set showcmd 右下角显示执行的命令</h3><h3 id="3-1-5-set-wildmenu-命令模式下的提示"><a href="#3-1-5-set-wildmenu-命令模式下的提示" class="headerlink" title="3.1.5 set wildmenu 命令模式下的提示"></a>3.1.5 set wildmenu 命令模式下的提示</h3><p>使用 <code>:</code> 进入命令模式, 输入 so 时, 敲 tab 会给出提示: <code>sort</code> 和 <code>source</code></p><p><img src="https://user-images.githubusercontent.com/17758731/59780689-fa40d200-92ec-11e9-96f5-da33eb7cf952.png" alt="image"></p><h2 id="3-2-vim-的编辑操作"><a href="#3-2-vim-的编辑操作" class="headerlink" title="3.2 vim 的编辑操作"></a>3.2 vim 的编辑操作</h2><p>vim 下的编辑操作通常由 <code>操作</code> 和 <code>动作</code> 组成</p><h3 id="3-2-1-常见操作"><a href="#3-2-1-常见操作" class="headerlink" title="3.2.1 常见操作"></a>3.2.1 常见操作</h3><h4 id="3-2-1-1-删除"><a href="#3-2-1-1-删除" class="headerlink" title="3.2.1.1 删除"></a>3.2.1.1 删除</h4><p>假设有如下内容, 我们需要删除中间的空格, 有如下几种方式</p><pre><code>&lt;optration&gt; &lt;motion&gt;</code></pre><p>总的来说, 编辑指令的语法类似于动宾短语, 操作一般是动词, 如复制, 删除等, 动作一般为宾语, 代表执行操作的字符.</p><p>下面来分别介绍一下常见的操作和动作</p><ol><li>在普通模式下将光标移动到空格后的 <code>&lt;</code> 然后输入 <code>x</code> 将光标的前一个字符删除.</li><li>在普通模式下输入 <code>d</code>, <code>d</code> 代表 delete, 提供了多种选项:<ol><li><code>d</code> + <code>←</code>(方向键左), 代表向左删除一个字符</li><li><code>d</code> + <code>3</code> + <code>→</code>(方向键右), 代表向右删除三个字符</li><li><code>d</code> + <code>d</code>, 代表对整行执行删除操作(实际上大多数操作都遵循双击代表针对行的规律)</li></ol></li></ol><h4 id="3-2-1-2-粘贴"><a href="#3-2-1-2-粘贴" class="headerlink" title="3.2.1.2 粘贴"></a>3.2.1.2 粘贴</h4><p><code>p</code>, 代表 paste, 可以用来粘贴被复制或剪切的字符</p><h4 id="3-2-1-4-复制"><a href="#3-2-1-4-复制" class="headerlink" title="3.2.1.4 复制"></a>3.2.1.4 复制</h4><p><code>y</code>, 代表 copy, 可以用来复制选中的字符</p><blockquote><ol><li><code>y</code> + <code>→</code>, 代表向右复制一个字符</li><li><code>y</code> + <code>3</code> + <code>→</code>, 代表向右复制三个字符</li></ol></blockquote><h4 id="3-2-1-5-改变-c"><a href="#3-2-1-5-改变-c" class="headerlink" title="3.2.1.5 改变(c)"></a>3.2.1.5 改变(c)</h4><p><code>c</code>, 代表 change, 与 <code>d</code> 操作相似, 不同的是完成了删除操作之后, 会自动进入编辑模式</p><blockquote><ol><li><code>c</code> + <code>→</code> + <code>6</code>, 代表删除光标右边的 6 个字符, 并进入编辑模式</li></ol></blockquote><h3 id="3-2-2-常见动作"><a href="#3-2-2-常见动作" class="headerlink" title="3.2.2 常见动作"></a>3.2.2 常见动作</h3><p>最常见的动作就是上下左右, 除此之外还有一些快捷动作.</p><h4 id="3-2-2-1-移动到下个单词-w"><a href="#3-2-2-1-移动到下个单词-w" class="headerlink" title="3.2.2.1 移动到下个单词(w)"></a>3.2.2.1 移动到下个单词(w)</h4><p>假设有如下字符</p><pre><code>I am Happy Today.^</code></pre><p>此时光标在 I 上, 如果在普通模式下按 <code>w</code>, 光标会移动到 <code>am</code> 的首字母 <code>a</code>, 以此类推, 每次都会让光标移动到下一个单词的首字母</p><p>假设我们想将上例中的 <code>Happy</code> 修改为 <code>excited</code>, 可以进行如下操作:</p><blockquote><p>将光标移动到 <code>Happy</code> 的首字母 h, 然后使用 <code>c</code> + <code>w</code>, 就可以将该词删除, 并且进入编辑模式, 然后输入 excited 即可.</p></blockquote><h4 id="3-2-2-2-移动到当前单词的首字母-b"><a href="#3-2-2-2-移动到当前单词的首字母-b" class="headerlink" title="3.2.2.2 移动到当前单词的首字母(b)"></a>3.2.2.2 移动到当前单词的首字母(b)</h4><p><code>b</code>, 代表 back, 可以将光标移动到当前单词的首字母位置</p><p>同样, 通过该动作就可以在 happy 的任意一个字符快速移动到首字母, 并完成删除操作</p><h4 id="3-2-2-3-范围-i"><a href="#3-2-2-3-范围-i" class="headerlink" title="3.2.2.3 范围(i)"></a>3.2.2.3 范围(i)</h4><p><code>i</code>, 代表 in, 表示选中在某个范围内的全部字符</p><blockquote><ol><li><code>c</code> + <code>i</code> + <code>w</code> 表示将当前光标所在单词范围内的全部字符替换  </li><li><code>y</code> + <code>i</code> + <code>w</code> 表示将当前光标所在单词范围内的全部字符复制</li><li><code>c</code> + <code>i</code> + <code>&quot;</code> 表示将当前光标所在引号范围的全部字符替换</li></ol></blockquote><h4 id="3-2-2-4-查找-f"><a href="#3-2-2-4-查找-f" class="headerlink" title="3.2.2.4 查找 (f)"></a>3.2.2.4 查找 (f)</h4><p><code>f</code>, 代表 find, 会将光标移动到第一个相同的字符</p><blockquote><ol><li><code>f</code> + <code>v</code>, 代表将光标向后移动到第一个 v 所在的位置s</li><li><code>d</code> + <code>f</code> + <code>:</code>, 代表 <code>删除+寻找+:</code> 从光标所在字符开始, 一直删除到其后的第一个 <code>:</code></li></ol></blockquote><h1 id="4-搜索"><a href="#4-搜索" class="headerlink" title="4 搜索"></a>4 搜索</h1><h2 id="4-1-搜索方式"><a href="#4-1-搜索方式" class="headerlink" title="4.1 搜索方式"></a>4.1 搜索方式</h2><p>vim 下的搜索主要分为两种方式:</p><ol><li>从上向下搜索(快捷键 <code>/</code>)</li><li>从下向上搜索(快捷键 <code>?</code>)</li></ol><p>两种操作的相同之处都是会以光标作为查询的起点, 向上/向下进行搜索</p><p>将搜索内容高亮的设置:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hlsearch        # 将搜索结果高亮</span><br><span class="line"><span class="keyword">set</span> incsearch       # 将搜索内容即时高亮</span><br><span class="line"><span class="keyword">set</span> ignorecase      # 忽略大小写</span><br><span class="line"><span class="keyword">set</span> smartcase       # 开启智能拼写</span><br><span class="line">exec <span class="string">"nohlsearch"</span>   # 搜索结果的高亮会在下次进入 <span class="keyword">vim</span> 是继续保留, 因此可以先执行该命令清除</span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;LEADER&gt;</span><span class="symbol">&lt;CR&gt;</span> :<span class="keyword">nohlsearch</span><span class="symbol">&lt;CR&gt;</span>    # 执行完搜索之后, 高亮会一直保留, 比较影响视线, 因此使用 `LEADER`(默认为 \ 键) + 回车执行 <span class="keyword">nohlsearch</span> 命令, 取消高亮</span><br></pre></td></tr></table></figure><p>在 vim 的搜索模式下, 模式使用 <code>n</code> 进行下一项的搜索, <code>N</code> 进行上一项的搜索, 可以配合 <code>zz</code> (将光标所在行移动到屏幕中间)</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">noremap</span> n nzz</span><br><span class="line"><span class="keyword">noremap</span> <span class="keyword">N</span> Nzz</span><br></pre></td></tr></table></figure><h1 id="5-美化-vim-界面"><a href="#5-美化-vim-界面" class="headerlink" title="5 美化 vim 界面"></a>5 美化 vim 界面</h1><h2 id="5-1-使用自带美化方案"><a href="#5-1-使用自带美化方案" class="headerlink" title="5.1 使用自带美化方案"></a>5.1 使用自带美化方案</h2><p>方式是在命令模式下输入 <code>color</code> + <code>空格</code> + <code>tab</code> 键, 接下来就会提示可以用的美化方案</p><p><img src="https://user-images.githubusercontent.com/17758731/59963846-5133ea80-952b-11e9-892f-82dcfca165ec.png" alt="image"></p><h2 id="5-2-自定义美化方案"><a href="#5-2-自定义美化方案" class="headerlink" title="5.2 自定义美化方案"></a>5.2 自定义美化方案</h2><p>但如果系统自带的美化方案不能满足需求, 就可以下载其他美化方案</p><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim 插件管理</a></p><h3 id="5-2-1-下载"><a href="#5-2-1-下载" class="headerlink" title="5.2.1 下载"></a>5.2.1 下载</h3><p>使用下面的命令进行下载<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/<span class="built_in">autoload</span>/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure></p><h3 id="5-2-2-安装插件"><a href="#5-2-2-安装插件" class="headerlink" title="5.2.2 安装插件"></a>5.2.2 安装插件</h3><p>在 <code>~/.vimrc</code> 中, 以下文开头</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br></pre></td></tr></table></figure><p>然后安装的语法格式为:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">''</span>     # 引号内为想装的插件</span><br></pre></td></tr></table></figure><p>最后使用下文结束安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure><p>将 <code>~/.vimrc</code> source 之后, <code>:</code> 进入命令模式, 输入 PlugInstall 命令开始安装指定插件</p><p><img src="https://user-images.githubusercontent.com/17758731/59964057-11bacd80-952e-11e9-98c9-93129ba662d7.png" alt="image"></p><h3 id="5-2-3-推荐的插件"><a href="#5-2-3-推荐的插件" class="headerlink" title="5.2.3 推荐的插件"></a>5.2.3 推荐的插件</h3><h4 id="5-2-3-1-vim-airline"><a href="#5-2-3-1-vim-airline" class="headerlink" title="5.2.3.1 vim-airline"></a>5.2.3.1 vim-airline</h4><p>会在 vim 底部展示状态栏</p><p><img src="https://user-images.githubusercontent.com/17758731/59964076-66f6df00-952e-11e9-82ea-553f6be1517b.png" alt="image"></p><p>包括文件路径, 编码格式以及进度条等.</p><h4 id="5-2-3-2-connorholyday-vim-snazzy"><a href="#5-2-3-2-connorholyday-vim-snazzy" class="headerlink" title="5.2.3.2 connorholyday/vim-snazzy"></a>5.2.3.2 connorholyday/vim-snazzy</h4><p>加入 <code>connorholyday/vim-snazzy</code> 并 PlugInstall 之后, 在配置文件之后再添加如下配置</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">colorscheme</span> snazzy</span><br></pre></td></tr></table></figure><p>最后 source 即可生效, 效果如图</p><p><img src="https://user-images.githubusercontent.com/17758731/59964448-644ab880-9533-11e9-8806-5ed12e3695e7.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;h1 id=&quot;2-基本使用方式&quot;&gt;&lt;a href=&quot;#2-基本使用方式&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hadoop基础</title>
    <link href="https://destinywang.github.io/blog/2019/04/21/Hadoop%E5%9F%BA%E7%A1%80/"/>
    <id>https://destinywang.github.io/blog/2019/04/21/Hadoop基础/</id>
    <published>2019-04-21T02:45:06.000Z</published>
    <updated>2019-07-27T01:55:57.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h1 id="2-Hadoop-安装"><a href="#2-Hadoop-安装" class="headerlink" title="2. Hadoop 安装"></a>2. Hadoop 安装</h1><h2 id="2-1-JDK-安装配置"><a href="#2-1-JDK-安装配置" class="headerlink" title="2.1 JDK 安装配置"></a>2.1 JDK 安装配置</h2><p>可以在 Oracle 官网或者直接使用 wget 命令下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header <span class="string">"Cookie: oraclelicense=accept-securebackup-cookie"</span> http://download.oracle.com/otn-pub/java/jdk/8u65-b17/jdk-8u65-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>使用 <code>tar -zxvf</code> 完成解压</p><p><img src="https://user-images.githubusercontent.com/17758731/56851599-89f87e80-6943-11e9-8b32-2453360ffef9.png" alt="image"></p><p>再将路径 (<code>/usr/soft/jdk1.8.0_65</code>) 配置到 <code>etc/enviroment</code> 路径下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 给 path 新增 JDK 的 bin 路径</span><br><span class="line">PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/soft/jdk1.8.0_65/bin&quot;</span><br><span class="line"></span><br><span class="line"># jdk 路径</span><br><span class="line">JAVA_HOME=/usr/soft/jdk1.8.0_65</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/56851719-ef993a80-6944-11e9-93ab-bc181fe1c5ee.png" alt="image"></p><p>经此验证, 已经成功安装并配置 JDK</p><h2 id="2-2-Hadoop-安装配置"><a href="#2-2-Hadoop-安装配置" class="headerlink" title="2.2 Hadoop 安装配置"></a>2.2 Hadoop 安装配置</h2><p>在 Apache 官网下载压缩包并解压:</p><p><img src="https://user-images.githubusercontent.com/17758731/56866098-2b490880-6a08-11e9-8e16-29f651ccc7a3.png" alt="image"></p><p>在 <code>/etc/enviroment</code> 文件中配置环境变量</p><pre><code>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/soft/jdk1.8.0_65/bin:/usr/soft/hadoop-2.7.7/bin:/usr/soft/hadoop-2.7.7/sbin&quot;JAVA_HOME=/usr/soft/jdk1.8.0_65HADOOP_INSTALL=/usr/soft/hadoop-2.7.7</code></pre><p>在输入 <code>hadoop version</code> 即可看到输出:</p><pre><code>destiny@destiny-Parallels-Virtual-Platform:/etc$ hadoop versionHadoop 2.7.7Subversion Unknown -r c1aad84bd27cd79c3d1a7dd58202a8c3ee1ed3acCompiled by stevel on 2018-07-18T22:47ZCompiled with protoc 2.5.0From source with checksum 792e15d20b12c74bd6f19a1fb886490This command was run using /usr/soft/hadoop-2.7.7/share/hadoop/common/hadoop-common-2.7.7.jardestiny@destiny-Parallels-Virtual-Platform:/etc$ </code></pre><p><img src="https://user-images.githubusercontent.com/17758731/56866210-4c5e2900-6a09-11e9-8587-949e514572eb.png" alt="image"></p><h1 id="3-Hadoop-配置"><a href="#3-Hadoop-配置" class="headerlink" title="3. Hadoop 配置"></a>3. Hadoop 配置</h1><p>Hadoop 的配置都是 XML 文件的方式完成, 通用配置都在 <code>core-site.xml</code> 中, HDFS, MapReduce 和 YARN 都有对应的 <code>hdfs-site.xml</code>, <code>mapred-site.xml</code> 以及 <code>yarn-site.xml</code>.</p><p>Hadoop 的设计的目的在于处理海量数据, 其主要内容包括数据的存储以及运算, 存储使用 HDFS 实现, 运算使用 MapReduce 编程模型实现.</p><p>Hadoop 有三种配置方式:</p><ol><li>独立模式: 没有守护程序, 所有程序都运行在一个单独的 JVM 之上, 独立模式适合在开发期间运行 MapReduce 程序, 方便调试和测试.</li><li>伪分布式: Hadoop 守护程序运行在本地机器上, 会模拟一个小规模的集群.</li><li>完全分布式: 运行在集群的不同机器上.</li></ol><p>当需要运行某个模式的 Hadoop 时, 需要设置适当的配置, 以及启动守护进程(独立模式除外), 不同模式见的配置如下:</p><table><thead><tr><th style="text-align:center">配置文件</th><th style="text-align:center">属性</th><th style="text-align:center">独立模式值</th><th style="text-align:center">伪分布式值</th><th style="text-align:center">完全分布式值</th></tr></thead><tbody><tr><td style="text-align:center">core</td><td style="text-align:center">fs.defaultFS</td><td style="text-align:center">file:///(默认值)</td><td style="text-align:center">hdfs://localhost/</td><td style="text-align:center">hdfs://namenode</td></tr><tr><td style="text-align:center">HDFS</td><td style="text-align:center">dfs.replication</td><td style="text-align:center">N/A</td><td style="text-align:center">1</td><td style="text-align:center">3(默认值)</td></tr><tr><td style="text-align:center">MapReduce</td><td style="text-align:center">mapreduce.framework.name</td><td style="text-align:center">local(默认值)</td><td style="text-align:center">yarn</td><td style="text-align:center">yarn</td></tr><tr><td style="text-align:center">yarn</td><td style="text-align:center">yarn.resourcemanager.hostname<br>yarn.nodemanager.aux-services</td><td style="text-align:center">N/A<br>N/A</td><td style="text-align:center">localhost <br> mapreduce_shuffle</td><td style="text-align:center">resourcemanager <br> mapreduce_shuffle</td></tr></tbody></table><p>此外, Hadoop 的不同配置模式见可以共存, 只需用不同的目录存放配置文件即可, 启动的时候可以通过如下两种方式来指定配置文件:</p><ol><li>设置 <code>HADOOP_CONF_DIR</code> 环境变量</li><li>通过 <code>--config</code> 选项来指定</li></ol><h2 id="3-1-独立模式"><a href="#3-1-独立模式" class="headerlink" title="3.1 独立模式"></a>3.1 独立模式</h2><p>在独立模式下不需要进行额外的配置, 所有默认的属性都是针对独立模式的, 也没有守护程序运行, 独立模式下使用的文件系统是 <code>Local File System</code> 和 <code>Local MR job runner</code>.</p><p><img src="https://user-images.githubusercontent.com/17758731/56866418-6d277e00-6a0b-11e9-9e87-832ec82a11f6.png" alt="image"></p><p>可以看到, 独立模式下使用 <code>hadoop fs -ls</code> 显示的就是本机的根路径文件</p><h2 id="3-2-伪分布式"><a href="#3-2-伪分布式" class="headerlink" title="3.2 伪分布式"></a>3.2 伪分布式</h2><h3 id="3-2-1-配置文件"><a href="#3-2-1-配置文件" class="headerlink" title="3.2.1 配置文件"></a>3.2.1 配置文件</h3><p>在伪分布式环境下, 需要配置如下文件:</p><ol><li><p>core-site.xml(核心站点)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- yarn 是一个 MapReduce 框架, 2.0 版本以上开始引入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>初始状态下, 这些配置文件中都是空值, 需要根据使用者的自身情况去配置以完成不同环境的搭建.</p><p><img src="https://user-images.githubusercontent.com/17758731/56905677-3cab1700-6ad3-11e9-93bf-b7274eca76ca.png" alt="image"></p><p>我们将 <code>$HADOOP_INSTALL/etc/hadoop</code> 文件夹拷贝一份, 用作伪分布式的配置</p><p><img src="https://user-images.githubusercontent.com/17758731/56906117-2baed580-6ad4-11e9-98b3-f0b1a8b24d94.png" alt="image"></p><p>然后依次将上文提到的四个配置文件修改成指定的配置方式</p><h3 id="3-2-2-配置-SSH"><a href="#3-2-2-配置-SSH" class="headerlink" title="3.2.2 配置 SSH"></a>3.2.2 配置 SSH</h3><p>在伪分布式下, 必须要启动守护进程, 启动守护进程就需要使用提供的启动脚本, Hadoop 并不严格区分伪分布式和完全分布式, 只是在目标主机上启动守护进程, 通过 SSH 命令让主机之间相互通信, 而且要启动守护进程. </p><p>伪分布式只是完全分布式的一个特例, 是一个在单个主机上运行 Hadoop 完全分布式的场景, 因此我们需要确保能够通过 SSH 命令登录本机, 而不需要通过输入密码.</p><p>在 ubuntu 上可以通过 <code>sudo apt-get install ssh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ssh                  <span class="comment"># 安装 ssh</span></span><br><span class="line">$ ssh-keygen -t rsa -P <span class="string">''</span> -f ~/.ssh/id_rsa  <span class="comment"># 生成公钥和私钥, -P '' 代表指定密码为空</span></span><br><span class="line">$ cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  <span class="comment"># 将公钥配置给 authorized_keys, 用来实现免密登陆</span></span><br><span class="line">$ ssh localhost                             <span class="comment"># 第一次yes</span></span><br><span class="line">$ yes</span><br><span class="line">$ ssh localhost                             <span class="comment"># 第二次不需要口令</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/56973756-0f786a80-6ba0-11e9-852e-47688237b2be.png" alt="image"></p><h3 id="3-2-3-使用-HDFS"><a href="#3-2-3-使用-HDFS" class="headerlink" title="3.2.3 使用 HDFS"></a>3.2.3 使用 HDFS</h3><p>首先需要对文件系统进行格式化</p><pre><code>hdfs namenode -format</code></pre><p>然后就可以启动守护进程</p><h4 id="3-2-3-1-启动"><a href="#3-2-3-1-启动" class="headerlink" title="3.2.3.1 启动"></a>3.2.3.1 启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">start-dfs.sh --config <span class="variable">$HADOOP_INSTALL</span>/etc/hadoop_pseudo</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/56974348-426f2e00-6ba1-11e9-9de9-8927285be487.png" alt="image"></p><h4 id="3-2-3-2-启动-yarn"><a href="#3-2-3-2-启动-yarn" class="headerlink" title="3.2.3.2 启动 yarn"></a>3.2.3.2 启动 yarn</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">start-yarn.sh --config <span class="variable">$HADOOP_INSTALL</span>/etc/hadoop_pseudo</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/56974786-1a33ff00-6ba2-11e9-9575-a52c554de287.png" alt="image"></p><p>此时可以通过 jps 查看:</p><p><img src="https://user-images.githubusercontent.com/17758731/56975718-f83b7c00-6ba3-11e9-8880-1c968d4d8dbd.png" alt="image"></p><ul><li>其中 ResourceManager 和 NodeManager 由 Yarn 提供</li><li>NameNode, DataNode, SecondaryNameNode 由 HDFS 提供</li></ul><p>可以使用如下命令停止 Hadoop<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop-yarn.sh</span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure></p><p>通过设置环境变量, 可以不再需要借助 –config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/usr/soft/hadoop-2.7.7/etc/hadoop_pseudo</span><br></pre></td></tr></table></figure><p>此时再使用 <code>hadoop fs -ls /</code> 就已经没有结果显示</p><p>我们可以像使用 Linux 系统类似的命令去操作 HDFS, 下图展示一个创建文件夹的操作</p><p><img src="https://user-images.githubusercontent.com/17758731/56976335-50bf4900-6ba5-11e9-9f11-61b04f473601.png" alt="image"></p><h2 id="3-3-完全分布式"><a href="#3-3-完全分布式" class="headerlink" title="3.3 完全分布式"></a>3.3 完全分布式</h2><h3 id="3-3-1-准备工作"><a href="#3-3-1-准备工作" class="headerlink" title="3.3.1 准备工作"></a>3.3.1 准备工作</h3><ol><li><p>在 /etc/passwd 修改登录提示消息</p></li><li><p>在 /etc/hostname 中修改主机名</p></li></ol><p>可以通过软连接的方式指定 Hadoop 配置文件</p><p><img src="https://user-images.githubusercontent.com/17758731/57002668-999dee80-6bf3-11e9-8fcc-bd41e67e0788.png" alt="image"></p><p>将现在的 ubuntu 虚拟机克隆出三份, 具体配置如下:</p><p><img src="https://user-images.githubusercontent.com/17758731/57017238-d6e49980-6c50-11e9-9aeb-cc3f98d4fd16.png" alt="image"></p><ol><li>左边标出本人当前的四台节点 ip</li><li><p>将 ip 和编号分别写在当前节点(s1) 的 <code>/etc/hosts</code> 文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.211.55.33 s0</span><br><span class="line">10.211.55.34 s1</span><br><span class="line">10.211.55.35 s2</span><br><span class="line">10.211.55.36 s3</span><br></pre></td></tr></table></figure></li><li><p>此时测试, s0, s1, s2, s3 均可以被 ping 通</p></li><li>现在需要将 hosts 分别同步(覆盖)给到 s1, s2, s3 节点</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/57017640-91c16700-6c52-11e9-8584-be7726f0d5cc.png" alt="image"></p><p>Hadoop 集群架构分析</p><p><img src="https://user-images.githubusercontent.com/17758731/57052874-aafefd80-6cbc-11e9-8d86-0ee8a6022d28.png" alt="image"></p><h3 id="3-3-2-集群模式配置"><a href="#3-3-2-集群模式配置" class="headerlink" title="3.3.2 集群模式配置"></a>3.3.2 集群模式配置</h3><p>预期部署的网络拓扑图: </p><p><img src="https://user-images.githubusercontent.com/17758731/57019091-021eb700-6c58-11e9-903b-4aa941551f75.png" alt="image"></p><table><thead><tr><th>节点名</th><th>功能</th></tr></thead><tbody><tr><td>s0</td><td>名称节点</td></tr><tr><td>s1</td><td>数据节点</td></tr><tr><td>s2</td><td>数据节点</td></tr><tr><td>s3</td><td>辅助名称节点</td></tr></tbody></table><blockquote><p>下面我们从 s0 开始进行配置, 在完成 s0 的配置后, Hadoop 运行时需要所有节点的配置相同, 因此类似于 hosts 文件, 我们需要将配置好的文件覆盖到其他节点.</p></blockquote><h4 id="3-3-2-1-core-site-xml"><a href="#3-3-2-1-core-site-xml" class="headerlink" title="3.3.2.1 core-site.xml"></a>3.3.2.1 core-site.xml</h4><p>core-site.xml 用来配置 NameNode 所运行的节点 ip</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://s0/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-2-hdfs-site-xml"><a href="#3-3-2-2-hdfs-site-xml" class="headerlink" title="3.3.2.2 hdfs-site.xml"></a>3.3.2.2 hdfs-site.xml</h4><p>hdfs-site.xml 用来配置 HDFS 的副本数量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-4-yarn-site-xml"><a href="#3-3-2-4-yarn-site-xml" class="headerlink" title="3.3.2.4 yarn-site.xml"></a>3.3.2.4 yarn-site.xml</h4><p>yarn-site.xml 用来配置 yarn 的资源管理节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>s0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-5-slaves"><a href="#3-3-2-5-slaves" class="headerlink" title="3.3.2.5 slaves"></a>3.3.2.5 slaves</h4><p>通过该文件配置从节点(DataNode) 的 ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1</span><br><span class="line">s2</span><br></pre></td></tr></table></figure><p>最后再将整个 <code>hadoop_cluster</code> 文件夹覆盖到其他节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -r hadoop_cluster root@s1:/usr/soft/hadoop-2.7.7/etc/</span><br><span class="line">sudo scp -r hadoop_cluster root@s2:/usr/soft/hadoop-2.7.7/etc/</span><br><span class="line">sudo scp -r hadoop_cluster root@s3:/usr/soft/hadoop-2.7.7/etc/</span><br></pre></td></tr></table></figure><p>使用 <code>start-all.sh</code> 完成 hdfs 和 yarn 的启动:</p><p><img src="https://user-images.githubusercontent.com/17758731/57019992-9be76380-6c5a-11e9-8048-d55108068731.png" alt="image"></p><p>我们可以对启动日志做一个简单的解读:</p><ul><li>在 s0 节点上启动名称节点</li><li>分别在 s1 和 s2 启动数据节点</li><li>启动辅助名称节点</li><li>启动 yarn 守护进程</li><li>分别在 s1 和 s2 启动节点管理器</li></ul><p>可以看一下此时集群上所有节点的 Java 进程状态</p><p><img src="https://user-images.githubusercontent.com/17758731/57020332-8aeb2200-6c5b-11e9-8075-2ffaebfd3096.png" alt="image"></p><p>此时我们已经完成了 Hadoop 完全分布式配置.</p><h1 id="4-分布式文件系统HDFS"><a href="#4-分布式文件系统HDFS" class="headerlink" title="4. 分布式文件系统HDFS"></a>4. 分布式文件系统HDFS</h1><h2 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h2><ul><li>Hadoop 实现的分布式文件系统(Hadoop Distributed File System), 简称 HDFS</li><li>源自于 Google 的 GFS 论文</li><li>发表与 2003 年, HDFS 是 GFS 的克隆版</li></ul><h2 id="4-2-设计目标"><a href="#4-2-设计目标" class="headerlink" title="4.2 设计目标"></a>4.2 设计目标</h2><ul><li>非常巨大的分布式文件系统</li><li>运行在普通的廉价硬件之上</li><li>易扩展, 为用户提供性能较高的文件存储服务</li></ul><h2 id="4-3-HDFS-架构"><a href="#4-3-HDFS-架构" class="headerlink" title="4.3 HDFS 架构"></a>4.3 HDFS 架构</h2><p><img src="https://user-images.githubusercontent.com/17758731/57053421-7c832180-6cc0-11e9-9ac0-cad53ca1ae99.png" alt="image"></p><p>一个 Master(NameNode/NN), 以及多个 Slave(DataNode/DN), DataNode 用于管理数据的读写, 一个文件会被拆分成多个 block, 默认为 128M, 被存储在一系列的 DataNode(不是一个 DataNode).</p><p>NameNode 职责:</p><ol><li>负责客户端请求的响应</li><li>负责元数据(文件名称, 副本系数, block 存放的 DN)的管理</li></ol><p>DataNode 职责:</p><ol><li>存储用户文件对应的数据块</li><li>要定期向 NameNode 发送心跳信息, 汇报本身及其所有的 block 信息, 健康状况</li></ol><h2 id="4-4-HDFS-副本机制"><a href="#4-4-HDFS-副本机制" class="headerlink" title="4.4 HDFS 副本机制"></a>4.4 HDFS 副本机制</h2><p><img src="https://user-images.githubusercontent.com/17758731/58401666-055b6600-8091-11e9-93ca-204b1312832c.png" alt="image"></p><p>心跳包中包含的信息:</p><ul><li>文件名称, 副本系数, block id</li><li>e.g. 文件名 part-0, 副本系数 2, block id 为 {1, 3}</li><li>e.g. 文件名 part-1, 副本系数 3, block id 为 {2, 4, 5}</li></ul><blockquote><p>HDFS 副本存放策略: 第一个副本存放在客户端所在的节点, 另外两个副本优先存放在不同的机架上, 假设集群只有一个机架, 所有副本都会存放在同一个机架, 如果集群存在多个机架, 就随机挑选一个.</p></blockquote><h2 id="4-5-Hadoop-Shell"><a href="#4-5-Hadoop-Shell" class="headerlink" title="4.5 Hadoop Shell"></a>4.5 Hadoop Shell</h2><p>基本的命令格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs/hadoop fs [generic options]</span><br><span class="line">比如 ls 命令可以写成: hdfs dfs -ls / 或 hadoop fs -ls /</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">ls</td><td style="text-align:center">展示文件/文件夹列表</td></tr><tr><td style="text-align:center">mkdir</td><td style="text-align:center">创建文件夹</td></tr><tr><td style="text-align:center">put</td><td style="text-align:center">上传文件</td></tr><tr><td style="text-align:center">get</td><td style="text-align:center">获取文件</td></tr><tr><td style="text-align:center">rm</td><td style="text-align:center">删除文件/文件夹</td></tr></tbody></table><h2 id="4-6-通过代码操作-API"><a href="#4-6-通过代码操作-API" class="headerlink" title="4.6 通过代码操作 API"></a>4.6 通过代码操作 API</h2><h3 id="4-6-1-测试文件的通用代码"><a href="#4-6-1-测试文件的通用代码" class="headerlink" title="4.6.1 测试文件的通用代码"></a>4.6.1 测试文件的通用代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HDFS_PATH = <span class="string">"hdfs://10.211.55.33:8020"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于文件系统, 所有操作的统一入库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FileSystem fileSystem = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Configuration configuration = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HDFSApp.setUp"</span>);</span><br><span class="line">        configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        fileSystem = FileSystem.get(<span class="keyword">new</span> URI(HDFS_PATH), configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        configuration = <span class="keyword">null</span>;</span><br><span class="line">        fileSystem = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"HDFSApp.tearDown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-2-创建路径"><a href="#4-6-2-创建路径" class="headerlink" title="4.6.2 创建路径"></a>4.6.2 创建路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 HDFS 目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    fileSystem.mkdirs(<span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后的结果:</p><p><img src="https://user-images.githubusercontent.com/17758731/58405892-0c877180-809b-11e9-9bed-22bb2a046cc3.png" alt="image"></p><h3 id="4-6-3-创建文件"><a href="#4-6-3-创建文件" class="headerlink" title="4.6.3 创建文件"></a>4.6.3 创建文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FSDataOutputStream fsDataOutputStream = fileSystem.create(<span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/a.txt"</span>));</span><br><span class="line">    fsDataOutputStream.write(<span class="string">"hello hadoop"</span>.getBytes());</span><br><span class="line">    fsDataOutputStream.flush();</span><br><span class="line">    fsDataOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后的结果:</p><p><img src="https://user-images.githubusercontent.com/17758731/58406172-98999900-809b-11e9-98c9-77d5b598fe54.png" alt="image"></p><h3 id="4-6-4-查看文件内容"><a href="#4-6-4-查看文件内容" class="headerlink" title="4.6.4 查看文件内容"></a>4.6.4 查看文件内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看 HDFS 文件的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FSDataInputStream fsDataInputStream = fileSystem.open(<span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/a.txt"</span>));</span><br><span class="line">    IOUtils.copyBytes(fsDataInputStream, System.out, <span class="number">1024</span>);</span><br><span class="line">    fsDataInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-5-重命名"><a href="#4-6-5-重命名" class="headerlink" title="4.6.5 重命名"></a>4.6.5 重命名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重命名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rename</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> rename = fileSystem.rename(<span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/a.txt"</span>), <span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/b.txt"</span>));</span><br><span class="line">    System.out.println(<span class="string">"rename = "</span> + rename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="https://user-images.githubusercontent.com/17758731/58406539-6b99b600-809c-11e9-8a9e-67819fc8e711.png" alt="image"></p><h3 id="4-6-6-将本地文件-copy-到-HDFS"><a href="#4-6-6-将本地文件-copy-到-HDFS" class="headerlink" title="4.6.6 将本地文件 copy 到 HDFS"></a>4.6.6 将本地文件 copy 到 HDFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将文件从本地 copy 到 HDFS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path localPath = <span class="keyword">new</span> Path(<span class="string">"/Users/destiny/dev/apache-tomcat-8.5.29-src.tar.gz"</span>);</span><br><span class="line">    Path hdfsPath = <span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/"</span>);</span><br><span class="line">    fileSystem.copyFromLocalFile(localPath, hdfsPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="https://user-images.githubusercontent.com/17758731/58406887-33df3e00-809d-11e9-9ebb-e7e94cdf83f8.png" alt="image"></p><h3 id="4-6-7-带进度条的上传"><a href="#4-6-7-带进度条的上传" class="headerlink" title="4.6.7 带进度条的上传"></a>4.6.7 带进度条的上传</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将文件从本地 copy 到 HDFS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFromLocalFileWithProgress</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/Users/destiny/dev/hadoop-2.7.7.tar.gz"</span>)));</span><br><span class="line">    FSDataOutputStream fsDataOutputStream = fileSystem.create(<span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/hadoop-2.7.7.tar.gz"</span>), <span class="keyword">new</span> Progressable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">progress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 带进度条提醒信息</span></span><br><span class="line">            System.out.print(<span class="string">"#"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    IOUtils.copyBytes(inputStream, fsDataOutputStream, <span class="number">4096</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="https://user-images.githubusercontent.com/17758731/58407545-9dac1780-809e-11e9-9873-15c03f8832eb.png" alt="image"></p><h3 id="4-6-8-下载-HDFS-文件"><a href="#4-6-8-下载-HDFS-文件" class="headerlink" title="4.6.8 下载 HDFS 文件"></a>4.6.8 下载 HDFS 文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载 HDFS 文件到本地</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path localPath = <span class="keyword">new</span> Path(<span class="string">"/Users/destiny/dev/"</span>);</span><br><span class="line">    Path hdfsPath = <span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/b.txt"</span>);</span><br><span class="line">    fileSystem.copyToLocalFile(hdfsPath, localPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-9-查看指定路径下的所有文件"><a href="#4-6-9-查看指定路径下的所有文件" class="headerlink" title="4.6.9 查看指定路径下的所有文件"></a>4.6.9 查看指定路径下的所有文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看指定路径的所有文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileStatus[] fileStatuses = fileSystem.listStatus(<span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/"</span>));</span><br><span class="line">    <span class="keyword">for</span> (FileStatus fileStatus : fileStatuses) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> directory = fileStatus.isDirectory();</span><br><span class="line">        System.out.println(<span class="string">"directory = "</span> + directory);</span><br><span class="line">        <span class="keyword">short</span> replication = fileStatus.getReplication();</span><br><span class="line">        System.out.println(<span class="string">"replication = "</span> + replication);</span><br><span class="line">        <span class="keyword">long</span> len = fileStatus.getLen();</span><br><span class="line">        System.out.println(<span class="string">"len = "</span> + len);</span><br><span class="line">        String path = fileStatus.getPath().toString();</span><br><span class="line">        System.out.println(<span class="string">"path = "</span> + path);</span><br><span class="line">        System.out.println(<span class="string">"==============================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><p><img src="https://user-images.githubusercontent.com/17758731/58408282-1495e000-80a0-11e9-9cd4-8221cd4cc79a.png" alt="image"></p><p>这里有一个小问题:</p><blockquote><p>在前面的分布式配置中, <code>hdfs-site.xml</code> 中设置的副本系数为 2, 但这里查询到的结果却为 3<br>如果是通过 HDFS shell 的方式 put 上去, 那么会采用设置的副本系数 2<br>而如果是通过 java API 上传, 那么由于本地没有设置副本系数, 因此采用的是 Hadoop 自带的副本系数</p></blockquote><h3 id="4-6-10-删除文件"><a href="#4-6-10-删除文件" class="headerlink" title="4.6.10 删除文件"></a>4.6.10 删除文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文件(默认递归)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    fileSystem.delete(<span class="keyword">new</span> Path(<span class="string">"/hdfsapi/test/"</span>), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-HDFS-文件写入流程"><a href="#4-7-HDFS-文件写入流程" class="headerlink" title="4.7 HDFS 文件写入流程"></a>4.7 HDFS 文件写入流程</h2><h2 id="4-8-HDFS-文件读取刘晨"><a href="#4-8-HDFS-文件读取刘晨" class="headerlink" title="4.8 HDFS 文件读取刘晨"></a>4.8 HDFS 文件读取刘晨</h2><h1 id="5-资源调度框架-YARN"><a href="#5-资源调度框架-YARN" class="headerlink" title="5. 资源调度框架 YARN"></a>5. 资源调度框架 YARN</h1><h2 id="5-1-背景"><a href="#5-1-背景" class="headerlink" title="5.1 背景"></a>5.1 背景</h2><h3 id="5-1-1-MapReduce-1-X-存在的问题"><a href="#5-1-1-MapReduce-1-X-存在的问题" class="headerlink" title="5.1.1 MapReduce 1.X 存在的问题"></a>5.1.1 MapReduce 1.X 存在的问题</h3><blockquote><ul><li>集群由一个 JobTracker 与多个 TaskTracker 构成, 客户端提交任务的时候, 直接将作业提交给 JobTracker, 由 JobTracker 负责资源的管理与作业的调度;  </li><li>TaskTracker 定期通过心跳机制与 JobTracker 进行通信, 汇报健康状况, 资源使用情况以及任务的执行进度, 并且接收来自 JobTracker 的命令来进行任务的启动和结束</li></ul></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/58748384-85773680-84aa-11e9-8233-daebe5f2ccf6.png" alt="image"></p><p>存在问题:</p><ol><li>JobTracker 存在单点故障</li><li>JobTracker 负载较大, 需要接收 TaskTracker 的心跳信息, 制约 Hadoop 集群的扩展</li><li>JobTracker 承载职责较多,  包括资源管理, 资源调度, 任务分配</li><li>仅仅支持 MapReduce 作业, Spark 以及 Storm 作业无法支持</li></ol><h3 id="5-1-2-资源利用-amp-运维成本"><a href="#5-1-2-资源利用-amp-运维成本" class="headerlink" title="5.1.2 资源利用&amp;运维成本"></a>5.1.2 资源利用&amp;运维成本</h3><p><img src="https://user-images.githubusercontent.com/17758731/58748483-1c90be00-84ac-11e9-8a8f-a1047ab1e791.png" alt="image"></p><p>由于 Hadoop 集群不支持其他形式的作业, 因此生产环境需要部署多套集群, 而不同集群在造成更多资源占用的同时, 往往存在运行时间不同, 如果能够将多个集群整合在一起, 就可以节约计算资源.</p><p>如果存在一种 <code>共享集群</code>, 能够处理不同类型的作业, 并且能够自行实现资源的合理分配, 就可以解决不同作业任务需要多套集群环境的问题.</p><p><img src="https://user-images.githubusercontent.com/17758731/58748603-f5d38700-84ad-11e9-862f-26c9e6a73f13.png" alt="image"></p><p>在 Hadoop2.0 的架构中, Hadoop 之上运行 YARN, YARN 负责集群的资源管理, 而 YARN 可以接收来自 MapReduce, HBase, Storm, Spark 等多种应用的输入. YARN 做了统一的抽象, 类似操作系统级别的通用资源调度框架, 可以让更多的计算框架运行在同一个集群中, 不同的计算框架可以共享同一个 HDFS 上的数据, 享受整体的资源调度.</p><h2 id="5-2-架构"><a href="#5-2-架构" class="headerlink" title="5.2 架构"></a>5.2 架构</h2><ul><li>Yarn(Yet Another Resource Negotiator, 另一个资源协调者的简称)</li><li>是一个通用的资源管理系统</li><li>为上层应用提供统一的资源管理和调度</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/58748576-8d84a580-84ad-11e9-98db-95d5970a38d0.png" alt="image"></p><p>Yarn 架构的核心组件:</p><table><thead><tr><th style="text-align:center">角色</th><th>描述</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">ResourceManager</td><td>整个集群同一时间提供服务的 Resource Manager 只有一个, 负责集群资源的统一管理和调度</td><td>1. 提交作业<br>2. 杀死作业<br>3. 监控 NodeManager, 一旦某个 NodeManager 挂了, 该 NameNode 上运行的任务要告诉 Application Master</td></tr><tr><td style="text-align:center">NodeManager</td><td>整个集群中有多个 NodeManager, 负责当前节点资源管理和使用</td><td>1. 定时向 ResourceManager 汇报当前节点的资源使用情况<br>2. 接受并处理 ResourceManager 的各种命令<br>3. 处理来自 Application Master 的命令<br>4. 单个节点的资源管理</td></tr><tr><td style="text-align:center">Application Master</td><td>每个应用程序对应一个 Application Master, 负责应用程序的管理</td><td>1. 为应用程序向 ResourceManager 申请资源(core, mem)<br>2. 分配给内部的 Task 处理<br> 3. 需要与 NodeManager 通信, 启动/停止 task</td></tr><tr><td style="text-align:center">Container</td><td>封装了 CPU, MEM 等资源的容器, 是一个任务运行环境的抽象</td></tr><tr><td style="text-align:center">Client</td><td>用于封装用户的操作</td><td>1. 提交作业<br> 2. 查询作业运行进度 <br> 3. 杀死作业<br></td></tr></tbody></table><h2 id="5-3-执行流程"><a href="#5-3-执行流程" class="headerlink" title="5.3 执行流程"></a>5.3 执行流程</h2><p><img src="https://user-images.githubusercontent.com/17758731/60674721-568b2080-9ead-11e9-8c35-654d3fdc8fdc.png" alt="image"></p><ol><li>用户向 YARN 提交作业</li><li>ResourceManager 为作业分配第一个 Container, 与对应的 NodeManager 通信, 要求在其上启动 Container, 用来启动应用程序</li><li>NodeManager 按照要求, 启动 Application Master</li><li>Application Master 启动后, 会首先在 ResourceManager 进行注册, 此时就可以通过 ResourceManager 查询作业的运行情况. 然后 ApplicationMaster 会将所需要的资源到 ResourceManager 上去申请</li><li>ApplicationMaster 申请到资源之后在对应的 NodeManager 上开始启动任务, 所有的任务都是以 Container 的方式运行的</li><li>NodeManager 启动对应的 Container 去执行任务.</li></ol><h2 id="5-5-提交作业到-YARN-上执行"><a href="#5-5-提交作业到-YARN-上执行" class="headerlink" title="5.5 提交作业到 YARN 上执行"></a>5.5 提交作业到 YARN 上执行</h2><h3 id="5-5-1-提交-Hadoop-包的-Example"><a href="#5-5-1-提交-Hadoop-包的-Example" class="headerlink" title="5.5.1 提交 Hadoop 包的 Example"></a>5.5.1 提交 Hadoop 包的 Example</h3><p>在 Hadoop 安装路径下的 <code>share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar</code> 文件</p><p>使用如下命令将 MapReduce 作业提交到 YARN 上去运行: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-mapreduce-examples-2.7.7.jar pi 2 3</span><br></pre></td></tr></table></figure><h1 id="6-启动脚本分析"><a href="#6-启动脚本分析" class="headerlink" title="6. 启动脚本分析"></a>6. 启动脚本分析</h1><p>Hadoop 启动脚本位于 <code>${HADOOP_HOME}/bin</code>, <code>${HADOOP_HOME}/sbin</code> 和 <code>${HADOOP_HOME}/libexec</code> 路径下, 其中包含 *nux 的 Shell 脚本和 win 的批处理文件.</p><h2 id="6-1-start-all-sh-启动分析"><a href="#6-1-start-all-sh-启动分析" class="headerlink" title="6.1 start-all.sh 启动分析"></a>6.1 start-all.sh 启动分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start all hadoop daemons.  Run this on master node.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This script is Deprecated. Instead use start-dfs.sh and start-yarn.sh"</span></span><br><span class="line"></span><br><span class="line">bin=`dirname <span class="string">"<span class="variable">$&#123;BASH_SOURCE-$0&#125;</span>"</span>`</span><br><span class="line">bin=`<span class="built_in">cd</span> <span class="string">"<span class="variable">$bin</span>"</span>; <span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line">DEFAULT_LIBEXEC_DIR=<span class="string">"<span class="variable">$bin</span>"</span>/../libexec</span><br><span class="line">HADOOP_LIBEXEC_DIR=<span class="variable">$&#123;HADOOP_LIBEXEC_DIR:-$DEFAULT_LIBEXEC_DIR&#125;</span></span><br><span class="line">. <span class="variable">$HADOOP_LIBEXEC_DIR</span>/hadoop-config.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># start hdfs daemons if hdfs is present</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$&#123;HADOOP_HDFS_HOME&#125;</span>"</span>/sbin/start-dfs.sh ]; <span class="keyword">then</span></span><br><span class="line">  <span class="string">"<span class="variable">$&#123;HADOOP_HDFS_HOME&#125;</span>"</span>/sbin/start-dfs.sh --config <span class="variable">$HADOOP_CONF_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start yarn daemons if yarn is present</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$&#123;HADOOP_YARN_HOME&#125;</span>"</span>/sbin/start-yarn.sh ]; <span class="keyword">then</span></span><br><span class="line">  <span class="string">"<span class="variable">$&#123;HADOOP_YARN_HOME&#125;</span>"</span>/sbin/start-yarn.sh --config <span class="variable">$HADOOP_CONF_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ol><li>首先会通过 echo 输出一句话, 大意是该脚本已被废弃, 推荐使用 <code>start-dfs.sh</code> 和 <code>start-yarn.sh</code></li><li><code>bin=`dirname &quot;${BASH_SOURCE-$0}&quot;`</code> 提取 start-all.sh 所在的绝对路径</li><li><code>bin=`cd &quot;$bin&quot;; pwd`</code> 切换到 start-all.sh 所在的绝对路径</li><li><code>DEFAULT_LIBEXEC_DIR=&quot;$bin&quot;/../libexec</code> 获取 <code>${HADOOP_HOME}/libexec/hadoop-config.sh</code> 路径</li><li><code>HADOOP_LIBEXEC_DIR=${HADOOP_LIBEXEC_DIR:-$DEFAULT_LIBEXEC_DIR}</code> 为 <code>HADOOP_LIBEXEC_DIR</code> 变量三元赋值: 如果 <code>HADOOP_LIBEXEC_DIR</code> 为空或者环境变量没有配置, 复制默认的绝对路径</li><li><code>. $HADOOP_LIBEXEC_DIR/hadoop-config.sh</code> 执行 <code>${HADOOP_HOME}/libexec/hadoop-config.sh</code> 脚本, 为后面执行启动各节点和启动 yarn 做预处理</li><li><code>&quot;${HADOOP_HDFS_HOME}&quot;/sbin/start-dfs.sh --config $HADOOP_CONF_DIR</code> 如果 <code>${HADOOP_HDFS_HOME}&quot;/sbin/start-dfs.sh</code> 是文件, 就通过 –config 参数启动 <code>start-dfs.sh</code> 脚本</li><li><code>&quot;${HADOOP_YARN_HOME}&quot;/sbin/start-yarn.sh --config $HADOOP_CONF_DIR</code>: 如果 <code>${HADOOP_YARN_HOME}&quot;/sbin/start-yarn.sh</code> 是文件, 就通过 –config 参数启动 <code>start-yarn.sh</code> 脚本</li></ol><h2 id="6-2-hadoop-config-sh"><a href="#6-2-hadoop-config-sh" class="headerlink" title="6.2 hadoop-config.sh"></a>6.2 hadoop-config.sh</h2><p>该脚本位于</p><h1 id="7-MapReduce"><a href="#7-MapReduce" class="headerlink" title="7. MapReduce"></a>7. MapReduce</h1><p>MapReduce 是一种并行计算编程模型, 源自于 Google 的 MapReduce 论文, 包含 Map 过程和 Reduce 过程, Map 过程对应创建 Mapper 实现类, Reduce 过程对应创建 Reducer 实现类.</p><h2 id="7-2-Map-和-Reduce-阶段"><a href="#7-2-Map-和-Reduce-阶段" class="headerlink" title="7.2 Map 和 Reduce 阶段"></a>7.2 Map 和 Reduce 阶段</h2><p>将作业拆分成 Map 阶段和 Reduce 阶段</p><ol><li>准备 Map 处理的输入数据</li><li>Mapper 处理</li><li>Shuffle: 将相同的 key 分配到同一个 Reduce 节点</li><li>Reduce 处理</li><li>输出结果</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/61185171-8ba32a00-a688-11e9-895f-b9b2e2fbaf96.png" alt="image"></p><p>假设现在有两个节点</p><ol><li>使用 <code>InputFormat</code> 读取文件系统(本地, HDFS), 并拆分成多个 Split</li><li>每个 Split 由一个 <code>RecordReader</code> 负责读取, 每读一行交由一个 mapper 处理</li><li>map 产生的结果交由 <code>Partitioner</code>, 将所有的 key 按一定规则分配给同一个节点并完成排序</li><li>相同的 key 交给 <code>Reduce</code> 负责处理</li><li>处理的结果交给 <code>OutputFormat</code> 写回文件系统</li></ol><h2 id="7-3-MapReduce-编程模型"><a href="#7-3-MapReduce-编程模型" class="headerlink" title="7.3 MapReduce 编程模型"></a>7.3 MapReduce 编程模型</h2><p><img src="https://user-images.githubusercontent.com/17758731/61185527-1b4ad780-a68d-11e9-9595-f8a380a57aa7.png" alt="image"></p><h3 id="7-3-1-Split"><a href="#7-3-1-Split" class="headerlink" title="7.3.1 Split"></a>7.3.1 Split</h3><p>被 InputFormat 从文件系统中读取并分片, 并交由 MapReduce 作业来处理的数据块</p><blockquote><p>HDFS 中的 blocksize 是 HDFS 中最小的存储单元, 默认 128M<br>Split 是 MapReduce 中最小的计算单元<br>默认情况下二者是一一对应的, 也可以手工设置二者之间的关系.</p></blockquote><h3 id="7-3-2-Combiner"><a href="#7-3-2-Combiner" class="headerlink" title="7.3.2 Combiner"></a>7.3.2 Combiner</h3><h3 id="7-3-3-Partitioner"><a href="#7-3-3-Partitioner" class="headerlink" title="7.3.3 Partitioner"></a>7.3.3 Partitioner</h3><h3 id="7-4-MapReduce-1-x-架构"><a href="#7-4-MapReduce-1-x-架构" class="headerlink" title="7.4 MapReduce 1.x 架构"></a>7.4 MapReduce 1.x 架构</h3><p><img src="https://user-images.githubusercontent.com/17758731/58748384-85773680-84aa-11e9-8233-daebe5f2ccf6.png" alt="image"></p><ol><li>JobTracker(JT)<ol><li>作业的管理者</li><li>将作业分解成多个任务(MapTask &amp; ReduceTask)</li><li>将任务分派给 TaskTracker 运行</li><li>作业监控, 容错处理</li><li>在一定时间内 JobTacker 没有收到 TaskTracker 的心跳, 会重新指派到其他的 TaskTracker 去执行</li></ol></li><li>TaskTracker(TT)<ol><li>任务的执行者, 执行任务(MapTask &amp; ReduceTask)</li><li>与 JobTracker 交互: 执行/启动/停止, 发送心跳信息给 JobTracker</li></ol></li><li>MapTask<ol><li>开发的 map 任务交由 MapTask 完成</li><li>解析每条记录的数据交给自己的 Map 方法处理</li><li>将 Map 的输出结果写到本地磁盘</li></ol></li><li>ReduceTask<ol><li>将 MapTask 输出的数据进行读取</li><li>按照数据进行分组传给 Reduce 方法处理</li><li>输出结果, 写入到 HDFS</li></ol></li></ol><h3 id="7-5-MapReduce-2-x-架构"><a href="#7-5-MapReduce-2-x-架构" class="headerlink" title="7.5 MapReduce 2.x 架构"></a>7.5 MapReduce 2.x 架构</h3><h3 id="7-6-Combiner"><a href="#7-6-Combiner" class="headerlink" title="7.6 Combiner"></a>7.6 Combiner</h3><ul><li>在 Mapper Task本地的 Reduce</li><li>减少 Map Task 输出的数据量及数据网络传输量</li><li>大部分情况下逻辑和 Reduce 基本相同</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/61586498-5fb40700-aba8-11e9-86ff-1309911e1010.png" alt="image"></p><h3 id="7-7-Partitioner"><a href="#7-7-Partitioner" class="headerlink" title="7.7 Partitioner"></a>7.7 Partitioner</h3><ul><li>决定 MapTask 输出的数据交由哪个 Reducer 处理</li><li>默认实现: 分发的 key 的 hash 值对 Reduce Task 个数取模</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;h1 id=&quot;2-Hadoop-安装&quot;&gt;&lt;a href=&quot;#2-Hadoop-安装&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="大数据" scheme="https://destinywang.github.io/blog/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="https://destinywang.github.io/blog/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://destinywang.github.io/blog/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(9)-XML解析</title>
    <link href="https://destinywang.github.io/blog/2019/04/08/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-9-XML%E8%A7%A3%E6%9E%90/"/>
    <id>https://destinywang.github.io/blog/2019/04/08/Activiti源码分析-9-XML解析/</id>
    <published>2019-04-08T14:32:21.000Z</published>
    <updated>2019-04-08T15:53:19.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-XML-解析"><a href="#1-XML-解析" class="headerlink" title="1. XML 解析"></a>1. XML 解析</h1><h2 id="1-1-DOM-模型"><a href="#1-1-DOM-模型" class="headerlink" title="1.1. DOM 模型"></a>1.1. DOM 模型</h2><ul><li>优点: 文档解析的时候允许客户端编辑和更新 XML 文档的内容, 并可以随机访问文档中定义的元素数据.</li><li>缺点: 文档解析的时候需要将 XML 一次性加载到内存, 进而映射成 Document 对象中的树形结构, 在解析大文件的时候内存占用大, 元素遍历查找慢, 性能容易成为瓶颈.</li></ul><h2 id="1-2-SAX-模型"><a href="#1-2-SAX-模型" class="headerlink" title="1.2. SAX 模型"></a>1.2. SAX 模型</h2><ul><li>优点: 该方式解析文档的时候, 每一次操作只会将解析的节点放置到内存中, 从头部开始, 读取一段处理一段, 内存占用小.</li><li>缺点: 解析文档的时候文档是只读的, 不能编辑, 并且文件流只能前进不能后退</li></ul><p>在 Activiti 中, 由于 XML 完全由用户的输入决定, 无法控制器大小, 因此选用 SAX 模型</p><h1 id="2-文档转换器"><a href="#2-文档转换器" class="headerlink" title="2. 文档转换器"></a>2. 文档转换器</h1><p>文档转换器可以将文档转换为 BpmnModel, 也可以将 BpmnModel 转换为文档</p><p>文档解析器: BpmnXMLConverter</p><p>解析器内部持有所有 <code>元素解析器</code></p><ul><li>元素解析器与元素之间一一对应</li><li>任务节点的元素名称是 UserTask, 因此对应的解析器为 <code>UserTaskXMLConverter</code></li><li>连线的元素名称是 SequenceFlow, 对应的解析器为 <code>SequenceFlowXMLConverter</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-XML-解析&quot;&gt;&lt;a href=&quot;#1-XML-解析&quot; class=&quot;headerlink&quot; title=&quot;1. XML 解析&quot;&gt;&lt;/a&gt;1. XML 解析&lt;/h1&gt;&lt;h2 id=&quot;1-1-DOM-模型&quot;&gt;&lt;a href=&quot;#1-1-DOM-模型&quot; class
      
    
    </summary>
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/categories/Activiti/"/>
    
      <category term="源码" scheme="https://destinywang.github.io/blog/categories/Activiti/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(7)-ID生成器</title>
    <link href="https://destinywang.github.io/blog/2019/03/26/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-7-ID%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://destinywang.github.io/blog/2019/03/26/Activiti源码分析-7-ID生成器/</id>
    <published>2019-03-26T14:52:05.000Z</published>
    <updated>2019-04-21T02:45:15.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-DbIdGenerator"><a href="#1-DbIdGenerator" class="headerlink" title="1. DbIdGenerator"></a>1. <code>DbIdGenerator</code></h1><p><img src="https://user-images.githubusercontent.com/17758731/55007318-2e706380-501a-11e9-9a32-8e98d9944b66.png" alt="image"></p><p>Activiti 默认采用数据库来实现强一致的发号器 <code>DbIdGenerator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbIdGenerator</span> <span class="keyword">implements</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> idBlockSize;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> nextId;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> lastId = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> CommandExecutor commandExecutor;</span><br><span class="line">  <span class="keyword">protected</span> CommandConfig commandConfig;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastId &lt; nextId) &#123;</span><br><span class="line">      getNewBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> _nextId = nextId++;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(_nextId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getNewBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IdBlock idBlock = commandExecutor.execute(commandConfig, <span class="keyword">new</span> GetNextIdBlockCmd(idBlockSize));</span><br><span class="line">    <span class="keyword">this</span>.nextId = idBlock.getNextId();</span><br><span class="line">    <span class="keyword">this</span>.lastId = idBlock.getLastId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdBlockSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> idBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdBlockSize</span><span class="params">(<span class="keyword">int</span> idBlockSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.idBlockSize = idBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommandExecutor <span class="title">getCommandExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommandExecutor</span><span class="params">(CommandExecutor commandExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CommandConfig <span class="title">getCommandConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommandConfig</span><span class="params">(CommandConfig commandConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.commandConfig = commandConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DbIdGenerator 实现了 <code>getNextId</code> 方法, 用于对应用范围内所有的实体对象分配 id, 我们就以这个方法为起点, 分析默认的发号器逻辑.</p><h2 id="1-1-DbIdGenerator-getNextId"><a href="#1-1-DbIdGenerator-getNextId" class="headerlink" title="1.1. DbIdGenerator#getNextId()"></a>1.1. DbIdGenerator#getNextId()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastId &lt; nextId) &#123;</span><br><span class="line">        getNewBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> _nextId = nextId++;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(_nextId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>比较内部持有的两个布局变量 <code>lastId</code> 和 <code>nextId</code><ol><li>如果 <code>lastId</code> 已经小于 <code>nextId</code></li><li>获取一个新的 Block</li></ol></li><li>获得当前的 <code>_nextId</code>, 并转换成字符串, 同时持有的局部变量 <code>nextId</code> 自增</li></ol><h2 id="1-2-DbIdGenerator-getNewBlock"><a href="#1-2-DbIdGenerator-getNewBlock" class="headerlink" title="1.2. DbIdGenerator#getNewBlock()"></a>1.2. DbIdGenerator#getNewBlock()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getNewBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IdBlock idBlock = commandExecutor.execute(commandConfig, <span class="keyword">new</span> GetNextIdBlockCmd(idBlockSize));</span><br><span class="line">    <span class="keyword">this</span>.nextId = idBlock.getNextId();</span><br><span class="line">    <span class="keyword">this</span>.lastId = idBlock.getLastId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取一个新的 <code>IdBlock</code> 对象</li><li>分别将该对象的 <code>nextId</code> 和 <code>lastId</code> 赋值给自身持有的同名字段</li></ol><h2 id="1-3-GetNextIdBlockCmd-execute-CommandContext-commandContext"><a href="#1-3-GetNextIdBlockCmd-execute-CommandContext-commandContext" class="headerlink" title="1.3. GetNextIdBlockCmd#execute(CommandContext commandContext)"></a>1.3. GetNextIdBlockCmd#execute(CommandContext commandContext)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IdBlock <span class="title">execute</span><span class="params">(CommandContext commandContext)</span> </span>&#123;</span><br><span class="line">    PropertyEntity property = (PropertyEntity) commandContext.getPropertyEntityManager().findById(<span class="string">"next.dbid"</span>);</span><br><span class="line">    <span class="keyword">long</span> oldValue = Long.parseLong(property.getValue());</span><br><span class="line">    <span class="keyword">long</span> newValue = oldValue + idBlockSize;</span><br><span class="line">    property.setValue(Long.toString(newValue));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IdBlock(oldValue, newValue - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 <code>PropertyEntityManager</code>, 从 <code>ACT_GE_PROPERTY</code> 表中获取 <code>next.dbid</code> 字段的值</li><li>将旧值转换成 long 类型并增加 <code>idBlockSize</code> 长度得到新值, 其中 <code>idBlockSize</code> 通过调用链追踪到在 <code>ProcessEngineConfiguration</code> 将其设置为 2500, 并调用命令类的初始化</li><li>将新值设置进查询到的 property 对象</li><li>返回新的 <code>IdBlock</code> 对象</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-DbIdGenerator&quot;&gt;&lt;a href=&quot;#1-DbIdGenerator&quot; class=&quot;headerlink&quot; title=&quot;1. DbIdGenerator&quot;&gt;&lt;/a&gt;1. &lt;code&gt;DbIdGenerator&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;&lt;im
      
    
    </summary>
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/categories/Activiti/"/>
    
      <category term="源码" scheme="https://destinywang.github.io/blog/categories/Activiti/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(8)-发起流程实例</title>
    <link href="https://destinywang.github.io/blog/2019/03/09/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-8-%E5%8F%91%E8%B5%B7%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B/"/>
    <id>https://destinywang.github.io/blog/2019/03/09/Activiti源码分析-8-发起流程实例/</id>
    <published>2019-03-09T10:48:39.000Z</published>
    <updated>2019-03-10T05:03:49.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><h2 id="1-1-启动流程"><a href="#1-1-启动流程" class="headerlink" title="1.1. 启动流程"></a>1.1. 启动流程</h2><ol><li>操作数据库的 ACT_RU_EXECUTION 表, 如果是用户任务节点, 同时也会在 ACT_RU_TASK 表添加一条记录;</li><li></li></ol><h2 id="1-2-流程实例"><a href="#1-2-流程实例" class="headerlink" title="1.2. 流程实例"></a>1.2. 流程实例</h2><ol><li>代表流程定义的执行实例</li><li>一个流程实例包括了所有的运行节点</li><li>流程实例表示一个流程从开始到结束的最大流程分支</li><li>流程实例也被称为执行实例根节点</li></ol><p>在 Activiti 对应的接口为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessInstance</span> <span class="keyword">extends</span> <span class="title">Execution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 ProcessInstance 就是 Execution</p><h2 id="1-3-执行实例"><a href="#1-3-执行实例" class="headerlink" title="1.3. 执行实例"></a>1.3. 执行实例</h2><ol><li>启动流程的时候会首先创建流程实例, 然后创建执行实例</li><li>流程运转的过程中永远执行的是自己对应的执行实例</li><li>当所有的执行实例按照规则完毕之后, 对应的流程随之结束</li><li>Activiti 使用 <code>Execution</code> 对象去描述流程执行的每一个节点</li><li>流程按照流程定义的规则执行一次的过程, 就可以表示执行对象 <code>Execution</code></li><li>一个流程中, 执行对象可以存在多个, 但流程实例只能有一个</li><li>执行实例的父级 / 父级的父级为流程实例</li></ol><h2 id="1-4-概念演示"><a href="#1-4-概念演示" class="headerlink" title="1.4. 概念演示"></a>1.4. 概念演示</h2><h3 id="1-4-1-简单流程实例"><a href="#1-4-1-简单流程实例" class="headerlink" title="1.4.1. 简单流程实例"></a>1.4.1. 简单流程实例</h3><p><img src="https://user-images.githubusercontent.com/17758731/54070715-5d5aab80-429e-11e9-815e-bfc25e01843c.png" alt="image"></p><ol><li>发起流程的时候, 会先创建一个流程实例, 然后创建执行实例;</li><li>随着流程的运转, 执行实例会不断更新;</li><li>直到流程执行完毕(走到结束节点), 对应执行实例会结束, 此时流程实例也结束.</li></ol><h3 id="1-4-2-有分支的流程实例"><a href="#1-4-2-有分支的流程实例" class="headerlink" title="1.4.2. 有分支的流程实例"></a>1.4.2. 有分支的流程实例</h3><p><img src="https://user-images.githubusercontent.com/17758731/54070799-bf67e080-429f-11e9-9264-556b380bc5cc.png" alt="image"></p><ol><li>当流程进入并行网关之后, 会创建两个执行实例</li><li>当两个执行实例都结束之后, 再创建第三个执行实例</li></ol><h1 id="2-RuntimeServiceImpl-startProcessInstanceByKey-String-processDefinitionKey"><a href="#2-RuntimeServiceImpl-startProcessInstanceByKey-String-processDefinitionKey" class="headerlink" title="2. RuntimeServiceImpl#startProcessInstanceByKey(String processDefinitionKey)"></a>2. RuntimeServiceImpl#startProcessInstanceByKey(String processDefinitionKey)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessInstance <span class="title">startProcessInstanceByKey</span><span class="params">(String processDefinitionKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.execute(<span class="keyword">new</span> StartProcessInstanceCmd&lt;ProcessInstance&gt;(processDefinitionKey, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-StartProcessInstanceCmd-execution-CommandContext-commandContext"><a href="#2-1-StartProcessInstanceCmd-execution-CommandContext-commandContext" class="headerlink" title="2.1. StartProcessInstanceCmd#execution(CommandContext commandContext)"></a>2.1. StartProcessInstanceCmd#execution(CommandContext commandContext)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessInstance <span class="title">execute</span><span class="params">(CommandContext commandContext)</span> </span>&#123;</span><br><span class="line">    DeploymentManager deploymentCache = commandContext.getProcessEngineConfiguration().getDeploymentManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the process definition</span></span><br><span class="line">    ProcessDefinition processDefinition = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (processDefinitionId != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        processDefinition = deploymentCache.findDeployedProcessDefinitionById(processDefinitionId);</span><br><span class="line">        <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiObjectNotFoundException(<span class="string">"No process definition found for id = '"</span> + processDefinitionId + <span class="string">"'"</span>, ProcessDefinition.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processDefinitionKey != <span class="keyword">null</span> &amp;&amp; (tenantId == <span class="keyword">null</span> || ProcessEngineConfiguration.NO_TENANT_ID.equals(tenantId))) &#123;</span><br><span class="line"></span><br><span class="line">        processDefinition = deploymentCache.findDeployedLatestProcessDefinitionByKey(processDefinitionKey);</span><br><span class="line">        <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiObjectNotFoundException(<span class="string">"No process definition found for key '"</span> + processDefinitionKey + <span class="string">"'"</span>, ProcessDefinition.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processDefinitionKey != <span class="keyword">null</span> &amp;&amp; tenantId != <span class="keyword">null</span> &amp;&amp; !ProcessEngineConfiguration.NO_TENANT_ID.equals(tenantId)) &#123;</span><br><span class="line"></span><br><span class="line">            processDefinition = deploymentCache.findDeployedLatestProcessDefinitionByKeyAndTenantId(processDefinitionKey, tenantId);</span><br><span class="line">            <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiObjectNotFoundException(<span class="string">"No process definition found for key '"</span> + processDefinitionKey + <span class="string">"' for tenant identifier "</span> + tenantId, ProcessDefinition.class);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"processDefinitionKey and processDefinitionId are null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processInstanceHelper = commandContext.getProcessEngineConfiguration().getProcessInstanceHelper();</span><br><span class="line">    ProcessInstance processInstance = createAndStartProcessInstance(processDefinition, businessKey, processInstanceName, variables, transientVariables);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>初始化 processDefinition 对象, 由于 <code>startProcessInstanceByXX</code> 系列方法有多种参数, 因此一下三种条件都可以实现:<ol><li>如果 processDefinitionId 不为空, 通过该 id 查询流程定义;</li><li>如果 processDefinitionKey 不为空, 并且 <code>tenantId</code> 为空, 就通过 <code>processDefinitionKey</code> 查询最新的流程定义;</li><li>如果 processDefinitionKey 不为空, 并且 <code>tenantId</code> 也不为空, 就通过这两个参数一起查询最新的流程定义;</li></ol></li><li>获取 <code>processInstanceHelper</code> 对象</li><li>执行创建流程逻辑并返回</li></ol><h2 id="2-2-StartProcessInstanceCmd-createAndStartProcessInstance-ProcessDefinition-processDefinition-String-businessKey-String-processInstanceName-Map-lt-String-Object-gt-variables-Map-lt-String-Object-gt-transientVariables"><a href="#2-2-StartProcessInstanceCmd-createAndStartProcessInstance-ProcessDefinition-processDefinition-String-businessKey-String-processInstanceName-Map-lt-String-Object-gt-variables-Map-lt-String-Object-gt-transientVariables" class="headerlink" title="2.2. StartProcessInstanceCmd#createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String,Object&gt; variables, Map&lt;String, Object&gt; transientVariables)"></a>2.2. StartProcessInstanceCmd#createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String,Object&gt; variables, Map&lt;String, Object&gt; transientVariables)</h2><p>参数较多, 先解释下参数:</p><ul><li>processDefinition: 流程定义对象</li><li>businessKey: 业务标识</li><li>processInstanceName: 需要设置的流程名称</li><li>variables: 表单数据(会持久化到变量表中)</li><li>transientVariables: 不需要持久化的变量表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ProcessInstance <span class="title">createAndStartProcessInstance</span><span class="params">(ProcessDefinition processDefinition, String businessKey, String processInstanceName, </span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;String,Object&gt; variables, Map&lt;String, Object&gt; transientVariables)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> processInstanceHelper.createAndStartProcessInstance(processDefinition, businessKey, processInstanceName, variables, transientVariables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-ProcessInstanceHelper-createAndStartProcessInstance-ProcessDefinition-processDefinition-String-businessKey-String-processInstanceName-Map-lt-String-Object-gt-variables-Map-lt-String-Object-gt-transientVariables-boolean-startProcessInstance"><a href="#2-3-ProcessInstanceHelper-createAndStartProcessInstance-ProcessDefinition-processDefinition-String-businessKey-String-processInstanceName-Map-lt-String-Object-gt-variables-Map-lt-String-Object-gt-transientVariables-boolean-startProcessInstance" class="headerlink" title="2.3. ProcessInstanceHelper#createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance)"></a>2.3. ProcessInstanceHelper#createAndStartProcessInstance(ProcessDefinition processDefinition, String businessKey, String processInstanceName, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ProcessInstance <span class="title">createAndStartProcessInstance</span><span class="params">(ProcessDefinition processDefinition,</span></span></span><br><span class="line"><span class="function"><span class="params">      String businessKey, String processInstanceName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, <span class="keyword">boolean</span> startProcessInstance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CommandContext commandContext = Context.getCommandContext(); <span class="comment">// Todo: ideally, context should be passed here</span></span><br><span class="line">    <span class="keyword">if</span> (Activiti5Util.isActiviti5ProcessDefinition(commandContext, processDefinition)) &#123;</span><br><span class="line">        Activiti5CompatibilityHandler activiti5CompatibilityHandler = Activiti5Util.getActiviti5CompatibilityHandler();</span><br><span class="line">        <span class="keyword">return</span> activiti5CompatibilityHandler.startProcessInstance(processDefinition.getKey(), processDefinition.getId(),</span><br><span class="line">                variables, businessKey, processDefinition.getTenantId(), processInstanceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not start process a process instance if the process definition is suspended</span></span><br><span class="line">    <span class="keyword">if</span> (ProcessDefinitionUtil.isProcessDefinitionSuspended(processDefinition.getId())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"Cannot start process instance. Process definition "</span> + processDefinition.getName() + <span class="string">" (id = "</span> + processDefinition.getId() + <span class="string">") is suspended"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get model from cache</span></span><br><span class="line">    Process process = ProcessDefinitionUtil.getProcess(processDefinition.getId());</span><br><span class="line">    <span class="keyword">if</span> (process == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"Cannot start process instance. Process model "</span> + processDefinition.getName() + <span class="string">" (id = "</span> + processDefinition.getId() + <span class="string">") could not be found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FlowElement initialFlowElement = process.getInitialFlowElement();</span><br><span class="line">    <span class="keyword">if</span> (initialFlowElement == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"No start element found for process definition "</span> + processDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createAndStartProcessInstanceWithInitialFlowElement(processDefinition, businessKey,</span><br><span class="line">            processInstanceName, initialFlowElement, process, variables, transientVariables, startProcessInstance);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>如果流程定义是 Activiti5 风格的, 执行 Activiti5 相关的兼容代码</li><li>如果流程定义已经被挂起, 那么抛出异常</li><li>根据 processDefinitionId 获取 Process 对象, 如果失败抛出异常</li><li>获取 Process 对象的 <code>initialFlowElement</code></li><li>创建并开启流程实例, 并返回结果</li></ol><h3 id="2-3-1-ProcessDefinitionUtil-getProcess-String-processDefinitionId"><a href="#2-3-1-ProcessDefinitionUtil-getProcess-String-processDefinitionId" class="headerlink" title="2.3.1. ProcessDefinitionUtil#getProcess(String processDefinitionId)"></a>2.3.1. ProcessDefinitionUtil#getProcess(String processDefinitionId)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Process <span class="title">getProcess</span><span class="params">(String processDefinitionId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Context.getProcessEngineConfiguration() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Activiti5Util.getActiviti5CompatibilityHandler().getProcessDefinitionProcessObject(processDefinitionId);</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DeploymentManager deploymentManager = Context.getProcessEngineConfiguration().getDeploymentManager();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// This will check the cache in the findDeployedProcessDefinitionById and resolveProcessDefinition method</span></span><br><span class="line">        ProcessDefinition processDefinitionEntity = deploymentManager.findDeployedProcessDefinitionById(processDefinitionId);</span><br><span class="line">        <span class="keyword">return</span> deploymentManager.resolveProcessDefinition(processDefinitionEntity).getProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-DeploymentManager-findDeployedProcessDefinitionById-String-processDefinitionId"><a href="#2-3-2-DeploymentManager-findDeployedProcessDefinitionById-String-processDefinitionId" class="headerlink" title="2.3.2. DeploymentManager#findDeployedProcessDefinitionById(String processDefinitionId)"></a>2.3.2. DeploymentManager#findDeployedProcessDefinitionById(String processDefinitionId)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessDefinition <span class="title">findDeployedProcessDefinitionById</span><span class="params">(String processDefinitionId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (processDefinitionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"Invalid process definition id : null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first try the cache</span></span><br><span class="line">    ProcessDefinitionCacheEntry cacheEntry = processDefinitionCache.get(processDefinitionId);</span><br><span class="line">    ProcessDefinition processDefinition = cacheEntry != <span class="keyword">null</span> ? cacheEntry.getProcessDefinition() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">        processDefinition = processDefinitionEntityManager.findById(processDefinitionId);</span><br><span class="line">        <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiObjectNotFoundException(<span class="string">"no deployed process definition found with id '"</span> + processDefinitionId + <span class="string">"'"</span>, ProcessDefinition.class);</span><br><span class="line">        &#125;</span><br><span class="line">        processDefinition = resolveProcessDefinition(processDefinition).getProcessDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先从缓存中查找</li><li>如果缓存没有, 继续从 DB 中查找</li><li>将 ProcessDefinition 转换为 Process 并返回</li></ol><h3 id="2-3-3-DeploymentManager-resolveProcessDefinition-ProcessDefinition-processDefinition"><a href="#2-3-3-DeploymentManager-resolveProcessDefinition-ProcessDefinition-processDefinition" class="headerlink" title="2.3.3. DeploymentManager#resolveProcessDefinition(ProcessDefinition processDefinition)"></a>2.3.3. DeploymentManager#resolveProcessDefinition(ProcessDefinition processDefinition)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessDefinitionCacheEntry <span class="title">resolveProcessDefinition</span><span class="params">(ProcessDefinition processDefinition)</span> </span>&#123;</span><br><span class="line">    String processDefinitionId = processDefinition.getId();</span><br><span class="line">    String deploymentId = processDefinition.getDeploymentId();</span><br><span class="line"></span><br><span class="line">    ProcessDefinitionCacheEntry cachedProcessDefinition = processDefinitionCache.get(processDefinitionId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cachedProcessDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CommandContext commandContext = Context.getCommandContext();</span><br><span class="line">        <span class="keyword">if</span> (commandContext.getProcessEngineConfiguration().isActiviti5CompatibilityEnabled() &amp;&amp; </span><br><span class="line">            Activiti5Util.isActiviti5ProcessDefinition(Context.getCommandContext(), processDefinition)) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> Activiti5Util.getActiviti5CompatibilityHandler().resolveProcessDefinition(processDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        DeploymentEntity deployment = deploymentEntityManager.findById(deploymentId);</span><br><span class="line">        deployment.setNew(<span class="keyword">false</span>);</span><br><span class="line">        deploy(deployment, <span class="keyword">null</span>);</span><br><span class="line">        cachedProcessDefinition = processDefinitionCache.get(processDefinitionId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cachedProcessDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"deployment '"</span> + deploymentId + <span class="string">"' didn't put process definition '"</span> + processDefinitionId + <span class="string">"' in the cache"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedProcessDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先尝试从缓存中获取流程定义<ol><li>如果为空<ol><li>如果是 Activiti5 风格的配置</li><li>通过 Activiti5 的方式获取并返回</li></ol></li><li>尝试从 DB 中获取, 补充到缓存中</li><li>再从缓存中获取</li><li>返回</li></ol></li></ol><h2 id="2-4-ProcessInstanceHelper-createAndStartProcessInstanceWithInitialFlowElement-ProcessDefinition-processDefinition-String-businessKey-String-processInstanceName-FlowElement-initialFlowElement-Process-process-Map-lt-String-Object-gt-variables-Map-lt-String-Object-gt-transientVariables-boolean-startProcessInstance"><a href="#2-4-ProcessInstanceHelper-createAndStartProcessInstanceWithInitialFlowElement-ProcessDefinition-processDefinition-String-businessKey-String-processInstanceName-FlowElement-initialFlowElement-Process-process-Map-lt-String-Object-gt-variables-Map-lt-String-Object-gt-transientVariables-boolean-startProcessInstance" class="headerlink" title="2.4. ProcessInstanceHelper#createAndStartProcessInstanceWithInitialFlowElement(ProcessDefinition processDefinition, String businessKey, String processInstanceName, FlowElement initialFlowElement, Process process, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance)"></a>2.4. ProcessInstanceHelper#createAndStartProcessInstanceWithInitialFlowElement(ProcessDefinition processDefinition, String businessKey, String processInstanceName, FlowElement initialFlowElement, Process process, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, boolean startProcessInstance)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessInstance <span class="title">createAndStartProcessInstanceWithInitialFlowElement</span><span class="params">(ProcessDefinition processDefinition,</span></span></span><br><span class="line"><span class="function"><span class="params">        String businessKey, String processInstanceName, FlowElement initialFlowElement,</span></span></span><br><span class="line"><span class="function"><span class="params">        Process process, Map&lt;String, Object&gt; variables, Map&lt;String, Object&gt; transientVariables, <span class="keyword">boolean</span> startProcessInstance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CommandContext commandContext = Context.getCommandContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the process instance</span></span><br><span class="line">    String initiatorVariableName = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialFlowElement <span class="keyword">instanceof</span> StartEvent) &#123;</span><br><span class="line">        initiatorVariableName = ((StartEvent) initialFlowElement).getInitiator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExecutionEntity processInstance = commandContext.getExecutionEntityManager()</span><br><span class="line">            .createProcessInstanceExecution(processDefinition, businessKey, processDefinition.getTenantId(), initiatorVariableName);</span><br><span class="line"></span><br><span class="line">    commandContext.getHistoryManager().recordProcessInstanceStart(processInstance, initialFlowElement);</span><br><span class="line"></span><br><span class="line">    processInstance.setVariables(processDataObjects(process.getDataObjects()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the variables passed into the start command</span></span><br><span class="line">    <span class="keyword">if</span> (variables != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String varName : variables.keySet()) &#123;</span><br><span class="line">            processInstance.setVariable(varName, variables.get(varName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (transientVariables != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String varName : transientVariables.keySet()) &#123;</span><br><span class="line">        processInstance.setTransientVariable(varName, transientVariables.get(varName));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set processInstance name</span></span><br><span class="line">    <span class="keyword">if</span> (processInstanceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processInstance.setName(processInstanceName);</span><br><span class="line">        commandContext.getHistoryManager().recordProcessInstanceNameChange(processInstance.getId(), processInstanceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fire events</span></span><br><span class="line">    <span class="keyword">if</span> (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">        Context.getProcessEngineConfiguration().getEventDispatcher()</span><br><span class="line">                .dispatchEvent(ActivitiEventBuilder.createEntityWithVariablesEvent(ActivitiEventType.ENTITY_INITIALIZED, processInstance, variables, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the first execution that will visit all the process definition elements</span></span><br><span class="line">    ExecutionEntity execution = commandContext.getExecutionEntityManager().createChildExecution(processInstance);</span><br><span class="line">    execution.setCurrentFlowElement(initialFlowElement);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (startProcessInstance) &#123;</span><br><span class="line">        startProcessInstance(processInstance, commandContext, variables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建流程实例(父级 Execution)</li><li>在历史流程表中将流程实例标记为开始</li><li>将所有 <code>DataObject</code> 转换为 Map&lt;String, Object&gt;, 并设置为流程实例的变量</li><li>将创建流程时填入的表单信息设置为变量</li><li>为流程变量设置名称</li><li>触发事件</li><li>创建第一个将访问所有流程定义元素的 <code>Execution</code></li><li>并将该 Execution 对象的当前元素设置为传入的初始化元素</li><li>如果需要立即开启<ol><li>调用开启流程实例方法</li></ol></li><li>返回该流程实例</li></ol><h3 id="2-4-1-ExecutionEntityManagerImpl-createProcessInstanceExecution-ProcessDefinition-processDefinition-String-businessKey-String-tenantId-String-initiatorVariableName"><a href="#2-4-1-ExecutionEntityManagerImpl-createProcessInstanceExecution-ProcessDefinition-processDefinition-String-businessKey-String-tenantId-String-initiatorVariableName" class="headerlink" title="2.4.1. ExecutionEntityManagerImpl#createProcessInstanceExecution(ProcessDefinition processDefinition, String businessKey, String tenantId, String initiatorVariableName)"></a>2.4.1. ExecutionEntityManagerImpl#createProcessInstanceExecution(ProcessDefinition processDefinition, String businessKey, String tenantId, String initiatorVariableName)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExecutionEntity <span class="title">createProcessInstanceExecution</span><span class="params">(ProcessDefinition processDefinition, String businessKey, String tenantId, String initiatorVariableName)</span> </span>&#123;</span><br><span class="line">    ExecutionEntity processInstanceExecution = executionDataManager.create();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isExecutionRelatedEntityCountEnabledGlobally()) &#123;</span><br><span class="line">        ((CountingExecutionEntity) processInstanceExecution).setCountEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    processInstanceExecution.setProcessDefinitionId(processDefinition.getId());</span><br><span class="line">    processInstanceExecution.setProcessDefinitionKey(processDefinition.getKey());</span><br><span class="line">    processInstanceExecution.setProcessDefinitionName(processDefinition.getName());</span><br><span class="line">    processInstanceExecution.setProcessDefinitionVersion(processDefinition.getVersion());</span><br><span class="line">    processInstanceExecution.setBusinessKey(businessKey);</span><br><span class="line">    processInstanceExecution.setScope(<span class="keyword">true</span>); <span class="comment">// process instance is always a scope for all child executions</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inherit tenant id (if any)</span></span><br><span class="line">    <span class="keyword">if</span> (tenantId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processInstanceExecution.setTenantId(tenantId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String authenticatedUserId = Authentication.getAuthenticatedUserId();</span><br><span class="line"></span><br><span class="line">    processInstanceExecution.setStartTime(Context.getProcessEngineConfiguration().getClock().getCurrentTime());</span><br><span class="line">    processInstanceExecution.setStartUserId(authenticatedUserId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store in database</span></span><br><span class="line">    insert(processInstanceExecution, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initiatorVariableName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processInstanceExecution.setVariable(initiatorVariableName, authenticatedUserId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to be after insert, cause we need the id</span></span><br><span class="line">    processInstanceExecution.setProcessInstanceId(processInstanceExecution.getId());</span><br><span class="line">    processInstanceExecution.setRootProcessInstanceId(processInstanceExecution.getId());</span><br><span class="line">    <span class="keyword">if</span> (authenticatedUserId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getIdentityLinkEntityManager().addIdentityLink(processInstanceExecution, authenticatedUserId, <span class="keyword">null</span>, IdentityLinkType.STARTER);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fire events</span></span><br><span class="line">    <span class="keyword">if</span> (getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">        getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, processInstanceExecution));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processInstanceExecution;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个新的 <code>ExecutionEntity</code> 对象并初始化</li><li>获取创建人 ID 和开始时间</li><li>插入该 <code>ExecutionEntity</code></li><li>触发事件</li></ol><h3 id="2-4-2-DefaultHistoryManager-recordProcessInstanceStart-ExecutionEntity-processInstance-FlowElement-startElement"><a href="#2-4-2-DefaultHistoryManager-recordProcessInstanceStart-ExecutionEntity-processInstance-FlowElement-startElement" class="headerlink" title="2.4.2. DefaultHistoryManager#recordProcessInstanceStart(ExecutionEntity processInstance, FlowElement startElement)"></a>2.4.2. DefaultHistoryManager#recordProcessInstanceStart(ExecutionEntity processInstance, FlowElement startElement)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordProcessInstanceStart</span><span class="params">(ExecutionEntity processInstance, FlowElement startElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isHistoryLevelAtLeast(HistoryLevel.ACTIVITY)) &#123;</span><br><span class="line">        HistoricProcessInstanceEntity historicProcessInstance = getHistoricProcessInstanceEntityManager().create(processInstance);</span><br><span class="line">        historicProcessInstance.setStartActivityId(startElement.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insert historic process-instance</span></span><br><span class="line">        getHistoricProcessInstanceEntityManager().insert(historicProcessInstance, <span class="keyword">false</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// Fire event</span></span><br><span class="line">        ActivitiEventDispatcher activitiEventDispatcher = getEventDispatcher();</span><br><span class="line">        <span class="keyword">if</span> (activitiEventDispatcher != <span class="keyword">null</span> &amp;&amp; activitiEventDispatcher.isEnabled()) &#123;</span><br><span class="line">            activitiEventDispatcher.dispatchEvent(</span><br><span class="line">                    ActivitiEventBuilder.createEntityEvent(ActivitiEventType.HISTORIC_PROCESS_INSTANCE_CREATED, historicProcessInstance));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据传入的 <code>processInstance</code> 构造 <code>HistoricProcessInstanceEntity</code> 对象</li><li>向历史表插入该对象</li><li>将给定的事件分派给任何已注册的侦听器</li></ol><h3 id="2-4-3-ExecutionEntityManagerImpl-createChildExecution-ExecutionEntity-parentExecutionEntity"><a href="#2-4-3-ExecutionEntityManagerImpl-createChildExecution-ExecutionEntity-parentExecutionEntity" class="headerlink" title="2.4.3. ExecutionEntityManagerImpl#createChildExecution(ExecutionEntity parentExecutionEntity)"></a>2.4.3. ExecutionEntityManagerImpl#createChildExecution(ExecutionEntity parentExecutionEntity)</h3><p>创建第一个将访问所有流程定义元素的执行对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExecutionEntity <span class="title">createChildExecution</span><span class="params">(ExecutionEntity parentExecutionEntity)</span> </span>&#123;</span><br><span class="line">    ExecutionEntity childExecution = executionDataManager.create();</span><br><span class="line">    inheritCommonProperties(parentExecutionEntity, childExecution);</span><br><span class="line">    childExecution.setParent(parentExecutionEntity);</span><br><span class="line">    childExecution.setProcessDefinitionId(parentExecutionEntity.getProcessDefinitionId());</span><br><span class="line">    childExecution.setProcessDefinitionKey(parentExecutionEntity.getProcessDefinitionKey());</span><br><span class="line">    childExecution.setProcessInstanceId(parentExecutionEntity.getProcessInstanceId() != <span class="keyword">null</span> </span><br><span class="line">            ? parentExecutionEntity.getProcessInstanceId() : parentExecutionEntity.getId());</span><br><span class="line">    childExecution.setScope(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// manage the bidirectional parent-child relation</span></span><br><span class="line">    parentExecutionEntity.addChildExecution(childExecution);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Insert the child execution</span></span><br><span class="line">    insert(childExecution, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Child execution &#123;&#125; created with parent &#123;&#125;"</span>, childExecution, parentExecutionEntity.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">        getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, childExecution));</span><br><span class="line">        getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_INITIALIZED, childExecution));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> childExecution;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个新的 <code>ExecutionEntity</code> 对象, 并继承父 ExecutionEntity 的公共配置</li><li>设置父子关系</li><li>插入子 ExecutionEntity</li><li>将指定事件分派给已注册的监听器</li></ol><h3 id="2-4-4-ExecutionEntityManagerImpl-startProcessInstance-ExecutionEntity-processInstance-CommandContext-commandContext-Map-lt-String-Object-gt-variables"><a href="#2-4-4-ExecutionEntityManagerImpl-startProcessInstance-ExecutionEntity-processInstance-CommandContext-commandContext-Map-lt-String-Object-gt-variables" class="headerlink" title="2.4.4. ExecutionEntityManagerImpl#startProcessInstance(ExecutionEntity processInstance, CommandContext commandContext, Map&lt;String, Object&gt; variables)"></a>2.4.4. ExecutionEntityManagerImpl#startProcessInstance(ExecutionEntity processInstance, CommandContext commandContext, Map&lt;String, Object&gt; variables)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcessInstance</span><span class="params">(ExecutionEntity processInstance, CommandContext commandContext, Map&lt;String, Object&gt; variables)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Process process = ProcessDefinitionUtil.getProcess(processInstance.getProcessDefinitionId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Event sub process handling</span></span><br><span class="line">    List&lt;MessageEventSubscriptionEntity&gt; messageEventSubscriptions = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (FlowElement flowElement : process.getFlowElements()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowElement <span class="keyword">instanceof</span> EventSubProcess) &#123;</span><br><span class="line">            EventSubProcess eventSubProcess = (EventSubProcess) flowElement;</span><br><span class="line">            <span class="keyword">for</span> (FlowElement subElement : eventSubProcess.getFlowElements()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (subElement <span class="keyword">instanceof</span> StartEvent) &#123;</span><br><span class="line">                    StartEvent startEvent = (StartEvent) subElement;</span><br><span class="line">                    <span class="keyword">if</span> (CollectionUtil.isNotEmpty(startEvent.getEventDefinitions())) &#123;</span><br><span class="line">                        EventDefinition eventDefinition = startEvent.getEventDefinitions().get(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (eventDefinition <span class="keyword">instanceof</span> MessageEventDefinition) &#123;</span><br><span class="line">                            MessageEventDefinition messageEventDefinition = (MessageEventDefinition) eventDefinition;</span><br><span class="line">                            BpmnModel bpmnModel = ProcessDefinitionUtil.getBpmnModel(processInstance.getProcessDefinitionId());</span><br><span class="line">                            <span class="keyword">if</span> (bpmnModel.containsMessageId(messageEventDefinition.getMessageRef())) &#123;</span><br><span class="line">                                messageEventDefinition.setMessageRef(bpmnModel.getMessage(messageEventDefinition.getMessageRef()).getName());</span><br><span class="line">                            &#125;</span><br><span class="line">                            ExecutionEntity messageExecution = commandContext.getExecutionEntityManager().createChildExecution(processInstance);</span><br><span class="line">                            messageExecution.setCurrentFlowElement(startEvent);</span><br><span class="line">                            messageExecution.setEventScope(<span class="keyword">true</span>);</span><br><span class="line">                            messageEventSubscriptions</span><br><span class="line">                                    .add(commandContext.getEventSubscriptionEntityManager().insertMessageEvent(messageEventDefinition.getMessageRef(), messageExecution));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ExecutionEntity execution = processInstance.getExecutions().get(<span class="number">0</span>); <span class="comment">// There will always be one child execution created</span></span><br><span class="line">    commandContext.getAgenda().planContinueProcessOperation(execution);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">    ActivitiEventDispatcher eventDispatcher = Context.getProcessEngineConfiguration().getEventDispatcher();</span><br><span class="line">        eventDispatcher.dispatchEvent(ActivitiEventBuilder.createProcessStartedEvent(execution, variables, <span class="keyword">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (MessageEventSubscriptionEntity messageEventSubscription : messageEventSubscriptions) &#123;</span><br><span class="line">            commandContext.getProcessEngineConfiguration().getEventDispatcher()</span><br><span class="line">                    .dispatchEvent(ActivitiEventBuilder.createMessageEvent(ActivitiEventType.ACTIVITY_MESSAGE_WAITING, messageEventSubscription.getActivityId(),</span><br><span class="line">                            messageEventSubscription.getEventName(), <span class="keyword">null</span>, messageEventSubscription.getExecution().getId(),</span><br><span class="line">                            messageEventSubscription.getProcessInstanceId(), messageEventSubscription.getProcessDefinitionId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取流程对象</li><li>找到所有的子流程的开始事件, 并查找开始事件的事件定义来收集所有的消息事件</li><li>获取当前 ExecutionEntity 的第一个子对象, 并由该子对象开始执行</li><li>开始流程后, 继续进行将给定的事件分派给任何已注册的侦听器的操作</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-启动流程&quot;&gt;&lt;a href=&quot;#1-1-启动流程&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/categories/Activiti/"/>
    
      <category term="源码" scheme="https://destinywang.github.io/blog/categories/Activiti/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Activiti" scheme="https://destinywang.github.io/blog/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(6)--RepositoryService(仓库服务类)模型校验</title>
    <link href="https://destinywang.github.io/blog/2019/03/09/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-RepositoryService-%E4%BB%93%E5%BA%93%E6%9C%8D%E5%8A%A1%E7%B1%BB-%E6%A8%A1%E5%9E%8B%E6%A0%A1%E9%AA%8C/"/>
    <id>https://destinywang.github.io/blog/2019/03/09/Activiti源码分析-6-RepositoryService-仓库服务类-模型校验/</id>
    <published>2019-03-09T05:38:16.000Z</published>
    <updated>2019-03-09T06:31:00.160Z</updated>
    
    <content type="html"><![CDATA[<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBpmnModel</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        BpmnModel bpmnModel = <span class="keyword">new</span> BpmnModel();</span><br><span class="line">        Process process = <span class="keyword">new</span> Process();</span><br><span class="line">        process.setId(<span class="string">"my-process"</span>);</span><br><span class="line"></span><br><span class="line">        StartEvent startEvent = <span class="keyword">new</span> StartEvent();</span><br><span class="line">        startEvent.setId(<span class="string">"startEvent"</span>);</span><br><span class="line"></span><br><span class="line">        UserTask someTask = <span class="keyword">new</span> UserTask();</span><br><span class="line">        someTask.setId(<span class="string">"someTask"</span>);</span><br><span class="line">        someTask.setName(<span class="string">"Activiti is awesome!"</span>);</span><br><span class="line">        someTask.setAssignee(<span class="string">"$&#123;user&#125;"</span>);</span><br><span class="line">        MultiInstanceLoopCharacteristics multiInstanceLoopCharacteristics = <span class="keyword">new</span> MultiInstanceLoopCharacteristics();</span><br><span class="line">        multiInstanceLoopCharacteristics.setSequential(<span class="keyword">false</span>);</span><br><span class="line">        multiInstanceLoopCharacteristics.setInputDataItem(<span class="string">"$&#123;usersBean.getUsers(name)&#125;"</span>);</span><br><span class="line">        multiInstanceLoopCharacteristics.setElementVariable(<span class="string">"user"</span>);</span><br><span class="line">        multiInstanceLoopCharacteristics.setCompletionCondition(<span class="string">"$&#123;nrOfCompletedInstances &gt; 0&#125;"</span>);</span><br><span class="line"></span><br><span class="line">        someTask.setLoopCharacteristics(multiInstanceLoopCharacteristics);</span><br><span class="line"></span><br><span class="line">        EndEvent endEvent = <span class="keyword">new</span> EndEvent();</span><br><span class="line">        endEvent.setId(<span class="string">"endEvent"</span>);</span><br><span class="line"></span><br><span class="line">        SequenceFlow flow1 = createSequence(<span class="string">"startEvent"</span>, <span class="string">"someTask"</span>, <span class="string">"flow1"</span>, <span class="string">"flow1"</span>, <span class="keyword">null</span>);</span><br><span class="line">        SequenceFlow flow2 = createSequence(<span class="string">"someTask"</span>, <span class="string">"endEvent"</span>, <span class="string">"flow2"</span>, <span class="string">"flow2"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        process.addFlowElement(startEvent);</span><br><span class="line">        process.addFlowElement(someTask);</span><br><span class="line">        process.addFlowElement(endEvent);</span><br><span class="line">        process.addFlowElement(flow1);</span><br><span class="line">        process.addFlowElement(flow2);</span><br><span class="line"></span><br><span class="line">        bpmnModel.addProcess(process);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> BpmnXMLConverter().convertToXML(bpmnModel);</span><br><span class="line">        String s = <span class="keyword">new</span> String(bytes, <span class="string">"utf-8"</span>);</span><br><span class="line">        log.info(s);</span><br><span class="line"></span><br><span class="line">        ProcessValidatorFactory processValidatorFactory = <span class="keyword">new</span> ProcessValidatorFactory();</span><br><span class="line">        ProcessValidator defaultProcessValidator = processValidatorFactory.createDefaultProcessValidator();</span><br><span class="line">        List&lt;ValidationError&gt; validate = defaultProcessValidator.validate(bpmnModel);</span><br><span class="line">        log.info(<span class="string">"validate: &#123;&#125;"</span>, validate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成的-XMl-文件"><a href="#生成的-XMl-文件" class="headerlink" title="生成的 XMl 文件:"></a>生成的 XMl 文件:</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/MODEL"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:activiti</span>=<span class="string">"http://activiti.org/bpmn"</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">"http://www.omg.org/spec/BPMN/20100524/DI"</span> <span class="attr">xmlns:omgdc</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DC"</span> <span class="attr">xmlns:omgdi</span>=<span class="string">"http://www.omg.org/spec/DD/20100524/DI"</span> <span class="attr">typeLanguage</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">expressionLanguage</span>=<span class="string">"http://www.w3.org/1999/XPath"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://www.activiti.org/test"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">"my-process"</span> <span class="attr">isExecutable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">"startEvent"</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">"someTask"</span> <span class="attr">name</span>=<span class="string">"Activiti is awesome!"</span> <span class="attr">activiti:assignee</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">multiInstanceLoopCharacteristics</span> <span class="attr">isSequential</span>=<span class="string">"false"</span> <span class="attr">activiti:collection</span>=<span class="string">"$&#123;usersBean.getUsers(name)&#125;"</span> <span class="attr">activiti:elementVariable</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">completionCondition</span>&gt;</span>$&#123;nrOfCompletedInstances &amp;gt; 0&#125;<span class="tag">&lt;/<span class="name">completionCondition</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">multiInstanceLoopCharacteristics</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">"endEvent"</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow1"</span> <span class="attr">name</span>=<span class="string">"flow1"</span> <span class="attr">sourceRef</span>=<span class="string">"startEvent"</span> <span class="attr">targetRef</span>=<span class="string">"someTask"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">"flow2"</span> <span class="attr">name</span>=<span class="string">"flow2"</span> <span class="attr">sourceRef</span>=<span class="string">"someTask"</span> <span class="attr">targetRef</span>=<span class="string">"endEvent"</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">"BPMNDiagram_my-process"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">"my-process"</span> <span class="attr">id</span>=<span class="string">"BPMNPlane_my-process"</span>&gt;</span><span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="validate-的结果"><a href="#validate-的结果" class="headerlink" title="validate 的结果"></a>validate 的结果</h4><pre><code>validate: []</code></pre><p>代表当前流程正常, 没有错误</p><h1 id="1-ProcessValidatorFactory-createDefaultProcessValidator"><a href="#1-ProcessValidatorFactory-createDefaultProcessValidator" class="headerlink" title="1. ProcessValidatorFactory#createDefaultProcessValidator()"></a>1. ProcessValidatorFactory#createDefaultProcessValidator()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessValidator <span class="title">createDefaultProcessValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProcessValidatorImpl processValidator = <span class="keyword">new</span> ProcessValidatorImpl();</span><br><span class="line">    processValidator.addValidatorSet(<span class="keyword">new</span> ValidatorSetFactory().createActivitiExecutableProcessValidatorSet());</span><br><span class="line">    <span class="keyword">return</span> processValidator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;测试代码&quot;&gt;&lt;a href=&quot;#测试代码&quot; class=&quot;headerlink&quot; title=&quot;测试代码&quot;&gt;&lt;/a&gt;测试代码&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(5)--RepositoryService(仓库服务类)classpath资源部署</title>
    <link href="https://destinywang.github.io/blog/2019/03/09/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-RepositoryService-%E4%BB%93%E5%BA%93%E6%9C%8D%E5%8A%A1%E7%B1%BB-classpath%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/"/>
    <id>https://destinywang.github.io/blog/2019/03/09/Activiti源码分析-5-RepositoryService-仓库服务类-classpath资源部署/</id>
    <published>2019-03-09T04:29:31.000Z</published>
    <updated>2019-03-09T08:31:21.248Z</updated>
    
    <content type="html"><![CDATA[<p>RepositoryService 是 Activiti 的仓库服务类, 仓库指的是流程定义文档的两个文件: BPMN 文件和流程图片</p><p>获得方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RepositoryService repositoryService = processEngine.getRepositoryService();</span><br></pre></td></tr></table></figure><ul><li>其实现类为: RepositoryServiceImpl</li><li>可以产生 DeploymentBuilder, 用来产生定义流程部署的相关参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployment deployment = repositoryService.createDeployment();</span><br></pre></td></tr></table></figure><h1 id="1-classpath-部署方式说明"><a href="#1-classpath-部署方式说明" class="headerlink" title="1. classpath 部署方式说明"></a>1. classpath 部署方式说明</h1><ol><li>先获取流程引擎对象, 在创建时会自动加载 classpath 下的 <code>activiti.cfg.xml</code></li><li>首先获得默认的流程引擎, 通过流程引擎获取一个 RepositoryService 对象</li><li>由仓库的服务对象产生一个部署对象配置对象, 用来封装部署操作的相关配置</li><li>链式编程, 在部署的配置对象中设置显示名, 上传流程定义规则文件</li><li>向数据库中存放流程定义的规则信息</li></ol><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    Deployment deployment = processEngine.getRepositoryService()</span><br><span class="line">            .createDeployment()</span><br><span class="line">            .name(<span class="string">"my-process"</span>)</span><br><span class="line">            .addClasspathResource(<span class="string">"process/my-process.bpmn20.xml"</span>)</span><br><span class="line">            .deploy();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"deployment: &#123;&#125;"</span>, deployment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-DeploymentBuilderImpl-addClasspathResource-String-resource"><a href="#1-1-DeploymentBuilderImpl-addClasspathResource-String-resource" class="headerlink" title="1.1. DeploymentBuilderImpl#addClasspathResource(String resource)"></a>1.1. DeploymentBuilderImpl#addClasspathResource(String resource)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DeploymentBuilder <span class="title">addClasspathResource</span><span class="params">(String resource)</span> </span>&#123;</span><br><span class="line">    InputStream inputStream = ReflectUtil.getResourceAsStream(resource);</span><br><span class="line">    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"resource '"</span> + resource + <span class="string">"' not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addInputStream(resource, inputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过资源路径获取输入流</li><li>添加输入流并返回</li></ul><h3 id="1-1-1-ReflectUtil-getResourceAsStream-String-name"><a href="#1-1-1-ReflectUtil-getResourceAsStream-String-name" class="headerlink" title="1.1.1. ReflectUtil.getResourceAsStream(String name)"></a>1.1.1. ReflectUtil.getResourceAsStream(String name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    InputStream resourceStream = <span class="keyword">null</span>;</span><br><span class="line">    ClassLoader classLoader = getCustomClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resourceStream = classLoader.getResourceAsStream(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Try the current Thread context classloader</span></span><br><span class="line">        classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        resourceStream = classLoader.getResourceAsStream(name);</span><br><span class="line">        <span class="keyword">if</span> (resourceStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Finally, try the classloader for this class</span></span><br><span class="line">            classLoader = ReflectUtil.class.getClassLoader();</span><br><span class="line">            resourceStream = classLoader.getResourceAsStream(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resourceStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取自定义类加载器</li><li>如果类加载器不为空, 获取 classpath 路径下的资源</li><li>如果资源为空, 重新获取当前线程的类加载器, 再次尝试获取 classpath 下的资源</li><li>如果资源依然为空, 再获取当前类的类加载器再次尝试获取 classpath 下的资源</li><li>返回 </li></ol><h2 id="1-2-DeploymentBuilderImpl-addInputStream-String-resourceName-InputStream-inputStream"><a href="#1-2-DeploymentBuilderImpl-addInputStream-String-resourceName-InputStream-inputStream" class="headerlink" title="1.2. DeploymentBuilderImpl#addInputStream(String resourceName, InputStream inputStream)"></a>1.2. DeploymentBuilderImpl#addInputStream(String resourceName, InputStream inputStream)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DeploymentBuilder <span class="title">addInputStream</span><span class="params">(String resourceName, InputStream inputStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"inputStream for resource '"</span> + resourceName + <span class="string">"' is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = IoUtil.readInputStream(inputStream, resourceName);</span><br><span class="line">    ResourceEntity resource = resourceEntityManager.create();</span><br><span class="line">    resource.setName(resourceName);</span><br><span class="line">    resource.setBytes(bytes);</span><br><span class="line">    deployment.addResource(resource);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将输入流转化为字节数组</li><li>创建一个 ResourceEntity 实例对象, 并设置名称和字节数组</li><li>为 <code>deployment</code> 对象添加资源, 其内部包含一个 <code>Map&lt;String, ResourceEntity&gt;</code> 的属性</li><li>返回当前对象(DeploymentBuilder)</li></ol><h3 id="1-2-1-IoUtil-readInputStream-InputStream-inputStream-String-inputStreamName"><a href="#1-2-1-IoUtil-readInputStream-InputStream-inputStream-String-inputStreamName" class="headerlink" title="1.2.1. IoUtil#readInputStream(InputStream inputStream, String inputStreamName)"></a>1.2.1. IoUtil#readInputStream(InputStream inputStream, String inputStreamName)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readInputStream(InputStream inputStream, String inputStreamName) &#123;</span><br><span class="line">    ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> bytesRead = inputStream.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">            outputStream.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            bytesRead = inputStream.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"couldn't read input stream "</span> + inputStreamName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outputStream.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-DeploymentEntityImpl-addResource-ResourceEntity-resource"><a href="#1-3-DeploymentEntityImpl-addResource-ResourceEntity-resource" class="headerlink" title="1.3. DeploymentEntityImpl#addResource(ResourceEntity resource)"></a>1.3. DeploymentEntityImpl#addResource(ResourceEntity resource)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResource</span><span class="params">(ResourceEntity resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        resources = <span class="keyword">new</span> HashMap&lt;String, ResourceEntity&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    resources.put(resource.getName(), resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-4-RepositoryServiceImpl-deploy"><a href="#1-4-RepositoryServiceImpl-deploy" class="headerlink" title="1.4. RepositoryServiceImpl#deploy()"></a>1.4. RepositoryServiceImpl#deploy()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Deployment <span class="title">deploy</span><span class="params">(DeploymentBuilderImpl deploymentBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.execute(<span class="keyword">new</span> DeployCmd&lt;Deployment&gt;(deploymentBuilder));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-DeployCmd-execute-CommandContext-commandContext"><a href="#1-5-DeployCmd-execute-CommandContext-commandContext" class="headerlink" title="1.5. DeployCmd#execute(CommandContext commandContext)"></a>1.5. DeployCmd#execute(CommandContext commandContext)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Deployment <span class="title">execute</span><span class="params">(CommandContext commandContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backwards compatibility with Activiti v5</span></span><br><span class="line">    <span class="keyword">if</span> (commandContext.getProcessEngineConfiguration().isActiviti5CompatibilityEnabled()</span><br><span class="line">        &amp;&amp; deploymentBuilder.getDeploymentProperties() != <span class="keyword">null</span> </span><br><span class="line">        &amp;&amp; deploymentBuilder.getDeploymentProperties().containsKey(DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION)</span><br><span class="line">        &amp;&amp; deploymentBuilder.getDeploymentProperties().get(DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION).equals(Boolean.TRUE)) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> deployAsActiviti5ProcessDefinition(commandContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executeDeploy(commandContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-DeployCmd-executeDeploy-CommandContext-commandContext"><a href="#1-6-DeployCmd-executeDeploy-CommandContext-commandContext" class="headerlink" title="1.6. DeployCmd#executeDeploy(CommandContext commandContext)"></a>1.6. DeployCmd#executeDeploy(CommandContext commandContext)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Deployment <span class="title">executeDeploy</span><span class="params">(CommandContext commandContext)</span> </span>&#123;</span><br><span class="line">    DeploymentEntity deployment = deploymentBuilder.getDeployment();</span><br><span class="line"></span><br><span class="line">    deployment.setDeploymentTime(commandContext.getProcessEngineConfiguration().getClock().getCurrentTime());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deploymentBuilder.isDuplicateFilterEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Deployment&gt; existingDeployments = <span class="keyword">new</span> ArrayList&lt;Deployment&gt;();</span><br><span class="line">        <span class="keyword">if</span> (deployment.getTenantId() == <span class="keyword">null</span> || ProcessEngineConfiguration.NO_TENANT_ID.equals(deployment.getTenantId())) &#123;</span><br><span class="line">            DeploymentEntity existingDeployment = commandContext.getDeploymentEntityManager().findLatestDeploymentByName(deployment.getName());</span><br><span class="line">            <span class="keyword">if</span> (existingDeployment != <span class="keyword">null</span>) &#123;</span><br><span class="line">                existingDeployments.add(existingDeployment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Deployment&gt; deploymentList = commandContext.getProcessEngineConfiguration().getRepositoryService().createDeploymentQuery().deploymentName(deployment.getName())</span><br><span class="line">                    .deploymentTenantId(deployment.getTenantId()).orderByDeploymentId().desc().list();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!deploymentList.isEmpty()) &#123;</span><br><span class="line">                existingDeployments.addAll(deploymentList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DeploymentEntity existingDeployment = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!existingDeployments.isEmpty()) &#123;</span><br><span class="line">            existingDeployment = (DeploymentEntity) existingDeployments.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((existingDeployment != <span class="keyword">null</span>) &amp;&amp; !deploymentsDiffer(deployment, existingDeployment)) &#123;</span><br><span class="line">            <span class="keyword">return</span> existingDeployment;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deployment.setNew(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the data</span></span><br><span class="line">    commandContext.getDeploymentEntityManager().insert(deployment);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commandContext.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">        commandContext.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, deployment));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deployment settings</span></span><br><span class="line">    Map&lt;String, Object&gt; deploymentSettings = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    deploymentSettings.put(DeploymentSettings.IS_BPMN20_XSD_VALIDATION_ENABLED, deploymentBuilder.isBpmn20XsdValidationEnabled());</span><br><span class="line">    deploymentSettings.put(DeploymentSettings.IS_PROCESS_VALIDATION_ENABLED, deploymentBuilder.isProcessValidationEnabled());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actually deploy</span></span><br><span class="line">    commandContext.getProcessEngineConfiguration().getDeploymentManager().deploy(deployment, deploymentSettings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deploymentBuilder.getProcessDefinitionsActivationDate() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheduleProcessDefinitionActivation(commandContext, deployment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commandContext.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">        commandContext.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_INITIALIZED, deployment));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deployment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>设置部署时间</li><li></li></ol><h1 id="2-资源部署涉及到的表"><a href="#2-资源部署涉及到的表" class="headerlink" title="2. 资源部署涉及到的表"></a>2. 资源部署涉及到的表</h1><ol><li>ACT_RE_DEPLOYMENT: 存放流程定义的显示名称和部署时间, 每部署一次增加一条记录;</li><li>ACT_RE_PROCDEF: 流程定义表, 存放流程定义的属性信息, 部署每个新的流程定义都会在这张表中增加一条记录, 当流程定义的 key 相同的时候, 使用的是版本升级</li><li>ACT_GE_BYTEARRAY: 资源文件表, 存储流程定义相关的二进制文件, 包括 XML 和图片.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RepositoryService 是 Activiti 的仓库服务类, 仓库指的是流程定义文档的两个文件: BPMN 文件和流程图片&lt;/p&gt;
&lt;p&gt;获得方式:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(4)--CommandExecutor(命令执行器)</title>
    <link href="https://destinywang.github.io/blog/2019/02/21/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-CommandExecutor-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>https://destinywang.github.io/blog/2019/02/21/Activiti源码分析-4-CommandExecutor-命令执行器/</id>
    <published>2019-02-21T15:01:25.000Z</published>
    <updated>2019-03-09T02:44:39.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-commandExecutor-对象的构造"><a href="#1-commandExecutor-对象的构造" class="headerlink" title="1. commandExecutor 对象的构造"></a>1. commandExecutor 对象的构造</h1><h2 id="1-1-ProcessEngineConfigurationImpl-ProcessEngineConfigurationImpl"><a href="#1-1-ProcessEngineConfigurationImpl-ProcessEngineConfigurationImpl" class="headerlink" title="1.1. ProcessEngineConfigurationImpl#ProcessEngineConfigurationImpl()"></a>1.1. ProcessEngineConfigurationImpl#ProcessEngineConfigurationImpl()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCommandExecutors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initDefaultCommandConfig();</span><br><span class="line">    initSchemaCommandConfig();</span><br><span class="line">    initCommandInvoker();</span><br><span class="line">    initCommandInterceptors();</span><br><span class="line">    initCommandExecutor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法由 <code>ProcessEngineConfigurationImpl#init()</code> 调用, init 在创建 ProcessEngineConfigurationImpl 对象的时候已经分析过</p><ul><li>第 5 行, 初始化命令拦截器</li><li>第 6 行, 初始化命令执行器</li></ul><h3 id="1-1-1-initCommandInterceptors-方法"><a href="#1-1-1-initCommandInterceptors-方法" class="headerlink" title="1.1.1. initCommandInterceptors() 方法"></a>1.1.1. initCommandInterceptors() 方法</h3><p>Activiti 提供了命令拦截器的功能, 通过 API 对 Activiti 流程各个实例的操作本质上都是对 DB 的操作. 因此 Activiti 将每一个 CRUD 操作都封装为一个 <code>Command</code>, 然后交由命令执行器 <code>CommandExecutor</code> 去执行. </p><p>为了能让使用者可以对命令进行拦截, Activiti 还是用了 <code>责任链模式</code>, 使用者可以在其中添加相应的拦截器. 职责链让多个对象都有机会处理请求, 从而避免了请求发送者和接受者之间的耦合, 这些请求接受者将组成一条链, 并沿着这条链传递下去, 直到有一个对象处理了这个请求为止.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCommandInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (commandInterceptors == <span class="keyword">null</span>) &#123;</span><br><span class="line">        commandInterceptors = <span class="keyword">new</span> ArrayList&lt;CommandInterceptor&gt;();</span><br><span class="line">        <span class="keyword">if</span> (customPreCommandInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            commandInterceptors.addAll(customPreCommandInterceptors);</span><br><span class="line">        &#125;</span><br><span class="line">        commandInterceptors.addAll(getDefaultCommandInterceptors());</span><br><span class="line">        <span class="keyword">if</span> (customPostCommandInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            commandInterceptors.addAll(customPostCommandInterceptors);</span><br><span class="line">        &#125;</span><br><span class="line">        commandInterceptors.add(commandInvoker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法完成对所有拦截器的初始化 </p><ul><li>自定义前置拦截器: 需要开发者实现 <code>CommandInterceptor</code> 接口, 并配置到 Activiti 配置文件(<code>activiti.cfg.xml</code>)中</li><li>默认的拦截器:<ol><li>LogInterceptor: 日志拦截器, 用于打印执行的日志</li><li>TransactionInterceptor: 事务拦截器</li><li>CommandContextInterceptor: 命令上下文拦截器</li></ol></li><li>自定义后置拦截器: 需要开发者实现 <code>CommandInterceptor</code> 接口, 并配置到 Activiti 配置文件中.</li></ul><h3 id="1-1-2-getDefaultCommandInterceptors"><a href="#1-1-2-getDefaultCommandInterceptors" class="headerlink" title="1.1.2. getDefaultCommandInterceptors()"></a>1.1.2. getDefaultCommandInterceptors()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;? extends CommandInterceptor&gt; getDefaultCommandInterceptors() &#123;</span><br><span class="line">    List&lt;CommandInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;CommandInterceptor&gt;();</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> LogInterceptor());</span><br><span class="line"></span><br><span class="line">    CommandInterceptor transactionInterceptor = createTransactionInterceptor();</span><br><span class="line">    <span class="keyword">if</span> (transactionInterceptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptors.add(transactionInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commandContextFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> CommandContextInterceptor(commandContextFactory, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionContextFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> TransactionContextInterceptor(transactionContextFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> interceptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-ProcessEngineConfigurationImpl-initCommandExecutor"><a href="#1-2-ProcessEngineConfigurationImpl-initCommandExecutor" class="headerlink" title="1.2. ProcessEngineConfigurationImpl#initCommandExecutor()"></a>1.2. ProcessEngineConfigurationImpl#initCommandExecutor()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCommandExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (commandExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      CommandInterceptor first = initInterceptorChain(commandInterceptors);</span><br><span class="line">      commandExecutor = <span class="keyword">new</span> CommandExecutorImpl(getDefaultCommandConfig(), first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将命令拦截器列表初始化为职责链</li><li>色织第一个拦截器</li></ul><h2 id="1-2-1-ProcessEngineConfigurationImpl-initInterceptorChain-List-chain"><a href="#1-2-1-ProcessEngineConfigurationImpl-initInterceptorChain-List-chain" class="headerlink" title="1.2.1 ProcessEngineConfigurationImpl#initInterceptorChain(List chain)"></a>1.2.1 ProcessEngineConfigurationImpl#initInterceptorChain(List<commandinterceptor> chain)</commandinterceptor></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CommandInterceptor <span class="title">initInterceptorChain</span><span class="params">(List&lt;CommandInterceptor&gt; chain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span> || chain.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"invalid command interceptor chain configuration: "</span> + chain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chain.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        chain.get(i).setNext(chain.get(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化命令拦截器链, 并返回其中的第一个拦截器</p><p><img src="https://user-images.githubusercontent.com/17758731/54065183-e995b000-4257-11e9-9005-4a4f5f6ae568.png" alt="image"></p><h1 id="2-ProcessEngineConfigurationImpl-initService-Object-service"><a href="#2-ProcessEngineConfigurationImpl-initService-Object-service" class="headerlink" title="2. ProcessEngineConfigurationImpl#initService(Object service)"></a>2. ProcessEngineConfigurationImpl#initService(Object service)</h1><p>在各个服务对象(如 <code>RuntimeService</code>, <code>RepositoryService</code>等)中, 都可以直接使用 CommandExecutor 来执行命令<br>commandExecutor 对象由 RepositoryServiceImpl 的基类 <code>ServiceImpl</code> 声明</p><p>在 ProcessEngineConfigurationImpl 类的 initService(Object service) 方法中完成各个服务类的属性注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initService</span><span class="params">(Object service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service <span class="keyword">instanceof</span> ServiceImpl) &#123;</span><br><span class="line">        ((ServiceImpl) service).setCommandExecutor(commandExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-commandExecutor-对象的构造&quot;&gt;&lt;a href=&quot;#1-commandExecutor-对象的构造&quot; class=&quot;headerlink&quot; title=&quot;1. commandExecutor 对象的构造&quot;&gt;&lt;/a&gt;1. commandExecut
      
    
    </summary>
    
      <category term="activiti" scheme="https://destinywang.github.io/blog/categories/activiti/"/>
    
      <category term="源码" scheme="https://destinywang.github.io/blog/categories/activiti/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="activiti" scheme="https://destinywang.github.io/blog/tags/activiti/"/>
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(3)--Spring配置风格源码分析1</title>
    <link href="https://destinywang.github.io/blog/2019/02/20/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-Spring%E9%85%8D%E7%BD%AE%E9%A3%8E%E6%A0%BC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"/>
    <id>https://destinywang.github.io/blog/2019/02/20/Activiti源码分析-3-Spring配置风格源码分析1/</id>
    <published>2019-02-20T14:01:01.000Z</published>
    <updated>2019-02-20T15:25:32.556Z</updated>
    
    <content type="html"><![CDATA[<p>在分析源码之前, 先贴出一个典型的 Activiti 与 Spring 整合的配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 ProcessEngineConfiguration  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"processEngineConfiguration"</span> <span class="attr">class</span>=<span class="string">"org.activiti.spring.SpringProcessEngineConfiguration"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring 需要单独配置 DataSource --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"databaseSchemaUpdate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"org.h2.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:h2:mem:activiti"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"sa"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 流程引擎对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"processEngine"</span> <span class="attr">class</span>=<span class="string">"org.activiti.spring.ProcessEngineFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"processEngineConfiguration"</span> <span class="attr">ref</span>=<span class="string">"processEngineConfiguration"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将服务暴露给 Spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runtimeService"</span> <span class="attr">factory-bean</span>=<span class="string">"processEngine"</span> <span class="attr">factory-method</span>=<span class="string">"getRuntimeService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"repositoryService"</span> <span class="attr">factory-bean</span>=<span class="string">"processEngine"</span> <span class="attr">factory-method</span>=<span class="string">"getRepositoryService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formService"</span> <span class="attr">factory-bean</span>=<span class="string">"processEngine"</span> <span class="attr">factory-method</span>=<span class="string">"getFormService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taskService"</span> <span class="attr">factory-bean</span>=<span class="string">"processEngine"</span> <span class="attr">factory-method</span>=<span class="string">"getTaskService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"historyService"</span> <span class="attr">factory-bean</span>=<span class="string">"processEngine"</span> <span class="attr">factory-method</span>=<span class="string">"getHistoryService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 activitiRule 用于测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"activitiRule"</span> <span class="attr">class</span>=<span class="string">"org.activiti.engine.test.ActivitiRule"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"processEngine"</span> <span class="attr">ref</span>=<span class="string">"processEngine"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="1-ProcessEngines-类"><a href="#1-ProcessEngines-类" class="headerlink" title="1. ProcessEngines 类"></a>1. ProcessEngines 类</h1><h2 id="1-1-init-方法"><a href="#1-1-init-方法" class="headerlink" title="1.1. init() 方法"></a>1.1. init() 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    resources = classLoader.getResources(<span class="string">"activiti-context.xml"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"problem retrieving activiti-context.xml resources on the classpath: "</span> + System.getProperty(<span class="string">"java.class.path"</span>), e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (resources.hasMoreElements()) &#123;</span><br><span class="line">    URL resource = resources.nextElement();</span><br><span class="line">    log.info(<span class="string">"Initializing process engine using Spring configuration '&#123;&#125;'"</span>, resource.toString());</span><br><span class="line">    initProcessEngineFromSpringResource(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前两篇文章中, 我们主要对常规模式(即不与 Spring 整合的初始化模式)做了简单介绍, 这篇文章我们对于 Spring 整合方式下的 ProcessEngine 初始化做一个简单分析.</p><ol><li>读取 classpath 下的 <code>activiti-context.xml</code> 文件</li><li>将资源列表依次交由 <code>initProcessEngineFromSpringResource(resource)</code> 方法完成初始化</li></ol><h2 id="1-2-initProcessEngineFromSpringResource-URL-resource-方法"><a href="#1-2-initProcessEngineFromSpringResource-URL-resource-方法" class="headerlink" title="1.2. initProcessEngineFromSpringResource(URL resource) 方法"></a>1.2. initProcessEngineFromSpringResource(URL resource) 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initProcessEngineFromSpringResource</span><span class="params">(URL resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; springConfigurationHelperClass = ReflectUtil.loadClass(<span class="string">"org.activiti.spring.SpringConfigurationHelper"</span>);</span><br><span class="line">        Method method = springConfigurationHelperClass.getDeclaredMethod(<span class="string">"buildProcessEngine"</span>, <span class="keyword">new</span> Class&lt;?&gt;[] &#123; URL.class &#125;);</span><br><span class="line">        ProcessEngine processEngine = (ProcessEngine) method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; resource &#125;);</span><br><span class="line"></span><br><span class="line">        String processEngineName = processEngine.getName();</span><br><span class="line">        ProcessEngineInfo processEngineInfo = <span class="keyword">new</span> ProcessEngineInfoImpl(processEngineName, resource.toString(), <span class="keyword">null</span>);</span><br><span class="line">        processEngineInfosByName.put(processEngineName, processEngineInfo);</span><br><span class="line">        processEngineInfosByResourceUrl.put(resource.toString(), processEngineInfo);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"couldn't initialize process engine from spring configuration resource "</span> + resource.toString() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过反射的方式加载目标类 <code>org.activiti.spring.SpringConfigurationHelper</code> 的 class 对象</li><li>通过反射的方式获取该类名为 <code>buildProcessEngine</code> , 参数列表为 <code>URL</code> 的方法对象</li><li>反射调用 <code>org.activiti.spring.SpringConfigurationHelper#buildProcessEngine(URL resource)</code> 方法</li></ol><h1 id="2-SpringConfigurationHelper-类"><a href="#2-SpringConfigurationHelper-类" class="headerlink" title="2. SpringConfigurationHelper 类"></a>2. SpringConfigurationHelper 类</h1><h2 id="2-1-buildProcessEngine-URL-resource-方法"><a href="#2-1-buildProcessEngine-URL-resource-方法" class="headerlink" title="2.1. buildProcessEngine(URL resource) 方法"></a>2.1. buildProcessEngine(URL resource) 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">(URL resource)</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"==== BUILDING SPRING APPLICATION CONTEXT AND PROCESS ENGINE ========================================="</span>);</span><br><span class="line"></span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> GenericXmlApplicationContext(<span class="keyword">new</span> UrlResource(resource));</span><br><span class="line">    Map&lt;String, ProcessEngine&gt; beansOfType = applicationContext.getBeansOfType(ProcessEngine.class);</span><br><span class="line">    <span class="keyword">if</span> ((beansOfType == <span class="keyword">null</span>) || (beansOfType.isEmpty())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"no "</span> + ProcessEngine.class.getName() + <span class="string">" defined in the application context "</span> + resource.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProcessEngine processEngine = beansOfType.values().iterator().next();</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"==== SPRING PROCESS ENGINE CREATED =================================================================="</span>);</span><br><span class="line">    <span class="keyword">return</span> processEngine;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>使用传入的 <code>activiti-context.xml</code> 文件创建 ApplicationContext 对象</li><li>通过 ApplicationContext 获取类型为 <code>ProcessEngine</code> 的所有对象, 返回值为 Map&lt;beanId, ProcessEngine 对象&gt;</li><li>通过遍历获取其中第一个 value 并返回</li></ol><p>在执行第 1 步的时候, 就会触发 Spring Application Context 管理的对应对象的初始化.</p><p>对应开始时贴出来的配置文件范例, 在初始化 <code>&lt;processEngine, ProcessEngineFactoryBean&gt;</code> 前, 需要先初始化 <code>&lt;processEngineConfiguration, SpringProcessEngineConfiguration&gt;</code> 对象</p><h2 id="2-2-SpringProcessEngineConfiguration-对象的默认构造方法"><a href="#2-2-SpringProcessEngineConfiguration-对象的默认构造方法" class="headerlink" title="2.2 SpringProcessEngineConfiguration 对象的默认构造方法"></a>2.2 SpringProcessEngineConfiguration 对象的默认构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringProcessEngineConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionsExternallyManaged = <span class="keyword">true</span>;</span><br><span class="line">    deploymentStrategies.add(<span class="keyword">new</span> DefaultAutoDeploymentStrategy());</span><br><span class="line">    deploymentStrategies.add(<span class="keyword">new</span> SingleResourceAutoDeploymentStrategy());</span><br><span class="line">    deploymentStrategies.add(<span class="keyword">new</span> ResourceParentFolderAutoDeploymentStrategy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-ProcessEngine-对象的-getObject-方法"><a href="#2-3-ProcessEngine-对象的-getObject-方法" class="headerlink" title="2.3. ProcessEngine 对象的 getObject() 方法"></a>2.3. ProcessEngine 对象的 getObject() 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessEngine <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    configureExpressionManager();</span><br><span class="line">    configureExternallyManagedTransactions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processEngineConfiguration.getBeans() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      processEngineConfiguration.setBeans(<span class="keyword">new</span> SpringBeanFactoryProxyMap(applicationContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.processEngine = processEngineConfiguration.buildProcessEngine();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.processEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分析源码之前, 先贴出一个典型的 Activiti 与 Spring 整合的配置文件:&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(2)--流程引擎类</title>
    <link href="https://destinywang.github.io/blog/2019/02/18/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E%E7%B1%BB/"/>
    <id>https://destinywang.github.io/blog/2019/02/18/Activiti源码分析-2-流程引擎类/</id>
    <published>2019-02-18T14:42:12.000Z</published>
    <updated>2019-02-20T13:31:56.733Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中, 我们跟踪了流程引擎配置类对象的创建过程, 今天紧接着来看 Activiti 在获取到流程引擎配置类之后, 如何完成流程引擎的初始化.</p><h1 id="1-ProcessEngineConfiguration-类"><a href="#1-ProcessEngineConfiguration-类" class="headerlink" title="1. ProcessEngineConfiguration 类"></a>1. ProcessEngineConfiguration 类</h1><h2 id="1-1-buildProcessEngine-URL-resource-方法"><a href="#1-1-buildProcessEngine-URL-resource-方法" class="headerlink" title="1.1. buildProcessEngine(URL resource) 方法"></a>1.1. buildProcessEngine(URL resource) 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">(URL resource)</span> </span>&#123;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = resource.openStream();</span><br><span class="line">        ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream);</span><br><span class="line">        <span class="keyword">return</span> processEngineConfiguration.buildProcessEngine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"couldn't open resource stream: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtil.closeSilently(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中, 上一篇文章我们讲了第 5 行代码的源码调用关系, 最终创建了 ProcessEngineConfiguration 对象, 这篇文章中我们来讲第 6 行是如何创建 ProcessEngine 对象的.</p><h2 id="1-2-buildProcessEngine-方法"><a href="#1-2-buildProcessEngine-方法" class="headerlink" title="1.2. buildProcessEngine() 方法"></a>1.2. buildProcessEngine() 方法</h2><p>该方法是一个抽象方法, 实现类分别有:</p><ol><li>MultiSchemaMultiTenantProcessEngineConfiguration</li><li>ProcessEngineConfigurationImpl</li><li>SpringProcessEngineConfiguration</li></ol><p>在本例中, 最终会调用 <code>ProcessEngineConfigurationImpl</code> 的 <code>buildProcessEngine()</code> 方法, 因为我们在 <code>activiti.cfg.xml</code> 中的配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"processEngineConfiguration"</span> <span class="attr">class</span>=<span class="string">"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用的是 <code>StandaloneProcessEngineConfiguration</code>, 而打开该类发现该类没有 <code>buildProcessEngine()</code> 方法的实现, 因此实现方法在其父类 <code>ProcessEngineConfigurationImpl</code> 中.</p><h1 id="2-ProcessEngineConfigurationImpl-类"><a href="#2-ProcessEngineConfigurationImpl-类" class="headerlink" title="2. ProcessEngineConfigurationImpl 类"></a>2. ProcessEngineConfigurationImpl 类</h1><h2 id="2-1-buildProcessEngine-方法"><a href="#2-1-buildProcessEngine-方法" class="headerlink" title="2.1. buildProcessEngine() 方法"></a>2.1. buildProcessEngine() 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ProcessEngineImpl processEngine = <span class="keyword">new</span> ProcessEngineImpl(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// trigger build of Activiti 5 Engine</span></span><br><span class="line">    <span class="keyword">if</span> (isActiviti5CompatibilityEnabled &amp;&amp; activiti5CompatibilityHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Context.setProcessEngineConfiguration(processEngine.getProcessEngineConfiguration());</span><br><span class="line">        activiti5CompatibilityHandler.getRawProcessEngine();</span><br><span class="line">    &#125;</span><br><span class="line">    postProcessEngineInitialisation();</span><br><span class="line">    <span class="keyword">return</span> processEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-init"><a href="#2-2-init" class="headerlink" title="2.2. init()"></a>2.2. init()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initConfigurators();</span><br><span class="line">    configuratorsBeforeInit();</span><br><span class="line">    initProcessDiagramGenerator();</span><br><span class="line">    initHistoryLevel();</span><br><span class="line">    initExpressionManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usingRelationalDatabase) &#123;</span><br><span class="line">      initDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initAgendaFactory();</span><br><span class="line">    initHelpers();</span><br><span class="line">    initVariableTypes();</span><br><span class="line">    initBeans();</span><br><span class="line">    initFormEngines();</span><br><span class="line">    initFormTypes();</span><br><span class="line">    initScriptingEngines();</span><br><span class="line">    initClock();</span><br><span class="line">    initBusinessCalendarManager();</span><br><span class="line">    initCommandContextFactory();</span><br><span class="line">    initTransactionContextFactory();</span><br><span class="line">    initCommandExecutors();</span><br><span class="line">    initServices();</span><br><span class="line">    initIdGenerator();</span><br><span class="line">    initBehaviorFactory();</span><br><span class="line">    initListenerFactory();</span><br><span class="line">    initBpmnParser();</span><br><span class="line">    initProcessDefinitionCache();</span><br><span class="line">    initProcessDefinitionInfoCache();</span><br><span class="line">    initKnowledgeBaseCache();</span><br><span class="line">    initJobHandlers();</span><br><span class="line">    initJobManager();</span><br><span class="line">    initAsyncExecutor();</span><br><span class="line"></span><br><span class="line">    initTransactionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usingRelationalDatabase) &#123;</span><br><span class="line">      initSqlSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initSessionFactories();</span><br><span class="line">    initDataManagers();</span><br><span class="line">    initEntityManagers();</span><br><span class="line">    initHistoryManager();</span><br><span class="line">    initJpa();</span><br><span class="line">    initDeployers();</span><br><span class="line">    initDelegateInterceptor();</span><br><span class="line">    initEventHandlers();</span><br><span class="line">    initFailedJobCommandFactory();</span><br><span class="line">    initEventDispatcher();</span><br><span class="line">    initProcessValidator();</span><br><span class="line">    initDatabaseEventLogging();</span><br><span class="line">    initActiviti5CompatibilityHandler();</span><br><span class="line">    configuratorsAfterInit();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>init()</code> 是一个非常大的方法, 其内容主要是各种初始化操作的执行, 其中有些比较重要的需要单独讲解.</p><ul><li>如果使用关系型数据库, 其实 <code>usingRelationalDatabase</code> 变量默认为 true, 代表目前只支持关系型数据库, 就会使用 <code>initRelationalDatabase()</code> 方法完成数据库相关的初始化操作.</li></ul><h2 id="2-3-initRelationalDatabase"><a href="#2-3-initRelationalDatabase" class="headerlink" title="2.3. initRelationalDatabase()"></a>2.3. initRelationalDatabase()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSourceJndiName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataSource = (DataSource) <span class="keyword">new</span> InitialContext().lookup(dataSourceJndiName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"couldn't lookup datasource from "</span> + dataSourceJndiName + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jdbcUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((jdbcDriver == <span class="keyword">null</span>) || (jdbcUsername == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"DataSource or JDBC properties have to be specified in a process engine configuration"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.debug(<span class="string">"initializing datasource to db: &#123;&#125;"</span>, jdbcUrl);</span><br><span class="line"></span><br><span class="line">            PooledDataSource pooledDataSource = <span class="keyword">new</span> PooledDataSource(ReflectUtil.getClassLoader(), jdbcDriver, jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jdbcMaxActiveConnections &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pooledDataSource.setPoolMaximumActiveConnections(jdbcMaxActiveConnections);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (jdbcMaxIdleConnections &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pooledDataSource.setPoolMaximumIdleConnections(jdbcMaxIdleConnections);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (jdbcMaxCheckoutTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pooledDataSource.setPoolMaximumCheckoutTime(jdbcMaxCheckoutTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (jdbcMaxWaitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pooledDataSource.setPoolTimeToWait(jdbcMaxWaitTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (jdbcPingEnabled == <span class="keyword">true</span>) &#123;</span><br><span class="line">                pooledDataSource.setPoolPingEnabled(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (jdbcPingQuery != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pooledDataSource.setPoolPingQuery(jdbcPingQuery);</span><br><span class="line">                &#125;</span><br><span class="line">                pooledDataSource.setPoolPingConnectionsNotUsedFor(jdbcPingConnectionNotUsedFor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (jdbcDefaultTransactionIsolationLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pooledDataSource.setDefaultTransactionIsolationLevel(jdbcDefaultTransactionIsolationLevel);</span><br><span class="line">            &#125;</span><br><span class="line">            dataSource = pooledDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> PooledDataSource) &#123;</span><br><span class="line">            <span class="comment">// ACT-233: connection pool of Ibatis is not properly</span></span><br><span class="line">            <span class="comment">// initialized if this is not called!</span></span><br><span class="line">            ((PooledDataSource) dataSource).forceCloseAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (databaseType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        initDatabaseType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>dataSource</code> 对象为空,  就初始化一个 <code>PooledDataSource</code> 对象, 根据默认的 <code>jdbcUrl</code>, <code>jdbcDriver</code>, <code>jdbcUsername</code> 等变量创建一个数据库连接, 而上述的默认值则对应 Activiti 内置的内存数据库 H2, 说明如果不设置 dataSource, Activiti 就会使用内置的 H2 数据库完成 dataSource 的初始化.</li><li><code>databaseType</code> 用于标识数据库类型, 如果该变量为空, 需要调用 <code>initDatabaseType()</code> 来完成数据库类型的赋值.</li></ul><h2 id="2-4-initDatabaseType-方法"><a href="#2-4-initDatabaseType-方法" class="headerlink" title="2.4. initDatabaseType() 方法"></a>2.4. initDatabaseType() 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDatabaseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = dataSource.getConnection();</span><br><span class="line">        DatabaseMetaData databaseMetaData = connection.getMetaData();</span><br><span class="line">        String databaseProductName = databaseMetaData.getDatabaseProductName();</span><br><span class="line">        log.debug(<span class="string">"database product name: '&#123;&#125;'"</span>, databaseProductName);</span><br><span class="line">        databaseType = databaseTypeMappings.getProperty(databaseProductName);</span><br><span class="line">        <span class="keyword">if</span> (databaseType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"couldn't deduct database type from database product name '"</span> + databaseProductName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"using database type: &#123;&#125;"</span>, databaseType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Special care for MSSQL, as it has a hard limit of 2000 params per statement (incl bulk statement).</span></span><br><span class="line">        <span class="comment">// Especially with executions, with 100 as default, this limit is passed.</span></span><br><span class="line">        <span class="keyword">if</span> (DATABASE_TYPE_MSSQL.equals(databaseType)) &#123;</span><br><span class="line">            maxNrOfStatementsInBulkInsert = DEFAULT_MAX_NR_OF_STATEMENTS_BULK_INSERT_SQL_SERVER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Exception while initializing Database connection"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Exception while closing the Database connection"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取一个数据库连接</li><li>通过该连接获取元数据信息, 得到数据库产品的名称</li><li>通过该名称去获取内部实现保存的数据库名称 Properties 集合, 如果为空说明不支持该数据库</li><li>通过存在就将 <code>databaseType</code> 完成赋值</li></ul><h2 id="2-5-回到-buildProcessEngine-方法"><a href="#2-5-回到-buildProcessEngine-方法" class="headerlink" title="2.5. 回到 buildProcessEngine() 方法"></a>2.5. 回到 buildProcessEngine() 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ProcessEngineImpl processEngine = <span class="keyword">new</span> ProcessEngineImpl(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger build of Activiti 5 Engine</span></span><br><span class="line">    <span class="keyword">if</span> (isActiviti5CompatibilityEnabled &amp;&amp; activiti5CompatibilityHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Context.setProcessEngineConfiguration(processEngine.getProcessEngineConfiguration());</span><br><span class="line">        activiti5CompatibilityHandler.getRawProcessEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postProcessEngineInitialisation();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processEngine;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>init()</code> 方法结束后, 已经完成了相关资源的初始化</li><li>使用 <code>ProcessEngineConfiguration</code> 对象去创建 <code>ProcessEngineImpl</code>, xxxService 核心服务对象都是通过 <code>ProcessEngineConfiguration</code> 对象中的同类对象完成的初始化.</li><li>如果开启 Activiti5 兼容功能, 并且 <code>activiti5CompatibilityHandler</code>(Activiti5兼容处理器对象) 不为空, 执行兼容初始化逻辑, 正常情况下不走该逻辑.</li><li>执行 <code>postProcessEngineInitialisation()</code></li></ul><h2 id="2-6-postProcessEngineInitialisation"><a href="#2-6-postProcessEngineInitialisation" class="headerlink" title="2.6. postProcessEngineInitialisation()"></a>2.6. postProcessEngineInitialisation()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessEngineInitialisation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (performanceSettings.isValidateExecutionRelationshipCountConfigOnBoot()) &#123;</span><br><span class="line">        commandExecutor.execute(<span class="keyword">new</span> ValidateExecutionRelatedEntityCountCfgCmd());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用该方法来检查是否使用了流程实例相关数量记录(<code>validateExecutionRelationshipCountConfigOnBoot</code> 配置的默认值为 true, 默认开启)</li><li>使用命令执行器执行 <code>ValidateExecutionRelatedEntityCountCfgCmd</code></li></ul><h1 id="3-ValidateExecutionRelatedEntityCountCfgCmd-类"><a href="#3-ValidateExecutionRelatedEntityCountCfgCmd-类" class="headerlink" title="3. ValidateExecutionRelatedEntityCountCfgCmd 类"></a>3. ValidateExecutionRelatedEntityCountCfgCmd 类</h1><p>实现了 <code>Command</code> 接口, 命令执行器执行的时候会自动调用其 <code>execute(CommandContext commandContext)</code> 方法.</p><h2 id="3-1-execute-CommandContext-commandContext-方法"><a href="#3-1-execute-CommandContext-commandContext-方法" class="headerlink" title="3.1. execute(CommandContext commandContext) 方法"></a>3.1. execute(CommandContext commandContext) 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">execute</span><span class="params">(CommandContext commandContext)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * If execution related entity counting is on in config | Current property in database : Result</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *  A) true | not there : write new property with value 'true'</span></span><br><span class="line"><span class="comment">     *  B) true | true : all good</span></span><br><span class="line"><span class="comment">     *  C) true | false : the feature was disabled before, but it is enabled now. Old executions will have a local flag with false. </span></span><br><span class="line"><span class="comment">     *                    It is now enabled. This is fine, will be handled in logic. Update the property.</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  D) false | not there: write new property with value 'false'</span></span><br><span class="line"><span class="comment">     *  E) false | true : the feature was disabled before and enabled now. To guarantee data consistency, we need to remove the flag from all executions.</span></span><br><span class="line"><span class="comment">     *                    Update the property.</span></span><br><span class="line"><span class="comment">     *  F) false | false : all good</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * In case A and D (not there), the property needs to be written to the db</span></span><br><span class="line"><span class="comment">     * Only in case E something needs to be done explicitely, the others are okay.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    PropertyEntityManager propertyEntityManager = commandContext.getPropertyEntityManager();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> configProperty = commandContext.getProcessEngineConfiguration().getPerformanceSettings().isEnableExecutionRelationshipCounts();</span><br><span class="line">    PropertyEntity propertyEntity = propertyEntityManager.findById(PROPERTY_EXECUTION_RELATED_ENTITY_COUNT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyEntity == <span class="keyword">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 'not there' case in the table above: easy, simply insert the value</span></span><br><span class="line">      </span><br><span class="line">        PropertyEntity newPropertyEntity = propertyEntityManager.create();</span><br><span class="line">        newPropertyEntity.setName(PROPERTY_EXECUTION_RELATED_ENTITY_COUNT);</span><br><span class="line">        newPropertyEntity.setValue(Boolean.toString(configProperty));</span><br><span class="line">        propertyEntityManager.insert(newPropertyEntity);</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">boolean</span> propertyValue = Boolean.valueOf(propertyEntity.getValue().toString().toLowerCase());</span><br><span class="line">            <span class="keyword">if</span> (!configProperty &amp;&amp; propertyValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Configuration change: execution related entity counting feature was enabled before, but now disabled. "</span></span><br><span class="line">                            + <span class="string">"Updating all execution entities."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                commandContext.getProcessEngineConfiguration().getExecutionDataManager().updateAllExecutionRelatedEntityCountFlags(configProperty);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Update property</span></span><br><span class="line">            <span class="keyword">if</span> (configProperty != propertyValue) &#123;</span><br><span class="line">                propertyEntity.setValue(Boolean.toString(configProperty));</span><br><span class="line">                propertyEntityManager.update(propertyEntity);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>去数据库中的 <code>ACT_GE_PROPERTY</code> 表查询 id 为 <code>cfg.execution-related-entities-count</code> 的记录.<ul><li>如果没有查到, 则插入一条 <code>cfg.execution-related-entities-count, false</code> 的记录</li><li>如果查到, 将该记录中的值转换为小写字符串, 转换为 boolean 值<ul><li>如果配置的值不等于 DB 中存储的值, 那么将 DB 的值更新为配置的值</li></ul></li></ul></li></ul><p>最终初始化代码执行完成后, 会在 DB 中存在这样一条记录</p><p><img src="https://user-images.githubusercontent.com/17758731/53029162-3bda8100-34a3-11e9-927c-0a9a2450c11d.png" alt="image"></p><hr><p>执行完毕后, 此时 ProcessEngine 对象已经初始化完成.</p><p>调用关系如下:</p><p><img src="https://user-images.githubusercontent.com/17758731/53028730-65df7380-34a2-11e9-9221-124d145046d8.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章中, 我们跟踪了流程引擎配置类对象的创建过程, 今天紧接着来看 Activiti 在获取到流程引擎配置类之后, 如何完成流程引擎的初始化.&lt;/p&gt;
&lt;h1 id=&quot;1-ProcessEngineConfiguration-类&quot;&gt;&lt;a href=&quot;#1-Proce
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关系型数据库的瓶颈与优化</title>
    <link href="https://destinywang.github.io/blog/2019/01/19/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%93%B6%E9%A2%88%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://destinywang.github.io/blog/2019/01/19/关系型数据库的瓶颈与优化/</id>
    <published>2019-01-19T13:42:46.000Z</published>
    <updated>2019-01-26T14:03:29.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据库的分类"><a href="#1-数据库的分类" class="headerlink" title="1. 数据库的分类"></a>1. 数据库的分类</h1><p>数据库大致可以分为两部分:</p><ol><li>传统的关系型数据库, 如: MySQL, Oracle, SQLServer 以及 PostgreSQL; MySQL 是国内使用最广泛的数据库, Oracle 在传统行业应用最为广泛, PostgreSQL 性能和功能都比较完善, 但目前文档和社区还有待成长.</li><li>非关系型数据库, 如 HBase(列式数据库), MongoDB(文档型数据库), Redis(高性能 KV 存储), Lucene(搜索引擎) 等等.</li></ol><h1 id="2-关系型数据库的瓶颈与优化"><a href="#2-关系型数据库的瓶颈与优化" class="headerlink" title="2. 关系型数据库的瓶颈与优化"></a>2. 关系型数据库的瓶颈与优化</h1><h2 id="2-1-为什么数据库的架构需要调整"><a href="#2-1-为什么数据库的架构需要调整" class="headerlink" title="2.1 为什么数据库的架构需要调整"></a>2.1 为什么数据库的架构需要调整</h2><ol><li>互联网的数据增长往往是指数型的;</li><li>读写分离, 分布式: 单机性能上存在瓶颈;</li><li>NoSQL, 搜索引擎: 特殊场景的需求无法满足;</li><li>分析系统: 无法满足大数据的分析需求;</li><li>部署要求: 同城容灾/异地容灾.</li></ol><h2 id="2-2-数据库会遇到什么问题"><a href="#2-2-数据库会遇到什么问题" class="headerlink" title="2.2 数据库会遇到什么问题"></a>2.2 数据库会遇到什么问题</h2><h3 id="2-2-1-性能"><a href="#2-2-1-性能" class="headerlink" title="2.2.1 性能"></a>2.2.1 性能</h3><ul><li>查询性能</li><li>写入更新</li><li>并发, 数据量等</li></ul><h3 id="2-2-2-功能"><a href="#2-2-2-功能" class="headerlink" title="2.2.2 功能"></a>2.2.2 功能</h3><ul><li>新功能: LBS/JSON/特殊业务场景</li><li>数据安全性: 强一致性/非强一致性</li><li>大数据分析</li><li>搜索等</li></ul><h1 id="3-不同业务场景的存储选型"><a href="#3-不同业务场景的存储选型" class="headerlink" title="3. 不同业务场景的存储选型"></a>3. 不同业务场景的存储选型</h1><h2 id="3-1-一个简单的问题"><a href="#3-1-一个简单的问题" class="headerlink" title="3.1 一个简单的问题"></a>3.1 一个简单的问题</h2><h4 id="MySQL-已经有-cache-了-为何还需要加一层-Redis"><a href="#MySQL-已经有-cache-了-为何还需要加一层-Redis" class="headerlink" title="MySQL 已经有 cache 了, 为何还需要加一层 Redis"></a>MySQL 已经有 cache 了, 为何还需要加一层 Redis</h4><h2 id="3-2-数据库查询开销"><a href="#3-2-数据库查询开销" class="headerlink" title="3.2 数据库查询开销"></a>3.2 数据库查询开销</h2><p><img src="https://user-images.githubusercontent.com/17758731/51440848-276d6200-1d06-11e9-8a4e-27a280b1a538.png" alt="image"></p><p>其中比较耗时的步骤有:</p><ul><li>建立 TCP 连接</li><li>生成执行计划</li><li>开表</li><li>从磁盘扫描数据</li><li>关闭连接</li></ul><h3 id="3-2-1-SQL-解析"><a href="#3-2-1-SQL-解析" class="headerlink" title="3.2.1 SQL 解析"></a>3.2.1 SQL 解析</h3><p>假设有如下三条语句, 均是根据主键的查询.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 1 </span><br><span class="line">SELECT id, name, price FROM products WHERE id IN (1, 2, 3, 4, ... 30000);           # (1-2s)</span><br><span class="line"></span><br><span class="line"># 2. 将第一条查询转换成 30000 条语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">SELECT id, name, price FROM products WHERE id = 30000;                              # (2-3s)</span><br><span class="line"></span><br><span class="line"># 3. 将第一条转换成 OR 语句</span><br><span class="line">SELECT id, name, price FROM products WHERE id = 1 OR id = 2 OR ... OR id = 30000;   # (8-10s)</span><br></pre></td></tr></table></figure><p>造成第三条语句执行时间如此长的主要原因就是大量的 OR 语句会导致 SQL 解析非常耗时.</p><h3 id="3-2-2-以-MySQL-的-InnoDB-存储引擎主键查询为例"><a href="#3-2-2-以-MySQL-的-InnoDB-存储引擎主键查询为例" class="headerlink" title="3.2.2 以 MySQL 的 InnoDB 存储引擎主键查询为例"></a>3.2.2 以 MySQL 的 InnoDB 存储引擎主键查询为例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = ?;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/51441235-71f0dd80-1d0a-11e9-95ef-24b2c481a4f0.png" alt="image"></p><p>常规配置的服务器基本可以达到 400000 QPS.</p><h3 id="3-2-3-如果查询条件不是主键"><a href="#3-2-3-如果查询条件不是主键" class="headerlink" title="3.2.3 如果查询条件不是主键"></a>3.2.3 如果查询条件不是主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">name</span> = ?;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/51441306-2ab71c80-1d0b-11e9-9b86-cf7aa0957787.png" alt="image"></p><p>对于非主键的查询, MySQL 会根据二级索引查询到主索引对应节点的位置. 按照图中的情况, 会首先通过三次 IO 找到对应主键, 在二级索引的叶子节点会同时保存索引字段的值以及主键的值, 再回到主索引通过主键查询到整条记录.</p><p>在 MySQL 中, 主键查询时最为高效的一类查询.</p><p>DBA 往往希望所有的 SQL 语句都是 KV 查询, 但是往往是不现实的.</p><ul><li>主键查询有限, 有些主键没有业务含义;</li><li>设计表结构时, 并没有考虑过主键问题.</li></ul><p>SQL 语句允许开发人员用各种方式从表中获取数据, 但 DBA 却不会希望我们这么做.</p><h3 id="3-2-3-数据库的大字段"><a href="#3-2-3-数据库的大字段" class="headerlink" title="3.2.3 数据库的大字段"></a>3.2.3 数据库的大字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content varchar(2046) NOT NULL <span class="keyword">COMMENT</span> <span class="string">'原始消息'</span>;</span><br></pre></td></tr></table></figure><p>以 InnoDB 存储引擎为例:</p><ul><li>TinyText/Text/Mediumtext</li><li>varchar(256)/varchar(500)/varchar(20000)</li><li>tinyBlob/blob/mediumBlob </li></ul><p>text 类型本质上和 varchar 类型没有区别.</p><p><img src="https://user-images.githubusercontent.com/17758731/51544585-3a656b00-1e9b-11e9-9610-28431f9b1b09.png" alt="image"></p><p>MySQL 中, 数据是以页的方式来组织的, 每个数据页默认大小 16 KB, 其中包括页头, 页尾, 中间是一行一行的记录.</p><p>图中的每条记录包括 ID, NAME, AGE 和 DETAIL. 假设 DETAIL 是一个大字段, 达到超过了单页的大小, 此时 DB 会新开一个数据页, 当前页通过指针指向该页. 如果一页依然不够, MySQL 就会不断新加数据页直到能够存下为止.</p><p>一旦存在这样的大字段, 会带来如下问题:</p><ol><li>查询开销大;</li><li>查询影响大, 严重时会触发热页换出, 引起系统抖动. MySQL 将记录从磁盘读取出来的时候, 可能会有很多数据页, MySQL 自带缓存时非常宝贵的, 会导致真正使用频率高的数据页被替换成大字段的数据页. 此外, 对 MySQL 来说, 即便只查记录中的某几个字段, 数据库依然会把整条记录取出, 读进内存, 再进行指定字段的筛选</li></ol><p>对于大字段场景可以尝试的优化方案:</p><ol><li>是否适合存储关系型数据库;</li><li>是否所有数据都需要存数据库;</li><li>是否可以新建一张表存储大字段.</li></ol><h3 id="3-2-4-数据库缓存利用率"><a href="#3-2-4-数据库缓存利用率" class="headerlink" title="3.2.4 数据库缓存利用率"></a>3.2.4 数据库缓存利用率</h3><p>以 InnoDB 存储引擎为例:</p><ol><li>MySQL 默认数据页为 <code>16KB</code>, 哪怕只读一行记录, 也需要从磁盘中取出 <code>16KB</code> 数据取出;</li><li>MySQL 是以页为最小的缓存单位;</li><li>如果每行数据 1kb, 256kb 内存空间能缓存多少行有效数据, 最好的情况是每条数据整齐排列在一个数据页中, 那么可以缓存256条记录, 最坏的情况下每一页只存在一条数据, 那么就只能缓存16条;</li><li>在 256KB 的 Buffer Pool 中, 并不是所有空间都用来做数据页缓存, 有很大的一块在 Write Buffer(MySQL 为了优化写操作, 会将一段时间内的写操作先放在 Write Buffer, 再由后台线程定时异步刷新到磁盘上). 然而剩下的 <code>128KB</code> 中还存在一部分脏页.</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/51545929-02135c00-1e9e-11e9-94ac-d755610749d5.png" alt="image"></p><p>缓存为什么如此重要:</p><ul><li>互联网产品往往读多写少;</li><li>扩展缓存远比扩展 DB 简单;</li><li>数据库缓存利用率很低;</li><li>互联网应用对 DB 响应时间比较敏感, 缓存系统一般性能比较好</li><li>只要符合条件的数据都应该走缓存:<ol><li>修改不频繁的数据;</li><li>非实时的数据, 一致性要求不严的数据;</li><li>查询频率较高, 带有明显热点请求的数据;</li></ol></li></ul><h3 id="3-2-5-缓存带来的问题"><a href="#3-2-5-缓存带来的问题" class="headerlink" title="3.2.5 缓存带来的问题"></a>3.2.5 缓存带来的问题</h3><blockquote><p>用了缓存并不一定代表没有问题</p></blockquote><ol><li>缓存命中</li><li>缓存穿透</li><li>缓存失效</li><li>缓存一致</li></ol><h3 id="3-2-6-选择正确的索引"><a href="#3-2-6-选择正确的索引" class="headerlink" title="3.2.6 选择正确的索引"></a>3.2.6 选择正确的索引</h3><blockquote><p>降低扫描数据量还是降低排序代价</p></blockquote><p>大多数查询只能使用一个索引, 因此在需要对多个列进行操作的 SQL 语句中, 我们需要准确评估每个索引的开销.</p><ul><li>key idx_create_time(createTime)</li><li>key idx_price(price)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_order <span class="keyword">WHERE</span> createTime &gt; xxx <span class="keyword">AND</span> createTime &lt; xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-7-索引的使用"><a href="#3-2-7-索引的使用" class="headerlink" title="3.2.7 索引的使用"></a>3.2.7 索引的使用</h3><h4 id="3-2-7-1-索引字段过长-超过索引支持"><a href="#3-2-7-1-索引字段过长-超过索引支持" class="headerlink" title="3.2.7.1 索引字段过长, 超过索引支持"></a>3.2.7.1 索引字段过长, 超过索引支持</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># name varchar(512)</span><br><span class="line"># ket idx_name(name(100))</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">comment</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt;= <span class="string">'destiny'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>上面的例子在实际场景中执行非常慢, 使用 EXPLAIN 打印查询计划: </p><pre><code>  select_type: SIMPLE        table: comment         type: rangepossible_keys: id_name          key: uk_sess      key_len: 403          ref: NULL         rows: 462642        Extra:Using where; Using filesort1 row in set(0.00sec)</code></pre><p>其中需要重点关注的是: <code>Extra:Using where; Using filesort</code></p><ul><li>Using where: 表用到了索引</li><li>Using filesort: MySQL 自带的磁盘排序, 并没有用到索引的排序</li></ul><p>问题是为什么使用了索引, 查询效率依然非常慢?</p><p>真正的原因是字段太长, 而索引的长度只能覆盖 256 字节, 导致 ORDER BY 无法在内存中完成排序</p><h4 id="3-2-7-2"><a href="#3-2-7-2" class="headerlink" title="3.2.7.2"></a>3.2.7.2</h4><p>查询某个用户 id 的分值总和</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- uid varchar(190) NOT NULL DEFAULT '' COMMENT '用户 id',</span></span><br><span class="line"><span class="comment">-- score bigint(20) NOT NULL DEFAULT '0' COMMENT '变动分值, 正增, 负减',</span></span><br><span class="line"><span class="comment">-- primary key ID</span></span><br><span class="line"><span class="comment">-- KEY idx_uid(uid)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(score) <span class="keyword">FROM</span> <span class="keyword">name</span> <span class="keyword">WHERE</span> uid = <span class="string">'5993156'</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/17758731/51613355-3f3f2300-1f5e-11e9-8736-f60fca4007b1.png" alt="image"></p><p>这条 SQL 的执行顺序:</p><ol><li>根据二级索引 uid 找到所有主键 id</li><li>再根据主键逐行找到 score</li><li>对 score 进行聚合</li></ol><p>这个 SQL 的问题在于需要进行大量的回表操作(从二级索引回到一级索引), 然后将全部符合过滤条件的记录放在内存中完成聚合操作.</p><p>改进的方法其实很简单, 可以尝试使用 (uid, score) 建立联合索引, 这样只需要查询二级索引就可以获得全部数据.</p><p><img src="https://user-images.githubusercontent.com/17758731/51614040-d062c980-1f5f-11e9-9960-41cc62ad6c77.png" alt="image"></p><p>随机插入 100W 条数据, 现在对比下两条索引的开销.</p><p><img src="https://user-images.githubusercontent.com/17758731/51614096-f0928880-1f5f-11e9-8c2d-bc625ffb2eb1.png" alt="image"></p><h2 id="3-3-数据库写开销"><a href="#3-3-数据库写开销" class="headerlink" title="3.3 数据库写开销"></a>3.3 数据库写开销</h2><ul><li>对持久化要求严格, 写操作代价大</li><li>日志文件需要 fsync, 硬件存在瓶颈</li><li>数据库写操作很难扩展</li><li>主从要求一致场景下还要算上网络开销</li></ul><p><img src="https://user-images.githubusercontent.com/17758731/51615980-191c8180-1f64-11e9-95db-355d532b58d5.png" alt="image"></p><ol><li>将 3 所在的数据页读到缓存中;</li><li>在内存中将 3 改成 5, 提交事务, 触发 Redo Log 的刷新;</li><li>向用户返回操作成功;</li></ol><h2 id="3-4-业务场景触发的高并发写入"><a href="#3-4-业务场景触发的高并发写入" class="headerlink" title="3.4 业务场景触发的高并发写入"></a>3.4 业务场景触发的高并发写入</h2><h3 id="3-4-1-秒杀"><a href="#3-4-1-秒杀" class="headerlink" title="3.4.1 秒杀"></a>3.4.1 秒杀</h3><ul><li>高并发写入的极端情况</li><li>业务优化(缓存/令牌通/排队/Java 信号量/乐观锁)</li><li>热点资源隔离</li><li>引入数据库线程池</li><li>InnoDB 内核层优化: AliSQL</li></ul><h3 id="3-4-2-私信-站内信消息推送"><a href="#3-4-2-私信-站内信消息推送" class="headerlink" title="3.4.2 私信/站内信消息推送"></a>3.4.2 私信/站内信消息推送</h3><ul><li>高并发写入</li><li>伴随大量的读请求</li><li>系统消息/个人消息区分对待</li><li>消息内容单独对待</li><li>延迟写入, 通过队列/缓存达到限流目的</li></ul><h3 id="3-4-3-听歌量"><a href="#3-4-3-听歌量" class="headerlink" title="3.4.3 听歌量"></a>3.4.3 听歌量</h3><p><img src="https://user-images.githubusercontent.com/17758731/51684703-a1178f80-2027-11e9-94ef-6f320b852c29.png" alt="image"></p><ul><li>业务原因导致写入量非常大</li><li>插入更新比不确定, 更新能力强</li><li>数据库需要具备自动扩展的能力</li><li>数据非强一致</li></ul><h2 id="3-5-死锁和超时"><a href="#3-5-死锁和超时" class="headerlink" title="3.5 死锁和超时"></a>3.5 死锁和超时</h2><ul><li>InnoDB 锁超时默认需要 5s 等待</li><li>死锁马上就能被发现, 然后被 DB 自动回滚</li><li>锁超时一般是索引不对, 或者 SQL 语句执行性能较差</li><li>死锁一般是业务实现有问题</li><li>锁超时一般影响较为可控</li><li>死锁情况比较严重, 会导致全站崩溃</li></ul><h2 id="3-6-数据库并发事务-锁"><a href="#3-6-数据库并发事务-锁" class="headerlink" title="3.6 数据库并发事务, 锁"></a>3.6 数据库并发事务, 锁</h2><ul><li>业务流程中的锁: 减库存, 发优惠券</li></ul><p>悲观锁实现:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span> <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> <span class="keyword">id</span> = ? <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- do sth</span></span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">SET</span> <span class="keyword">count</span> = <span class="keyword">count</span> - ? <span class="keyword">WHERE</span> <span class="keyword">id</span> = ?;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p><p>乐观锁实现:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span> <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> <span class="keyword">id</span> = ?;</span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">SET</span> <span class="keyword">count</span> = <span class="keyword">count</span> - ? <span class="keyword">WHERE</span> <span class="keyword">id</span> = ? <span class="keyword">AND</span> <span class="keyword">count</span> = :<span class="keyword">count</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- do sth</span></span><br></pre></td></tr></table></figure></p><h1 id="4-数据库的模块化拆分"><a href="#4-数据库的模块化拆分" class="headerlink" title="4. 数据库的模块化拆分"></a>4. 数据库的模块化拆分</h1><h2 id="4-1-单机服务器的局限"><a href="#4-1-单机服务器的局限" class="headerlink" title="4.1 单机服务器的局限"></a>4.1 单机服务器的局限</h2><ul><li>虽然硬件配置越来越高, 但是总有瓶颈(e.g. CPU/内存/网络/IO/容量)</li><li>为了后续业务的可扩展性</li><li>单机系统崩溃风险较高</li><li>优化性能<ul><li>读写分离</li><li>冷热分离, 创建归档库</li><li>关键链路和非关键链路隔离</li><li>系统层面做好降级</li></ul></li></ul><h2 id="4-2-常见拆分方案"><a href="#4-2-常见拆分方案" class="headerlink" title="4.2 常见拆分方案"></a>4.2 常见拆分方案</h2><h3 id="4-2-1-读写分离"><a href="#4-2-1-读写分离" class="headerlink" title="4.2.1 读写分离"></a>4.2.1 读写分离</h3><p>读写分离的原理就是将数据库读写操作分散到不同的节点上</p><p><img src="https://user-images.githubusercontent.com/17758731/51689739-3586ef80-2032-11e9-8d0a-3bfcb7ac34d3.png" alt="image"></p><p>读写分离的基本原理就是:</p><ul><li>数据库服务器搭建主从集群;</li><li>数据库主机负责写操作, 从机只负责读操作;</li><li>数据库主机通过复制将数据同步到从机, 每台数据库服务器都存储了所有业务数据.</li><li>业务服务器将写操作发给数据库主机, 将读操作发给数据库从机.</li></ul><p>使用读写分离之后, 可能会引入两个问题:</p><ol><li>主从复制延迟</li><li>分配机制</li></ol><h4 id="4-2-1-1-复制延迟"><a href="#4-2-1-1-复制延迟" class="headerlink" title="4.2.1.1 复制延迟"></a>4.2.1.1 复制延迟</h4><p>主从复制的延迟可能达到秒级, 如果有大量数据短时间需要完成同步, 延迟甚至可能达到分钟.</p><p>主从复制所带来的问题: </p><blockquote><p>如果业务服务器将数据写入到主库后进行读取, 此时读操作访问从库, 而主库的数据没有完全复制过来, 从库是无法读取到最新数据的.</p></blockquote><p>解决方案:</p><ol><li>写操作后的读操作指定发给主库, 逻辑会和业务强绑定, 对业务侵入较大.</li><li>读从库失败后再读一次主库, 如果有大量没有命中从库的读请求, 会给主库带来较大压力.</li><li>关键业务读写操作全部走主库, 非关键业务采用读写分离.</li></ol><h4 id="4-2-1-2-分配机制"><a href="#4-2-1-2-分配机制" class="headerlink" title="4.2.1.2 分配机制"></a>4.2.1.2 分配机制</h4><p>将读写操作区分开来, 然后访问不同的数据库服务器, 一般有两种方式: 程序代码封装和中间件封装</p><h5 id="1-程序代码封装"><a href="#1-程序代码封装" class="headerlink" title="1. 程序代码封装"></a>1. 程序代码封装</h5><p>在代码中抽象一个数据访问层, 实现读写操作分离和数据库服务器连接的管理.</p><p><img src="https://user-images.githubusercontent.com/17758731/51787744-9c321780-21b0-11e9-864b-933a0bde94e3.png" alt="image"></p><p>特点:</p><ol><li>实现简单, 可以根据业务定制化;</li><li>无法做到多语言通用, 容易重复开发;</li><li>故障情况下, 如果主从发生切换, 需要将系统配置手动修改.</li></ol><h5 id="2-中间件封装"><a href="#2-中间件封装" class="headerlink" title="2. 中间件封装"></a>2. 中间件封装</h5><p>独立一套系统出来, 实现读写分离和数据库服务器连接的管理, 中间件对业务服务器提供 SQL 兼容的协议, 业务服务器无需自己进行读写分离, 对于业务服务器来说, 访问中间件和访问数据库没有区别</p><p><img src="https://user-images.githubusercontent.com/17758731/51787885-19aa5780-21b2-11e9-8df2-cba6fb8fcc3e.png" alt="image"></p><p>特点:</p><ol><li>能够支持多种编程语言, 因为数据库中间件对业务提供的是标准的 SQL 接口.</li><li>实现较为复杂, 需要完整支持 SQL 语法和数据库服务器的协议.</li><li>性能要求很高, 容易成为瓶颈.</li><li>数据库主从切换对业务服务器无感知, 数据库中间件可以探测数据库服务器的主从状态(e.g. 向某个测试库写入一条数据, 成功的是主机, 失败的是从机)</li></ol><h3 id="4-2-2-分布式"><a href="#4-2-2-分布式" class="headerlink" title="4.2.2 分布式"></a>4.2.2 分布式</h3><p>读写分离分散了读写操作的压力, 但没有分散存储的压力, 当数据量达到千万级以上的时候, 单台数据库服务器的存储能力就会成为瓶颈:</p><ol><li>数据量太大, 读写的性能会大幅下降.</li><li>数据文件备份和恢复都会很困难.</li></ol><p><img src="https://user-images.githubusercontent.com/17758731/51788030-3051ae00-21b4-11e9-99ca-cdd067495813.png" alt="image"></p><ul><li>垂直分表: 适合将某些表中不常用且占用大量空间的列拆分出去. 代价是操作表的数量增加.</li><li>水平拆分: 适合行数较大的表, 会引入更多的复杂度: <code>路由</code>, <code>join 操作</code>, <code>count 操作</code> 等</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-数据库的分类&quot;&gt;&lt;a href=&quot;#1-数据库的分类&quot; class=&quot;headerlink&quot; title=&quot;1. 数据库的分类&quot;&gt;&lt;/a&gt;1. 数据库的分类&lt;/h1&gt;&lt;p&gt;数据库大致可以分为两部分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传统的关系型数据库, 如: MyS
      
    
    </summary>
    
      <category term="MySQL" scheme="https://destinywang.github.io/blog/categories/MySQL/"/>
    
    
      <category term="关系型数据库" scheme="https://destinywang.github.io/blog/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Activiti源码分析(1)--流程引擎配置类</title>
    <link href="https://destinywang.github.io/blog/2018/12/31/Activiti%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E5%BC%95%E6%93%8E%E9%85%8D%E7%BD%AE%E7%B1%BB/"/>
    <id>https://destinywang.github.io/blog/2018/12/31/Activiti源码分析-1-引擎配置类/</id>
    <published>2018-12-31T15:19:13.000Z</published>
    <updated>2019-02-18T16:31:12.891Z</updated>
    
    <content type="html"><![CDATA[<p>Activiti 配置风格获取引擎源码分析: </p><p>流程引擎管理类 ProcessEngines</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    log.info(<span class="string">"processEngine: &#123;&#125;"</span>, processEngine);   <span class="comment">// org.activiti.engine.impl.ProcessEngineImpl@66ea1466</span></span><br><span class="line">    Class&lt;? extends ProcessEngine&gt; processEngineClass = processEngine.getClass();</span><br><span class="line">    log.info(<span class="string">"class: &#123;&#125;"</span>, processEngineClass);      <span class="comment">// org.activiti.engine.impl.ProcessEngineImpl</span></span><br><span class="line">    DynamicBpmnService dynamicBpmnService = processEngine.getDynamicBpmnService();</span><br><span class="line">    FormService formEngineFormService = processEngine.getFormEngineFormService();</span><br><span class="line">    FormRepositoryService formEngineRepositoryService = processEngine.getFormEngineRepositoryService();</span><br><span class="line">    org.activiti.engine.FormService formService = processEngine.getFormService();</span><br><span class="line">    HistoryService historyService = processEngine.getHistoryService();</span><br><span class="line">    IdentityService identityService = processEngine.getIdentityService();</span><br><span class="line">    ManagementService managementService = processEngine.getManagementService();</span><br><span class="line">    ProcessEngineConfiguration processEngineConfiguration = processEngine.getProcessEngineConfiguration();  <span class="comment">// 流程引擎配置类</span></span><br><span class="line">    RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">    RuntimeService runtimeService = processEngine.getRuntimeService();                                      <span class="comment">// 运行时</span></span><br><span class="line">    TaskService taskService = processEngine.getTaskService();                                               <span class="comment">// 任务相关</span></span><br><span class="line">    log.info(<span class="string">"dynamicBpmnService: &#123;&#125;"</span>, dynamicBpmnService);                     <span class="comment">// org.activiti.engine.impl.DynamicBpmnServiceImpl@1601e47</span></span><br><span class="line">    log.info(<span class="string">"formEngineFormService: &#123;&#125;"</span>, formEngineFormService);               <span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">"formEngineRepositoryService: &#123;&#125;"</span>, formEngineRepositoryService);   <span class="comment">// null</span></span><br><span class="line">    log.info(<span class="string">"formService: &#123;&#125;"</span>, formService);                                   <span class="comment">// org.activiti.engine.impl.FormServiceImpl@3bffddff</span></span><br><span class="line">    log.info(<span class="string">"historyService: &#123;&#125;"</span>, historyService);                             <span class="comment">// org.activiti.engine.impl.HistoryServiceImpl@66971f6b</span></span><br><span class="line">    log.info(<span class="string">"identityService: &#123;&#125;"</span>, identityService);                           <span class="comment">// org.activiti.engine.impl.IdentityServiceImpl@50687efb</span></span><br><span class="line">    log.info(<span class="string">"managementService: &#123;&#125;"</span>, managementService);                       <span class="comment">// org.activiti.engine.impl.ManagementServiceImpl@517bd097</span></span><br><span class="line">    log.info(<span class="string">"processEngineConfiguration: &#123;&#125;"</span>, processEngineConfiguration);     <span class="comment">// org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration@142eef62</span></span><br><span class="line">    log.info(<span class="string">"repositoryService: &#123;&#125;"</span>, repositoryService);                       <span class="comment">// org.activiti.engine.impl.RepositoryServiceImpl@4a9cc6cb</span></span><br><span class="line">    log.info(<span class="string">"runtimeService: &#123;&#125;"</span>, runtimeService);                             <span class="comment">// org.activiti.engine.impl.RuntimeServiceImpl@5990e6c5</span></span><br><span class="line">    log.info(<span class="string">"taskService: &#123;&#125;"</span>, taskService);                                   <span class="comment">// org.activiti.engine.impl.TaskServiceImpl@56e07a08</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总的来说流程引擎配置类(ProcessEngineConfiguration) 的获取比较简单, 通过默认配置找到 classpath 下的 activiti.cfg.xml 配置文件, 再将该配置文件使用 Spring 的组件完成读取, 将 id 为 <code>processEngineConfiguration</code> 的 bean 完成初始化并返回.</p></blockquote><p><img src="https://user-images.githubusercontent.com/17758731/52964570-96a9a500-33dd-11e9-93fb-e677b4d880ff.png" alt="image"></p><h1 id="1-ProcessEngines"><a href="#1-ProcessEngines" class="headerlink" title="1. ProcessEngines"></a>1. ProcessEngines</h1><p>包含四个重要的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;流程引擎名称, 流程引擎实例&gt;</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Map&lt;String, ProcessEngine&gt; processEngines = <span class="keyword">new</span> HashMap&lt;String, ProcessEngine&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;流程引擎名称, 流程引擎信息类实例&gt;</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByName = <span class="keyword">new</span> HashMap&lt;String, ProcessEngineInfo&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;构造流程引擎的资源名称(如文件路径名), 流程引擎信息类实例&gt;</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl = <span class="keyword">new</span> HashMap&lt;String, ProcessEngineInfo&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储流程引擎信息类实例对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;ProcessEngineInfo&gt; processEngineInfos = <span class="keyword">new</span> ArrayList&lt;ProcessEngineInfo&gt;();</span><br></pre></td></tr></table></figure><h2 id="1-1-getDefaultProcessEngine"><a href="#1-1-getDefaultProcessEngine" class="headerlink" title="1.1. getDefaultProcessEngine"></a>1.1. getDefaultProcessEngine</h2><p>方法体中只有一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title">getDefaultProcessEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProcessEngine(NAME_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中 NAME_DEFAULT 的值是 <code>default</code></p><h2 id="1-2-getProcessEngine-String-processEngineName"><a href="#1-2-getProcessEngine-String-processEngineName" class="headerlink" title="1.2. getProcessEngine(String processEngineName)"></a>1.2. getProcessEngine(String processEngineName)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title">getProcessEngine</span><span class="params">(String processEngineName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processEngines.get(processEngineName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断该类是否已经被初始化<ol><li>如果没有初始化, 执行 <code>init()</code> 方法</li></ol></li><li>返回 <code>Map&lt;String, ProcessEngine&gt; processEngines</code> 对应 key 的实例对象</li></ol><h3 id="1-2-1-isInitialized"><a href="#1-2-1-isInitialized" class="headerlink" title="1.2.1. isInitialized()"></a>1.2.1. isInitialized()</h3><p>返回类中一个静态常量, 用于标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isInitialized;</span><br></pre></td></tr></table></figure><h2 id="1-3-init"><a href="#1-3-init" class="headerlink" title="1.3. init()"></a>1.3. init()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processEngines == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Create new map to store process-engines if current map is</span></span><br><span class="line">            <span class="comment">// null</span></span><br><span class="line">            processEngines = <span class="keyword">new</span> HashMap&lt;String, ProcessEngine&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader classLoader = ReflectUtil.getClassLoader();</span><br><span class="line">        Enumeration&lt;URL&gt; resources = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resources = classLoader.getResources(<span class="string">"activiti.cfg.xml"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"problem retrieving activiti.cfg.xml resources on the classpath: "</span> + System.getProperty(<span class="string">"java.class.path"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remove duplicated configuration URL's using set. Some</span></span><br><span class="line">        <span class="comment">// classloaders may return identical URL's twice, causing duplicate</span></span><br><span class="line">        <span class="comment">// startups</span></span><br><span class="line">        Set&lt;URL&gt; configUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line">        <span class="keyword">while</span> (resources.hasMoreElements()) &#123;</span><br><span class="line">            configUrls.add(resources.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;URL&gt; iterator = configUrls.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            URL resource = iterator.next();</span><br><span class="line">            log.info(<span class="string">"Initializing process engine using configuration '&#123;&#125;'"</span>, resource.toString());</span><br><span class="line">            initProcessEngineFromResource(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resources = classLoader.getResources(<span class="string">"activiti-context.xml"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"problem retrieving activiti-context.xml resources on the classpath: "</span> + System.getProperty(<span class="string">"java.class.path"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (resources.hasMoreElements()) &#123;</span><br><span class="line">            URL resource = resources.nextElement();</span><br><span class="line">            log.info(<span class="string">"Initializing process engine using Spring configuration '&#123;&#125;'"</span>, resource.toString());</span><br><span class="line">            initProcessEngineFromSpringResource(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        setInitialized(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"Process engines already initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>再判断是否已经初始化<ol><li>如果未初始化, 先初始化 <code>Map&lt;String, ProcessEngine&gt; processEngines</code></li><li>获取当前类加载器</li><li>使用该类加载器指定加载 <code>activiti.cfg.xml</code> 路径下的资源, 并保存在 Set 中</li><li>遍历 Set 集合执行 <code>initProcessEngineFromResource(URL resource)</code></li><li>获取 spring 风格配置文件</li><li>将类中 <code>initialized</code> 设置为 true</li></ol></li><li>如果已被初始化, 直接返回</li></ol><h2 id="1-4-initProcessEngineFromResource-URL-resourceUrl"><a href="#1-4-initProcessEngineFromResource-URL-resourceUrl" class="headerlink" title="1.4. initProcessEngineFromResource(URL resourceUrl)"></a>1.4. initProcessEngineFromResource(URL resourceUrl)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessEngineInfo <span class="title">initProcessEngineFromResource</span><span class="params">(URL resourceUrl)</span> </span>&#123;</span><br><span class="line">    ProcessEngineInfo processEngineInfo = processEngineInfosByResourceUrl.get(resourceUrl.toString());</span><br><span class="line">    <span class="comment">// if there is an existing process engine info</span></span><br><span class="line">    <span class="keyword">if</span> (processEngineInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// remove that process engine from the member fields</span></span><br><span class="line">        processEngineInfos.remove(processEngineInfo);</span><br><span class="line">        <span class="keyword">if</span> (processEngineInfo.getException() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String processEngineName = processEngineInfo.getName();</span><br><span class="line">            processEngines.remove(processEngineName);</span><br><span class="line">            processEngineInfosByName.remove(processEngineName);</span><br><span class="line">        &#125;</span><br><span class="line">        processEngineInfosByResourceUrl.remove(processEngineInfo.getResourceUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    String resourceUrlString = resourceUrl.toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"initializing process engine for resource &#123;&#125;"</span>, resourceUrl);</span><br><span class="line">        ProcessEngine processEngine = buildProcessEngine(resourceUrl);</span><br><span class="line">        String processEngineName = processEngine.getName();</span><br><span class="line">        log.info(<span class="string">"initialised process engine &#123;&#125;"</span>, processEngineName);</span><br><span class="line">        processEngineInfo = <span class="keyword">new</span> ProcessEngineInfoImpl(processEngineName, resourceUrlString, <span class="keyword">null</span>);</span><br><span class="line">        processEngines.put(processEngineName, processEngine);</span><br><span class="line">        processEngineInfosByName.put(processEngineName, processEngineInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">"Exception while initializing process engine: &#123;&#125;"</span>, e.getMessage(), e);</span><br><span class="line">        processEngineInfo = <span class="keyword">new</span> ProcessEngineInfoImpl(<span class="keyword">null</span>, resourceUrlString, getExceptionString(e));</span><br><span class="line">    &#125;</span><br><span class="line">    processEngineInfosByResourceUrl.put(resourceUrlString, processEngineInfo);</span><br><span class="line">    processEngineInfos.add(processEngineInfo);</span><br><span class="line">    <span class="keyword">return</span> processEngineInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据路径尝试从 <code>Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl</code> 获取流程引擎类实例<ol><li>如果不为空</li><li>将 <code>List&lt;ProcessEngineInfo&gt; processEngineInfos</code> 中对应的元素删除</li><li>流程引擎信息类实例没有 Exception, 将 <code>Map&lt;String, ProcessEngine&gt; processEngines</code> 和 <code>Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByName</code> 中 key 对应的元素都删除</li><li><code>Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl</code> 中 key 对应的元素也删除.</li></ol></li><li>通过 <code>buildProcessEngine</code> 方法获取 ProcessEngine 对象</li><li>将 <code>Map&lt;String, ProcessEngine&gt; processEngines</code> 和 <code>Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByName</code> 设置对应的 key 和 value</li><li>将 <code>Map&lt;String, ProcessEngineInfo&gt; processEngineInfosByResourceUrl</code> 和 <code>List&lt;ProcessEngineInfo&gt; processEngineInfos</code> 也添加对应元素</li></ol><h2 id="1-5-buildProcessEngine-URL-resource"><a href="#1-5-buildProcessEngine-URL-resource" class="headerlink" title="1.5. buildProcessEngine(URL resource)"></a>1.5. buildProcessEngine(URL resource)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">(URL resource)</span> </span>&#123;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = resource.openStream();</span><br><span class="line">        ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream);</span><br><span class="line">        <span class="keyword">return</span> processEngineConfiguration.buildProcessEngine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"couldn't open resource stream: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtil.closeSilently(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过传入的 URL 获取输入流;</li><li>通过 <code>createProcessEngineConfigurationFromInputStream()</code> 方法获取流程引擎配置对象</li><li>根据流程引擎配置类实例返回流程引擎实例</li><li>关闭流</li></ol><h1 id="2-ProcessEngineConfiguration-类"><a href="#2-ProcessEngineConfiguration-类" class="headerlink" title="2. ProcessEngineConfiguration 类"></a>2. ProcessEngineConfiguration 类</h1><h2 id="2-1-createProcessEngineConfigurationFromInputStream-InputStream-inputStream"><a href="#2-1-createProcessEngineConfigurationFromInputStream-InputStream-inputStream" class="headerlink" title="2.1. createProcessEngineConfigurationFromInputStream(InputStream inputStream)"></a>2.1. createProcessEngineConfigurationFromInputStream(InputStream inputStream)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngineConfiguration <span class="title">createProcessEngineConfigurationFromInputStream</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createProcessEngineConfigurationFromInputStream(inputStream, <span class="string">"processEngineConfiguration"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法只有一行, 用来添加默认的 beanName: <code>processEngineConfiguration</code></p><p>这个 beanName 非常重要, Activiti 要求在配置文件中必须完成 id 为 <code>processEngineConfiguration</code> 的 bean</p><h2 id="2-2-createProcessEngineConfigurationFromInputStream-InputStream-inputStream-String-beanName"><a href="#2-2-createProcessEngineConfigurationFromInputStream-InputStream-inputStream-String-beanName" class="headerlink" title="2.2. createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName)"></a>2.2. createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngineConfiguration <span class="title">createProcessEngineConfigurationFromInputStream</span><span class="params">(InputStream inputStream, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeansConfigurationHelper.parseProcessEngineConfigurationFromInputStream(inputStream, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-BeansConfigurationHelper-类"><a href="#3-BeansConfigurationHelper-类" class="headerlink" title="3. BeansConfigurationHelper 类"></a>3. BeansConfigurationHelper 类</h1><h2 id="3-1-parseProcessEngineConfigurationFromInputStream-InputStream-inputStream-String-beanName"><a href="#3-1-parseProcessEngineConfigurationFromInputStream-InputStream-inputStream-String-beanName" class="headerlink" title="3.1. parseProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName)"></a>3.1. parseProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngineConfiguration <span class="title">parseProcessEngineConfigurationFromInputStream</span><span class="params">(InputStream inputStream, String beanName)</span> </span>&#123;</span><br><span class="line">    Resource springResource = <span class="keyword">new</span> InputStreamResource(inputStream);</span><br><span class="line">    <span class="keyword">return</span> parseProcessEngineConfiguration(springResource, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将输入流转化为 <code>org.springframework.core.io.Resource</code>, Spring 的资源抽象接口, 用于后续的 spring 风格配置文件解析;</li><li>将配置文件解析为 bean, 最终构造 ProcessEngineConfiguration 并返回</li></ol><h2 id="3-2-parseProcessEngineConfiguration-Resource-springResource-String-beanName"><a href="#3-2-parseProcessEngineConfiguration-Resource-springResource-String-beanName" class="headerlink" title="3.2. parseProcessEngineConfiguration(Resource springResource, String beanName)"></a>3.2. parseProcessEngineConfiguration(Resource springResource, String beanName)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngineConfiguration <span class="title">parseProcessEngineConfiguration</span><span class="params">(Resource springResource, String beanName)</span> </span>&#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    xmlBeanDefinitionReader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_XSD);</span><br><span class="line">    xmlBeanDefinitionReader.loadBeanDefinitions(springResource);</span><br><span class="line">    ProcessEngineConfigurationImpl processEngineConfiguration = (ProcessEngineConfigurationImpl) beanFactory.getBean(beanName);</span><br><span class="line">    processEngineConfiguration.setBeans(<span class="keyword">new</span> SpringBeanFactoryProxyMap(beanFactory));</span><br><span class="line">    <span class="keyword">return</span> processEngineConfiguration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建 BeanFactory;</li><li>创建 XmlBeanDefinitionReader, 用于读取 XML 中的 bean 定义;</li><li>指定 XML 验证方式为 XSD;</li><li>读取配置文件资源;</li><li>根据 beanName 从 beanFactory 中获取指定对象, 并强转为 ProcessEngineConfigurationImpl;</li></ol><h1 id="4-回到-ProcessEngines-类中"><a href="#4-回到-ProcessEngines-类中" class="headerlink" title="4. 回到 ProcessEngines 类中"></a>4. 回到 ProcessEngines 类中</h1><p>此时已经完成了 <code>ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream);</code> 的执行, 得到了 ProcessEngineConfiguration 对象, 接下来调用 <code>processEngineConfiguration.buildProcessEngine()</code> 来获取 ProcessEngine 并返回.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Activiti 配置风格获取引擎源码分析: &lt;/p&gt;
&lt;p&gt;流程引擎管理类 ProcessEngines&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="activiti" scheme="https://destinywang.github.io/blog/categories/activiti/"/>
    
      <category term="源码" scheme="https://destinywang.github.io/blog/categories/activiti/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="activiti" scheme="https://destinywang.github.io/blog/tags/activiti/"/>
    
  </entry>
  
</feed>
